<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="zhenby's blog">
<meta property="og:url" content="http://zhenby.com/index.html">
<meta property="og:site_name" content="zhenby's blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zhenby's blog">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> zhenby's blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-32727809-1', 'auto');
  ga('send', 'pageview');
</script>







  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">zhenby's blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-iread">
          <a href="/iread" rel="section">
            
              <i class="menu-item-icon fa fa-question-circle fa-fw"></i> <br />
            
            我读
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/02/23/16nian-1yue-fen-du-shu-liang-ben/" itemprop="url">
                  16年1月读书两本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-02-23T13:42:00+08:00" content="2016-02-23">
              2016-02-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/02/23/16nian-1yue-fen-du-shu-liang-ben/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2016/02/23/16nian-1yue-fen-du-shu-liang-ben/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《彷徨之刃》★★★★☆"><a href="#《彷徨之刃》★★★★☆" class="headerlink" title="《彷徨之刃》★★★★☆"></a>《彷徨之刃》★★★★☆</h2><p><img src="http://pic.zhenby.com/The-Hovering-Blade.jpg" alt="东野圭吾 著，刘珮瑄 译"></p>
<p>一个未成年人犯罪，而因为日本司法制度对于未成年人犯罪的宽容，受害者的父亲选择自己制裁凶手的故事。</p>
<p>对待未成年人的犯罪，日本司法制度上异常宽容：不会被公布姓名，刑期很短，案子也不会被公开审理。这是从凶手的角度上去考虑，考虑到他们心智还不成熟，给他们较轻的处罚，从而让他们在接下来漫长的人生历程中有机会改正，重新做一个对社会有用的人。而从受害者的角度考虑，很明显，凶手是没得到应有的惩罚的。<br>而社会背景则是大部分人，对案子无动于衷，顶多是可怜一下受害者；媒体为了博眼球，大势宣传，消费这个悲惨故事；邻居把这个故事作为茶余饭后八卦的话题；只有受害者，忍受着失去女儿的痛苦。</p>
<p>查了一下相关的资料：<a href="http://www.nippon.com/hk/features/h00105/?pnum=1" target="_blank" rel="external">川崎市國中一年級學生被殺，修改《少年法》呼聲再度高漲</a>，日本到现在还是是有发生类似的事件，每次发生这样的事件，修改《少年法》的呼声就会出现。法律的条文也在不断的修正，现在的法律制度不是完全公正正义的。所谓的真正公正正义到底是什么？世界都在寻找答案。</p>
<h2 id="《岛上书店》★★★★☆"><a href="#《岛上书店》★★★★☆" class="headerlink" title="《岛上书店》★★★★☆"></a>《岛上书店》★★★★☆</h2><p><img src="http://pic.zhenby.com/The-Storied-Life-of-A.J.Fikry.jpg" alt="加布瑞埃拉·泽文 著，孙仲旭/李玉瑶 译"></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2016/01/23/15nian-12yue-kan-shu-liang-ben/" itemprop="url">
                  15年12月读书两本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-01-23T20:21:00+08:00" content="2016-01-23">
              2016-01-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2016/01/23/15nian-12yue-kan-shu-liang-ben/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2016/01/23/15nian-12yue-kan-shu-liang-ben/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《追风筝的人》★★★★★"><a href="#《追风筝的人》★★★★★" class="headerlink" title="《追风筝的人》★★★★★"></a>《追风筝的人》★★★★★</h2><p><img src="http://pic.zhenby.com/The-Kite-Runner.jpg" alt="卡勒德·胡赛尼 著，李继宏 译"></p>
<p>这是一本关于<strong>友谊</strong>、<strong>等级</strong>、<strong>救赎</strong>及<strong>战争</strong>的故事。</p>
<p>关于<strong>战争</strong>，阿米尔跟他爸之前平静的生活，被战争彻底改变，远离家乡，融入美国，而家乡已经变成一片废墟，生灵涂炭，让人不寒而栗。而现在 ISIS 在中东造成的破坏，不比那时的塔利班轻，这些以宗教的名义，迫害普通老百姓的行径真让人不齿。人民无力改变，感到绝望，更可怕的是，小孩从小在这样的环境下长大，接受极端思想的教育，对世界充满仇恨，这些现在是 ISIS 统治地区人民的日常，想想都觉的很可怕。</p>
<h2 id="《人类简史-从动物到上帝》★★★★★"><a href="#《人类简史-从动物到上帝》★★★★★" class="headerlink" title="《人类简史-从动物到上帝》★★★★★"></a>《人类简史-从动物到上帝》★★★★★</h2><p><img src="http://pic.zhenby.com/Brief-History-Humankind.jpg" alt="尤瓦尔·赫拉利 著，林俊宏 译"></p>
<p>这本书讲述了：把时间跨度拉长，看人类是怎么从猿人，到智人，再经历认知革命，农业革命，科学革命走到今天统治世界的地位的。在讲述的过程中，有很多有意思的观点：</p>
<ul>
<li><p>智人这一分支打败其他分支的人种，开始统治世界。而让智人脱颖而出的是<strong>语言</strong>及<strong>想象力</strong>。人类语言比其他动物的语言更丰富更多样，也有说因为智人要交流八卦，所以需要很多语言上的交流，从而让他们脱颖而出；而想象力则是智人特有的，通过想象出一些现实世界中不存在的东西，并且还能让别人相信，从而有共同的立场，这就是宗教、国家、公司的前身。</p>
</li>
<li><p>智人所到之处，当地的很多物种就开始<strong>灭亡</strong>，特别是大型动物，作者没有一口咬定就是智人导致了这些物种的灭亡，但是通过对比智人到达一个地方的时间以及该地方的大型动物开始灭亡的时间来看，基本可以确定跟智人是有很大关系的。智人每去到一个地方，会对当地的资源进行采集，一开始当地物种觉得智人根本没什么威胁，而事实上智人的智力已经甩它们几条街了，可以通过火、团队作战、陷阱等方式轻松打猎。而等到这些物种身上将要进化出怕智人的基因时，它们已经灭绝。</p>
</li>
<li><p>人类在农业革命后，陷入了<strong>虚荣陷阱</strong>，以为会过得越来越轻松，事实上，人类在农业革命后过的比农业革命前还惨，因为安定聚集起来了，人口上去了，一旦粮食欠收就会导致饥饿，人群聚集使传染病更容易传播，农活也限制了人类的活动范围。</p>
</li>
<li><p>书中说了另一种<strong>农业革命</strong>发生的可能：因为<strong>宗教的原因</strong>，需要在某个圣地建宏伟的建筑，从而需要做大量的集中体力活，导致人类聚集，然后驯化了小麦，人类也因为虔诚而聚集在宗教点附近。</p>
</li>
<li><p>从<strong>动植物的角度看农业革命</strong>，就很惨了，羊牛鸡鸭命运都很曲折，有得要一直怀孕挤奶，有得刚生出来不久就要被杀做成食物，有得要一直做苦力活。</p>
</li>
<li><p>讲到<strong>不公平</strong>产生的原因，是因为<strong>历史偶然事件</strong>的发生，让白人，雅利安人占据了领导地位。而为了巩固他们的统治，握有权利的他们，可以结合社会各方面（宗教、身体结构、智力等）对黑人，印度人产生歧视，从而让他们自己的地位高人一等，让黑人，印度人地位低的可怜。一旦社会地位低，向上的机会就会减少，而社会又会拿「黑人、印度人很少从事某个职位」这种观点来证明他们是低人一级的，这是一个恶性循环。</p>
</li>
<li><p>什么行为是自然的，什么行为是不自然的？在人类的大部分阶段，异性之间的性行为是自然的，同性之间的性行为是不自然的，这个自然与不自然的划分，是文化造成的，「<strong>天生带来允许，文化造成封闭</strong>」。人类的一些器官如果都按「自然」的方式使用，那亲吻也是不自然的，因为嘴巴生来是吃东西的。</p>
</li>
<li><p>科学革命，1860 年代的世界，西方已因为科学革命上升了一个维度，打中国绰绰有余。而科学革命的前提，是<strong>承认自己的无知</strong>，<strong>放下身段</strong>，<strong>才能去探索</strong>。资本主义与科学是现代社会的基石。</p>
</li>
</ul>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2015/12/12/15nian-11yue-du-shu-san-ben/" itemprop="url">
                  15年11月读书三本
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-12-12T12:20:00+08:00" content="2015-12-12">
              2015-12-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/读书/" itemprop="url" rel="index">
                    <span itemprop="name">读书</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2015/12/12/15nian-11yue-du-shu-san-ben/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2015/12/12/15nian-11yue-du-shu-san-ben/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="《天才在左，疯子在右》★★★☆☆"><a href="#《天才在左，疯子在右》★★★☆☆" class="headerlink" title="《天才在左，疯子在右》★★★☆☆"></a>《天才在左，疯子在右》★★★☆☆</h2><p><img src="http://pic.zhenby.com/tiancai.png" alt="高铭 著"></p>
<p>这书一直躺在我的书单里，上次同事极力推荐，就买了电子书看。一开始看挺震撼的，一群在我们世俗眼光下不正常的人，一个个却都有一些很特别的世界观，让你换个角度去看世界，觉的一切很新鲜。</p>
<p>里面有各种大开脑洞的想法，有觉得石头是一种生命，观察石头很久不动是因为我们的时间对于石头来说只是很少的瞬间；蚂蚁群是生命，蚂蚁只是细胞；里面住着三个多重人格的人，三个人格被杀剩一个；觉得自己是一本小说主角，你只是他小说中的一个人物的男人；与四维生物交流，我们在四维生物眼中都是一条虫子，时间是虫子的长度，从一个时间点开始，从另一个时间点结束，就是虫子；还有对宗教虔诚到极点，到走火入魔，变成信仰魔鬼，从而衬托出神的伟大的男人。</p>
<p>最喜欢的一节是说玛雅文明的，探索一种未知文字可先从数字入手，看哪些字是表达一、二、三这些数字的，然后再看数字前后跟的名词，然后再推测。而玛雅文明的特点是文字描述很简单，重视祭祀，现实中没有车轮，却有车轮祭品，对天文很在行。作者推断玛雅文明之前是有一个上层文明的，可能来至宇宙，这样部分疑惑就比较容易解释了。</p>
<p>本来觉的这书挺不错的，但是读到最后，竟然看到「这里有近 20 余篇是真实案例；也有些是出于一些原因，我基于真实案例在内容赏做了增添或者删减」，我感觉被欺骗了，这本书的副标题明明叫：国内第一本精神病人访谈手记。</p>
<h2 id="《秘密》★★★★★"><a href="#《秘密》★★★★★" class="headerlink" title="《秘密》★★★★★"></a>《秘密》★★★★★</h2><p><img src="http://pic.zhenby.com/secret.png" alt="东野圭吾 著"></p>
<p>很好的一本小说，结尾很震惊。东野圭吾的小说一旦开始读，总是放不下手。</p>
<p>车祸，母亲死了，女儿重伤，最后发现母亲的灵魂交换到女儿身上，父亲开始与女儿身，妈妈魂的一个人相依为命；想象这情景套到自己身上，也是非常棘手。<br>一老一少，生活还得继续，<br>老的要上班，少的要上学，<br>老的生活枯燥乏味，少的生活多姿多彩。<br>老的终究要被青春抛弃。</p>
<h2 id="《蒋介石传》-★★★☆☆"><a href="#《蒋介石传》-★★★☆☆" class="headerlink" title="《蒋介石传》 ★★★☆☆"></a>《蒋介石传》 ★★★☆☆</h2><p><img src="http://pic.zhenby.com/Chiang-Kai-shek.png" alt="布赖恩·克罗泽 著"></p>
<p>书一般，基本是一本蒋的大事记。</p>
<p>我们用现在的眼光去看历史，总是马后炮的说：这选择是错的，应该这样这样做，仿佛按照我们的想法做，历史就能按照我们预想的发展。我在看这书的时候就多次有这样的想法，比如九一八时蒋介石让张学良不抵抗，再比如西安事变后，张学良被软禁，而国共内战期间，蒋介石不愿意把张学良放回东北战场…</p>
<p>我们无法亲身体会的感受到人物当时面临的众多选择，更多的是应该理解人物当时的选择。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2013/10/10/blink-support-ios-7-now/" itemprop="url">
                  BLink V1.5 兼容iOS 7了
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-10-10T17:25:00+08:00" content="2013-10-10">
              2013-10-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/作品/" itemprop="url" rel="index">
                    <span itemprop="name">作品</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2013/10/10/blink-support-ios-7-now/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2013/10/10/blink-support-ios-7-now/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://pic.zhenby.com/BLink-iOS7.png" alt="BLink in iOS 7">  </p>
<h2 id="之前为什么不兼容-iOS-7"><a href="#之前为什么不兼容-iOS-7" class="headerlink" title="之前为什么不兼容 iOS 7"></a>之前为什么不兼容 iOS 7</h2><p>我在上一篇博客<a href="http://zhenby.com/blog/2013/09/12/blink/">第一个收费应用-BLink</a>中提到过，BLink 不兼容 iOS 7 是因为 iOS 7 的 bug，那时候因为 iOS 7 还在测试阶段，因为 NDA 的原因，我没细说那个 bug：  </p>
<blockquote>
<p>在 iOS 7 中，在 Web App 的全屏模式下（standlone），所有会离开当前浏览会话的 JS 执行都无效。比如，在全屏模式下，执行一个 JS 的 alert 语句无效，使用 JS 打开一个应用的 URL Scheme 也会无效。  </p>
</blockquote>
<p>因为 BLink 的快捷方式实际上就是一个桌面书签，会通过是否全屏模式做不同的操作：非全屏模式下，提示用户添加书签到桌面上；全屏模式下，直接打开一个 URL Scheme。<br>因为 iOS 7 的这个 bug，在全屏模式下打开一个应用的 URL Scheme 无效了，所以 BLink 在 iOS 7 下的快捷方式打开后只会是一个白屏。  </p>
<h2 id="别对苹果修-bug-抱太大希望，要有-Plan-B"><a href="#别对苹果修-bug-抱太大希望，要有-Plan-B" class="headerlink" title="别对苹果修 bug 抱太大希望，要有 Plan B"></a>别对苹果修 bug 抱太大希望，要有 Plan B</h2><p>这个 bug 从 iOS 7 测试版本就一直存在，具体从 beta 几开始我没测试，我从 iOS 7 beta 4 开始试用 iOS 7，就发现了这个 bug，我一直认为现在是 iOS 7 的测试版本，有 bug 很正常，看到苹果开发者论坛上也有人已经报 bug 给苹果了，所以我是幻想着苹果能在 iOS 7 正式版本之前解决这个 bug 的。<br>但是到了 beta 6，再到9月10号苹果发布会后发布的 GM版，这个 bug 还是一直存在。<br>我这个时候还是幻想着苹果能在正式版的时候解决这个 bug，毕竟这是个大问题阿，所有全屏 Web App 都会受影响，连 alert 都 alert 不了。<br>所以在这段 iOS 7 测试版本期间，我没有做任何的行动，也没想好一直幻想着正式版本能正常工作。<br>但是在9月18号的时候，iOS 7 正式版发布，我测试后，问题依旧阿。我X，而且发现正式版根本就是 GM 版，一个星期一个问题都没解决阿，顿时对苹果失望至极。  </p>
<p>因为之前对苹果修 bug 抱太大希望，我根本没考虑 Plan B，所以正式版发布后，一天几个一星差评，几封反馈的邮件。<br>这是教训阿，以后对这种大版本的更新，在最后的 GM 版本，如果还有问题，就应该尽快想 Plan B，并尽快上线新版本，并且，再加根据系统版本的远程开关，这样即使正式版本修复了，也可以远程控制是否启用 Plan B。  </p>
<h2 id="怎么解决的"><a href="#怎么解决的" class="headerlink" title="怎么解决的"></a>怎么解决的</h2><p>解决的过程比较曲折，我尝试了使用 Local Storage 以及 Web SQL Database 来保存「是否将快捷方式添加到桌面」的标识，由于我的快捷方式的书签地址为 data:text/html 类型的，都无法使用 Local Storeage 及 Web SQL Database。<br>一开始一筹莫展，想不到好的办法解决，最后参考了一个同类型的 App，他们是使用安装「描述文件」的方式来生成桌面快捷方式。这种方式我一开始是抗拒的，因为用户不了解什么是描述文件，也不确定安装完后会不会对设备造成其他影响，而且由于我没买电子签名证书，所以我生成的描述文件在设备上安装时，会显示「未签名」的，这也会让用户疑惑。但是实在找不到其他的解决办法，最后只能在安装过程中提示用户「安装此描述文件只会在你的设备主屏幕上添加一个快捷方式，不会修改你设备上的任何设置，所以无需担心描述文件未签名的问题。」  </p>
<p><img src="http://pic.zhenby.com/Profile.png" alt="Install the Profile">  </p>
<p>然后，解决了这个问题后，我又发现了一个 bug，在 iOS 7 中，从原生的应用中尝试打开电话的 URL Scheme 时，会卡个10秒，拨号的界面才会出现，电话已经拨通了，但是界面却一直卡在打开的原生应用中。<br>这是恶心的问题阿，最后只能直接通过 Safari 打开电话的 URL Scheme，这就导致了每次都会出现一个确认框，用户体验又下降一大截了。  </p>
<p><img src="http://pic.zhenby.com/Confim.png" alt="Confirmation box">  </p>
<p>所以在 iOS 7 中，现在的 BLink 只能算个半成品，只是达到勉强可用的状态，希望苹果尽快发布新的 iOS 7 版本，可能修复这些 bug。  </p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>这件事后，我思考了一下，为什么 BLink 会遇到这样的窘境，我发现是因为 BLink 太依赖 iOS 中原生的其他应用了，整个应用流程不能在 BLink 里面单独完成，在 BLink 中完成一部分操作，跳出 BLink，再在其他地方完成另一部分操作。而依赖越多，那么限制也会越多，毕竟依赖的这部分你是无法控制的。<br>所以我的下个应用，我希望能做一个独立的，拥有完整用户体验的一个应用。  </p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2013/09/12/blink/" itemprop="url">
                  第一个收费App——BLink
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-09-12T20:24:00+08:00" content="2013-09-12">
              2013-09-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/作品/" itemprop="url" rel="index">
                    <span itemprop="name">作品</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2013/09/12/blink/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2013/09/12/blink/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近新上架了第一个收费作品：<a href="https://itunes.apple.com/us/app/blink-contact-shortcuts-contact/id684640621?ls=1&amp;mt=8" target="_blank" rel="external">BLink</a>  </p>
<p><img src="http://pic.zhenby.com/BLink-Screenshot-1.png" alt="BLink 0"><img src="http://pic.zhenby.com/BLink-Screenshot-2.png" alt="BLink 1"></p>
<h2 id="做什么的"><a href="#做什么的" class="headerlink" title="做什么的"></a>做什么的</h2><p>这是一个用来创建联系人快捷方式的 App，用户可以用照片，或者内置的头像在桌面上创建一个用于打电话、发短信、发邮件的快捷图标。  </p>
<h2 id="原理很简单"><a href="#原理很简单" class="headerlink" title="原理很简单"></a>原理很简单</h2><p>如果大家用过 BLink 的话，就会知道它的工作原理还是很简单的，生成图标必须依靠 Safari，所以每个快捷方式其实就是一个 Web Clip，判断到是全屏启动的，则直接跳转到一个 URL Scheme。  </p>
<h2 id="限免"><a href="#限免" class="headerlink" title="限免"></a>限免</h2><p>由于是第一个收费作品，所以没经验，早上六点多审核通过上线的，中午十二点我就把他设置成限免了，后来 bang 提醒我，设置的太快了，收费的时间太短，这样限免的网站爬不到价格变化，就不会推荐了。</p>
<p>果然，我搜了又搜，限免网站上都找不到推荐，只能自己在<a href="http://www.iapps.im/single/16644" target="_blank" rel="external">爱应用</a>上自推了一下，编辑觉的不错，就推荐了。其他中文网站看到后，也做了不少推荐，所以量还不错。但是都是大中华地区的，我本来定位的主要付费市场是在欧美的，由于限免时机设置的不好，欧美的量少的可怜。  </p>
<p>所以第一次上线的时候，可以收费几天，然后再设置限免，这样限免的效果比较好。如果本来已经有收费版本上线了，只是更新版本而已，那审核通过后，可以马上设置成限免。  </p>
<p>收费后，BLink 最高的时候冲到了中国区付费总榜单的第30名左右。第二天出销售报告的时候才知道，付费总榜单第30名的钱也没多少钱，单靠这点钱，那些主要市场在中国区的付费应用的公司真没法活。  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="不兼容-iOS-7"><a href="#不兼容-iOS-7" class="headerlink" title="不兼容 iOS 7"></a>不兼容 iOS 7</h3><p>由于 iOS 7 当前的测试版本有 bug，BLink 创建的快捷方式在 iOS 7 上打开后，一片空白，不能打电话，也不能调出发信息、发邮件的界面。因为这个 bug，中国区的用户有几个上来就直接给一星，写说不能兼容 iOS 7，中国区的用户就喜欢尝鲜啊。<br>对于这个 bug，我试了几种办法，都不能规避它，只能让苹果解决了，已经有国外开发者把这个 bug 提交给苹果了(<a href="https://devforums.apple.com/message/885521#885521" target="_blank" rel="external">Apple Developer 论坛对此 bug 的讨论</a>)，但是在苹果发布会上发布的 iOS 7 GM 版本上，此 bug 依然存在。希望18号发布的 iOS 7 正式版能解决此问题。  </p>
<h3 id="快捷方式启动慢"><a href="#快捷方式启动慢" class="headerlink" title="快捷方式启动慢"></a>快捷方式启动慢</h3><p>这个问题我只能尽量的优化，因为是使用 Web Clip 作为快捷方式的，所以快捷方式启动的快慢主要取决于 Web Clip 的加载速度，其他耗时的过程，包括从 Safari 切换到具体应用，具体应用的打开，我不能干预。所以我能做的，只能是缩小 Web Clip 的体积。测试了一天，终于大大缩小了 Web Clip 的体积。优化后的版本为 V1.1 版本，很快就能上线。   </p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2013/08/20/talk-ios-orientation/" itemprop="url">
                  iOS 屏幕方向那点事儿
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-08-20T19:26:00+08:00" content="2013-08-20">
              2013-08-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程技术/" itemprop="url" rel="index">
                    <span itemprop="name">编程技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2013/08/20/talk-ios-orientation/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2013/08/20/talk-ios-orientation/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般的应用，只会支持竖屏正方向一个方向，支持多个屏幕方向的应用还是比较少的。<br>不过我在工作的项目中，跟这个屏幕方向接触比较多，因为我们是一个有界面的 SDK，要让接入方接入的，一开始做没什么经验，考虑到接入方本身的屏幕方向可能是多种的，所以我们直接上来就支持四个方向，然后就是各种转屏的问题，90度旋转、180读旋转、270度旋转，测试手都快转断了。<br>后来觉的根本没必要，浪费了很多时间在解决屏幕方向的问题上，后来就简化到让接入方直接设置支持某个方向了。  </p>
<p>一般的应用不用搞的这么的复杂，只要支持一两个屏幕方向就可以了。我也做一下跟屏幕方向有关的几点总结，希望能帮到一些开发者！  </p>
<h2 id="系统屏幕方向枚举"><a href="#系统屏幕方向枚举" class="headerlink" title="系统屏幕方向枚举"></a>系统屏幕方向枚举</h2><p>通过查看文档，用于控制系统屏幕方向的枚举如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iOS 6 之前用于控制屏幕方向的枚举</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortrait</span>           = <span class="built_in">UIDeviceOrientationPortrait</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span> = <span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>      = <span class="built_in">UIDeviceOrientationLandscapeRight</span>,</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationLandscapeRight</span>     = <span class="built_in">UIDeviceOrientationLandscapeLeft</span></span><br><span class="line">&#125; <span class="built_in">UIInterfaceOrientation</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iOS 6 及之后版本用于控制屏幕方向的枚举</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortrait</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortrait</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span> = (<span class="number">1</span> &lt;&lt; <span class="built_in">UIInterfaceOrientationPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskLandscape</span> = (<span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAll</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> |</span><br><span class="line">			   <span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span> | <span class="built_in">UIInterfaceOrientationMaskPortraitUpsideDown</span>),</span><br><span class="line">    <span class="built_in">UIInterfaceOrientationMaskAllButUpsideDown</span> = (<span class="built_in">UIInterfaceOrientationMaskPortrait</span> | <span class="built_in">UIInterfaceOrientationMaskLandscapeLeft</span> |</span><br><span class="line">						<span class="built_in">UIInterfaceOrientationMaskLandscapeRight</span>),</span><br><span class="line">&#125; <span class="built_in">UIInterfaceOrientationMask</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以发现：</p>
<ul>
<li>iOS 6 及之后版本使用的 UIInterfaceOrientationMask 类型来控制屏幕屏幕方向，该类型也新增加了几个枚举取值，可用一个枚举取值来代表多个屏幕方向。  </li>
<li>四个基本屏幕方向（上、下、左、右）中，<code>UIInterfaceOrientationMask = (1 &lt;&lt; UIInterfaceOrientation)</code>，所以，如果你的应用中需要动态的将 UIInterfaceOrientation 类型转换成 UIInterfaceOrientationMask 类型的话，只需做一下上面的转换即可，不需要通过 switch 来判断再转换。   </li>
</ul>
<h2 id="怎么控制屏幕方向"><a href="#怎么控制屏幕方向" class="headerlink" title="怎么控制屏幕方向"></a>怎么控制屏幕方向</h2><p>在 iOS 的应用中，有多种方式可以控制界面的屏幕方向，有全局的，有针对 UIWindow 中界面的控制，也有针对单个界面。  </p>
<h3 id="单个界面控制"><a href="#单个界面控制" class="headerlink" title="单个界面控制"></a>单个界面控制</h3><h4 id="iOS-6之前"><a href="#iOS-6之前" class="headerlink" title="iOS 6之前"></a>iOS 6之前</h4><p>在 iOS 6 之前，单个界面的屏幕方向控制，都使用 UIViewController 类中的这个方法：  </p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否支持旋转到某个屏幕方向</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldAutorotateToInterfaceOrientation:(<span class="built_in">UIInterfaceOrientation</span>)toInterfaceOrientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((toInterfaceOrientation == <span class="built_in">UIInterfaceOrientationLandscapeRight</span>) |</span><br><span class="line">	            (toInterfaceOrientation == <span class="built_in">UIInterfaceOrientationLandscapeLeft</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下，此方法只有参数为 UIInterfaceOrientationPortrait 时，返回值才为真，即默认只支持竖屏向上。上面的例子中，表示支持横屏向右及横屏向左两个方向。    </p>
<h3 id="iOS-6及之后的版本"><a href="#iOS-6及之后的版本" class="headerlink" title="iOS 6及之后的版本"></a>iOS 6及之后的版本</h3><p>在 iOS 6 及之后的版本，单个界面的屏幕方向控制，要使用 UIViewController 在 iOS 6.0 中新增加的两个方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 是否支持转屏</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)shouldAutorotate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持的屏幕方向，此处可直接返回 UIInterfaceOrientationMask 类型</span></span><br><span class="line"><span class="comment">// 也可以返回多个 UIInterfaceOrientationMask 取或运算后的值</span></span><br><span class="line">- (<span class="built_in">NSUInteger</span>)supportedInterfaceOrientations</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscape</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>- supportedInterfaceOrientations</code> 方法在 iPad 中默认取值为 UIInterfaceOrientationMaskAll，即默认支持所有屏幕方向；而 iPhone 跟 iPod Touch 的默认取值为 UIInterfaceOrientationMaskAllButUpsideDown，即支持除竖屏向下以外的三个方向。<br>在设备屏幕旋转时，系统会调用 <code>- shouldAutorotate</code> 方法检查当前界面是否支持旋转，只有 <code>- shouldAutorotate</code> 返回 YES 的时候，<code>- supportedInterfaceOrientations</code> 方法才会被调用，以确定是否需要旋转界面。  </p>
<h3 id="UIWindow中的界面控制-iOS-6及以上版本才有效"><a href="#UIWindow中的界面控制-iOS-6及以上版本才有效" class="headerlink" title="UIWindow中的界面控制(iOS 6及以上版本才有效)"></a>UIWindow中的界面控制(iOS 6及以上版本才有效)</h3><p>在 iOS 6 中，UIApplicationDelegate 协议中添加了一个可以指定 UIWindow 中的界面的屏幕方向的方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">        supportedInterfaceOrientationsForWindow:(<span class="built_in">UIWindow</span> *)window</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIInterfaceOrientationMaskLandscape</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此方法的默认值为 Info.plist 中配置的 Supported interface orientations 项的值。<br>一般我们都不会创建其他的 UIWindow，所以通过这个方法，也可以达到全局控制。  </p>
<h3 id="全局控制"><a href="#全局控制" class="headerlink" title="全局控制"></a>全局控制</h3><p>在应用的 Info.plist 文件中，有一个 Supported interface orientations 的配置，可以配置整个应用的屏幕方向，如下图：<br><img src="http://pic.zhenby.com/PlistOrientation.png" alt="Supported interface orientations"></p>
<p>此配置其实跟工程中 Target 的 Summary 界面中的 Supported interface orientations 配置是一致的，修改任意一边，另一个边都会同步的修改。<br><img src="http://pic.zhenby.com/TargetSummary.png" alt="Target Summary"></p>
<p>并且，应用在启动时，会使用 Info.plist 中的 Supported interface orientations 项中的第一个值作为启动动画的屏幕方向。按照此处截图的取值，第一个取值为 <code>Portrait(top home button)</code>，即竖屏反方向，所以此应用在启动时，会使用竖屏反方向显示启动动画。  </p>
<h2 id="多种控制共存的规则"><a href="#多种控制共存的规则" class="headerlink" title="多种控制共存的规则"></a>多种控制共存的规则</h2><ul>
<li>一个界面最后支持的屏幕方向，是取 <code>(全局控制 ∩ UIWindow 中的界面控制 ∩ 单个界面控制)</code> 的交集，如果全局控制支持所有屏幕方向，UIWindow 中的界面控制支持横屏，当个界面中只是支持横屏向右，那么最后界面只会以横屏向右显示，并且不支持旋转到其他的方向。  </li>
<li>如果以上三种控制支持的屏幕方向最后的交集为空，iOS 5 跟 iOS 6 的处理有点不同，在 iOS 6 下，甚至会直接抛出 <code>UIApplicationInvalidInterfaceOrientationException</code> 的异常，然后直接崩溃，所以还是要保持这三个值的交集为非空。  </li>
</ul>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2013/05/16/cordova-for-ios/" itemprop="url">
                  浅析 Cordova for iOS
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-05-16T10:54:00+08:00" content="2013-05-16">
              2013-05-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程技术/" itemprop="url" rel="index">
                    <span itemprop="name">编程技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2013/05/16/cordova-for-ios/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2013/05/16/cordova-for-ios/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://cordova.apache.org/" target="_blank" rel="external">Cordova</a>，对这个名字大家可能比较陌生，大家肯定听过 PhoneGap 这个名字，Cordova 就是 PhoneGap 被 Adobe 收购后所改的名字。</p>
<p>Cordova 是一个可以让 JS 与原生代码(包括 Android 的 java，iOS 的 Objective-C 等)互相通信的一个库，并且提供了一系列的插件类，比如 JS 直接操作本地数据库的插件类。</p>
<p>这些插件类都是基于 JS 与 Objective-C 可以互相通信的基础的，这篇文章说说 Cordova 是如何做到 JS 与 Objective-C 互相通信的，解释如何互相通信需要弄清楚下面三个问题：  </p>
<ol>
<li>JS 怎么跟 Objective-C 通信  </li>
<li>Objective-C 怎么跟 JS 通信  </li>
<li>JS 请求 Objective-C，Objective-C 返回结果给 JS，这一来一往是怎么串起来的  </li>
</ol>
<p>Cordova 现在最新版本是 2.7.0，本文也是基于 2.7.0 版本进行分析的。 </p>
<h2 id="JS-怎么跟-Objective-C-通信"><a href="#JS-怎么跟-Objective-C-通信" class="headerlink" title="JS 怎么跟 Objective-C 通信"></a>JS 怎么跟 Objective-C 通信</h2><p>JS 与 Objetive-C 通信的关键代码如下：(点击代码框右上角的文件名链接，可直接跳转该文件在 github 的地址)<br><figure class="highlight js"><figcaption><span>JS 发起请求</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/cordova.js" target="_blank" rel="external">cordova.js</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iOSExec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line"> 	if (!isInContextOfEvalJs &amp;&amp; commandQueue.length == <span class="number">1</span>) 	&#123;</span><br><span class="line"> 		<span class="comment">// 如果支持 XMLHttpRequest，则使用 XMLHttpRequest 方式</span></span><br><span class="line">    	<span class="keyword">if</span> (bridgeMode != jsToNativeModes.IFRAME_NAV) &#123;</span><br><span class="line">            <span class="comment">// This prevents sending an XHR when there is already one being sent.</span></span><br><span class="line">            <span class="comment">// This should happen only in rare circumstances (refer to unit tests).</span></span><br><span class="line">            <span class="keyword">if</span> (execXhr &amp;&amp; execXhr.readyState != <span class="number">4</span>) &#123;</span><br><span class="line">                execXhr = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Re-using the XHR improves exec() performance by about 10%.</span></span><br><span class="line">            execXhr = execXhr || <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">            <span class="comment">// Changing this to a GET will make the XHR reach the URIProtocol on 4.2.</span></span><br><span class="line">            <span class="comment">// For some reason it still doesn't work though...</span></span><br><span class="line">            <span class="comment">// Add a timestamp to the query param to prevent caching.</span></span><br><span class="line">            execXhr.open(<span class="string">'HEAD'</span>, <span class="string">"/!gap_exec?"</span> + (+<span class="keyword">new</span> <span class="built_in">Date</span>()), <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (!vcHeaderValue) &#123;</span><br><span class="line">                vcHeaderValue = <span class="regexp">/.*\((.*)\)/</span>.exec(navigator.userAgent)[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            execXhr.setRequestHeader(<span class="string">'vc'</span>, vcHeaderValue);</span><br><span class="line">            execXhr.setRequestHeader(<span class="string">'rc'</span>, ++requestCount);</span><br><span class="line">            <span class="keyword">if</span> (shouldBundleCommandJson()) &#123;</span><br><span class="line">            	<span class="comment">// 设置请求的数据</span></span><br><span class="line">                execXhr.setRequestHeader(<span class="string">'cmds'</span>, iOSExec.nativeFetchMessages());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发起请求</span></span><br><span class="line">            execXhr.send(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        	<span class="comment">// 如果不支持 XMLHttpRequest，则使用透明 iframe 的方式，设置 iframe 的 src 属性</span></span><br><span class="line">            execIframe = execIframe || createExecIframe();</span><br><span class="line">            execIframe.src = <span class="string">"gap://ready"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>JS 使用了<strong>两种方式</strong>来与 Objective-C 通信，一种是使用 XMLHttpRequest 发起请求的方式，另一种则是通过设置透明的 iframe 的 src 属性，下面详细介绍一下两种方式是怎么工作的：</p>
<h3 id="XMLHttpRequest-bridge"><a href="#XMLHttpRequest-bridge" class="headerlink" title="XMLHttpRequest bridge"></a>XMLHttpRequest bridge</h3><p>JS 端使用 XMLHttpRequest 发起了一个请求：<code>execXhr.open(&#39;HEAD&#39;, &quot;/!gap_exec?&quot; + (+new Date()), true);</code> ，请求的地址是 <code>/!gap_exec</code>；并把请求的数据放在了请求的 header 里面，见这句代码：<code>execXhr.setRequestHeader(&#39;cmds&#39;, iOSExec.nativeFetchMessages());</code> 。  </p>
<p>而在 Objective-C 端使用一个 NSURLProtocol 的子类来检查每个请求，如果地址是 <code>/!gap_exec</code> 的话，则认为是 Cordova 通信的请求，直接拦截，拦截后就可以通过分析请求的数据，分发到不同的插件类(<a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/cordova.js" target="_blank" rel="external">CDVPlugin</a> 类的子类)的方法中：<br><figure class="highlight objc"><figcaption><span>UCCDVURLProtocol 拦截请求</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVURLProtocol.m" target="_blank" rel="external">UCCDVURLProtocol.m</a></figcaption><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)canInitWithRequest:(<span class="built_in">NSURLRequest</span>*)theRequest</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span>* theUrl = [theRequest URL];</span><br><span class="line">    <span class="built_in">NSString</span>* theScheme = [theUrl scheme];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断请求是否为 /!gap_exec</span></span><br><span class="line">    <span class="keyword">if</span> ([[theUrl path] isEqualToString:<span class="string">@"/!gap_exec"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSString</span>* viewControllerAddressStr = [theRequest valueForHTTPHeaderField:<span class="string">@"vc"</span>];</span><br><span class="line">        <span class="keyword">if</span> (viewControllerAddressStr == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"!cordova request missing vc header"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> viewControllerAddress = [viewControllerAddressStr longLongValue];</span><br><span class="line">        <span class="comment">// Ensure that the UCCDVViewController has not been dealloc'ed.</span></span><br><span class="line">        UCCDVViewController* viewController = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">@synchronized</span>(gRegisteredControllers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![gRegisteredControllers containsObject:</span><br><span class="line">					[<span class="built_in">NSNumber</span> numberWithLongLong:viewControllerAddress]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            viewController = (UCCDVViewController*)(<span class="keyword">void</span>*)viewControllerAddress;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取请求的数据</span></span><br><span class="line">        <span class="built_in">NSString</span>* queuedCommandsJSON = [theRequest valueForHTTPHeaderField:<span class="string">@"cmds"</span>];</span><br><span class="line">        <span class="built_in">NSString</span>* requestId = [theRequest valueForHTTPHeaderField:<span class="string">@"rc"</span>];</span><br><span class="line">        <span class="keyword">if</span> (requestId == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"!cordova request missing rc header"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       	...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cordova 中优先使用这种方式，<a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/cordova.js" target="_blank" rel="external">Cordova.js</a> 中的注释有提及为什么优先使用 XMLHttpRequest 的方式，及为什么保留第二种 iframe bridge 的通信方式:  </p>
<blockquote>
<p>// XHR mode does not work on iOS 4.2, so default to IFRAME_NAV for such devices.<br>// XHR mode’s main advantage is working around a bug in -webkit-scroll, which<br>// doesn’t exist in 4.X devices anyways</p>
</blockquote>
<h3 id="iframe-bridge"><a href="#iframe-bridge" class="headerlink" title="iframe bridge"></a>iframe bridge</h3><p>在 JS 端创建一个<strong>透明的 iframe</strong>，设置这个 ifame 的 src 为自定义的协议，而 ifame 的 src 更改时，UIWebView 会先回调其 delegate 的 <code>webView:shouldStartLoadWithRequest:navigationType:</code> 方法，关键代码如下：<br><figure class="highlight objc"><figcaption><span>UIWebView拦截加载</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVViewController.m" target="_blank" rel="external">CDVViewController.m</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// UIWebView 加载 URL 前回调的方法，返回 YES，则开始加载此 URL，返回 NO，则忽略此 URL</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)webView:(<span class="built_in">UIWebView</span>*)theWebView </span><br><span class="line">			shouldStartLoadWithRequest:(<span class="built_in">NSURLRequest</span>*)request </span><br><span class="line">			navigationType:(<span class="built_in">UIWebViewNavigationType</span>)navigationType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span>* url = [request URL];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Execute any commands queued with cordova.exec() on the JS side.</span><br><span class="line">     * The part of the URL after gap:// is irrelevant.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// 判断是否 Cordova 的请求，对于 JS 代码中 execIframe.src = "gap://ready" 这句</span></span><br><span class="line">    <span class="keyword">if</span> ([[url scheme] isEqualToString:<span class="string">@"gap"</span>]) &#123;</span><br><span class="line">        <span class="comment">// 获取请求的数据，并对数据进行分析、处理</span></span><br><span class="line">        [_commandQueue fetchCommandsFromJs];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Objective-C-怎么跟-JS-通信"><a href="#Objective-C-怎么跟-JS-通信" class="headerlink" title="Objective-C 怎么跟 JS 通信"></a>Objective-C 怎么跟 JS 通信</h2><p>熟悉 UIWebView 用法的同学都知道 UIWebView 有一个这样的方法 <code>stringByEvaluatingJavaScriptFromString:</code>，这个方法可以让一个 UIWebView 对象执行一段 JS 代码，这样就可以达到 Objective-C 跟 JS 通信的效果，在 Cordova 的代码中多处用到了这个方法，其中最重要的两处如下：   </p>
<ul>
<li><p>获取 JS 的请求数据</p>
<figure class="highlight objc"><figcaption><span>获取 JS 的请求数据</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVCommandQueue.m" target="_blank" rel="external">CDVCommandQueue.m</a></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)fetchCommandsFromJs</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Grab all the queued commands from the JS side.</span></span><br><span class="line">    <span class="built_in">NSString</span>* queuedCommandsJSON = [_viewController.webView </span><br><span class="line">										stringByEvaluatingJavaScriptFromString: </span><br><span class="line">											<span class="string">@"cordova.require('cordova/exec').nativeFetchMessages()"</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> enqueCommandBatch:queuedCommandsJSON];</span><br><span class="line">    <span class="keyword">if</span> ([queuedCommandsJSON length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CDV_EXEC_LOG(<span class="string">@"Exec: Retrieved new exec messages by request."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>把 JS 请求的结果返回给 JS 端</p>
<figure class="highlight objc"><figcaption><span>把 JS 请求的结果返回给 JS 端</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVCommandDelegateImpl.m" target="_blank" rel="external">CDVCommandDelegateImpl.m</a></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)evalJs:(<span class="built_in">NSString</span>*)js scheduledOnRunLoop:(<span class="built_in">BOOL</span>)scheduledOnRunLoop</span><br><span class="line">&#123;</span><br><span class="line">    js = [<span class="built_in">NSString</span> stringWithFormat:</span><br><span class="line">					<span class="string">@"cordova.require('cordova/exec').nativeEvalAndFetch(function()&#123; %@ &#125;)"</span>, </span><br><span class="line">					js];</span><br><span class="line">    <span class="keyword">if</span> (scheduledOnRunLoop) &#123;</span><br><span class="line">        [<span class="keyword">self</span> evalJsHelper:js];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> evalJsHelper2:js];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)evalJsHelper2:(<span class="built_in">NSString</span>*)js</span><br><span class="line">&#123;</span><br><span class="line">    CDV_EXEC_LOG(<span class="string">@"Exec: evalling: %@"</span>, [js substringToIndex:MIN([js length], <span class="number">160</span>)]);</span><br><span class="line">    <span class="built_in">NSString</span>* commandsJSON = [_viewController.webView </span><br><span class="line">								stringByEvaluatingJavaScriptFromString:js];</span><br><span class="line">    <span class="keyword">if</span> ([commandsJSON length] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CDV_EXEC_LOG(<span class="string">@"Exec: Retrieved new exec messages by chaining."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [_commandQueue enqueCommandBatch:commandsJSON];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)evalJsHelper:(<span class="built_in">NSString</span>*)js</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Cycle the run-loop before executing the JS.</span></span><br><span class="line">    <span class="comment">// This works around a bug where sometimes alerts() within callbacks can cause</span></span><br><span class="line">    <span class="comment">// dead-lock.</span></span><br><span class="line">    <span class="comment">// If the commandQueue is currently executing, then we know that it is safe to</span></span><br><span class="line">    <span class="comment">// execute the callback immediately.</span></span><br><span class="line">    <span class="comment">// Using    (dispatch_get_main_queue()) does *not* fix deadlocks for some reaon,</span></span><br><span class="line">    <span class="comment">// but performSelectorOnMainThread: does.</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="built_in">NSThread</span> isMainThread] || !_commandQueue.currentlyExecuting) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(evalJsHelper2:) </span><br><span class="line">			    			    withObject:js </span><br><span class="line">			    			 waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> evalJsHelper2:js];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="怎么串起来"><a href="#怎么串起来" class="headerlink" title="怎么串起来"></a>怎么串起来</h2><p>先看一下 Cordova JS 端请求方法的格式：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// successCallback : 成功回调方法</span></span><br><span class="line"><span class="comment">// failCallback    : 失败回调方法</span></span><br><span class="line"><span class="comment">// server          : 所要请求的服务名字</span></span><br><span class="line"><span class="comment">// action          : 所要请求的服务具体操作</span></span><br><span class="line"><span class="comment">// actionArgs      : 请求操作所带的参数</span></span><br><span class="line">cordova.exec(successCallback, failCallback, service, action, actionArgs);</span><br></pre></td></tr></table></figure></p>
<p>传进来的这五个参数并不是直接传送给原生代码的，Cordova JS 端会做以下的处理：  </p>
<ol>
<li>会为每个请求生成一个叫 <strong>callbackId</strong> 的唯一标识：这个参数需传给 Objective-C 端，Objective-C 处理完后，会把 callbackId 连同处理结果一起返回给 JS 端  </li>
<li>以 callbackId 为 key，{success:successCallback, fail:failCallback} 为 value，<strong>把这个键值对保存在 JS 端的字典里</strong>，successCallback 与 failCallback 这两个参数不需要传给 Objective-C 端，Objective-C 返回结果时带上 callbackId，<strong>JS 端就可以根据 callbackId 找到回调方法</strong>  </li>
<li>每次 JS 请求，最后发到 Objective-C 的数据包括：callbackId, service, action, actionArgs  </li>
</ol>
<p>关键代码如下：<br><figure class="highlight js"><figcaption><span>JS 端处理请求</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/cordova.js" target="_blank" rel="external">cordova.js</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iOSExec</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">// 生成一个 callbackId 的唯一标识，并把此标志与成功、失败回调方法一起保存在 JS 端</span></span><br><span class="line">    <span class="comment">// Register the callbacks and add the callbackId to the positional</span></span><br><span class="line">    <span class="comment">// arguments if given.</span></span><br><span class="line">    <span class="keyword">if</span> (successCallback || failCallback) &#123;</span><br><span class="line">        callbackId = service + cordova.callbackId++;</span><br><span class="line">        cordova.callbacks[callbackId] =</span><br><span class="line">            &#123;success:successCallback, fail:failCallback&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    actionArgs = massageArgsJsToNative(actionArgs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把 callbackId，service，action，actionArgs 保持到 commandQueue 中</span></span><br><span class="line">	<span class="comment">// 这四个参数就是最后发给原生代码的数据</span></span><br><span class="line">    <span class="keyword">var</span> command = [callbackId, service, action, actionArgs];</span><br><span class="line">    commandQueue.push(<span class="built_in">JSON</span>.stringify(command));</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取请求的数据，包括 callbackId, service, action, actionArgs</span></span><br><span class="line">iOSExec.nativeFetchMessages = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Each entry in commandQueue is a JSON string already.</span></span><br><span class="line">    <span class="keyword">if</span> (!commandQueue.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> json = <span class="string">'['</span> + commandQueue.join(<span class="string">','</span>) + <span class="string">']'</span>;</span><br><span class="line">    commandQueue.length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> json;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>原生代码拿到 callbackId、service、action 及 actionArgs 后，会做以下的处理：  </p>
<ol>
<li>根据 service 参数找到对应的插件类  </li>
<li>根据 action 参数找到插件类中对应的处理方法，并把 actionArgs 作为处理方法请求参数的一部分传给处理方法  </li>
<li>处理完成后，把处理结果及 callbackId 返回给 JS 端，JS 端收到后会根据 callbackId 找到回调方法，并把处理结果传给回调方法  </li>
</ol>
<p>关键代码：<br><figure class="highlight objc"><figcaption><span>Objective-C 返回结果给 JS 端</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/Classes/CDVCommandDelegateImpl.m" target="_blank" rel="external">CDVCommandDelegateImpl.m</a></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendPluginResult:(CDVPluginResult*)result callbackId:(<span class="built_in">NSString</span>*)callbackId</span><br><span class="line">&#123;</span><br><span class="line">    CDV_EXEC_LOG(<span class="string">@"Exec(%@): Sending result. Status=%@"</span>, callbackId, result.status);</span><br><span class="line">    <span class="comment">// This occurs when there is are no win/fail callbacks for the call.</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="string">@"INVALID"</span> isEqualToString : callbackId]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> status = [result.status intValue];</span><br><span class="line">    <span class="built_in">BOOL</span> keepCallback = [result.keepCallback boolValue];</span><br><span class="line">    <span class="built_in">NSString</span>* argumentsAsJSON = [result argumentsAsJSON];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将请求的处理结果及 callbackId 通过调用 JS 方法返回给 JS 端</span></span><br><span class="line">    <span class="built_in">NSString</span>* js = [<span class="built_in">NSString</span> stringWithFormat:</span><br><span class="line">								<span class="string">@"cordova.require('cordova/exec').nativeCallback('%@',%d,%@,%d)"</span>, </span><br><span class="line">								callbackId, status, argumentsAsJSON, keepCallback];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> evalJsHelper:js];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><figcaption><span>JS 端根据 callbackId 回调</span><a href="https://github.com/apache/cordova-ios/blob/master/CordovaLib/cordova.js" target="_blank" rel="external">cordova.js</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 callbackId 及是否成功标识，找到回调方法，并把处理结果传给回调方法</span></span><br><span class="line">callbackFromNative: <span class="function"><span class="keyword">function</span>(<span class="params">callbackId, success, status, args, keepCallback</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> callback = cordova.callbacks[callbackId];</span><br><span class="line">       <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">           <span class="keyword">if</span> (success &amp;&amp; status == cordova.callbackStatus.OK) &#123;</span><br><span class="line">               callback.success &amp;&amp; callback.success.apply(<span class="literal">null</span>, args);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">               callback.fail &amp;&amp; callback.fail.apply(<span class="literal">null</span>, args);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// Clear callback if not expecting any more results</span></span><br><span class="line">           <span class="keyword">if</span> (!keepCallback) &#123;</span><br><span class="line">               <span class="keyword">delete</span> cordova.callbacks[callbackId];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="通信效率"><a href="#通信效率" class="headerlink" title="通信效率"></a>通信效率</h2><p>Cordova 这套通信效率并不算低。我使用 <strong>iPod Touch 4</strong> 与 <strong>iPhone 5</strong> 进行真机测试：JS 做一次请求，Objective-C 收到请求后不做任何的处理，马上把请求的数据返回给 JS 端，这样能大概的测出一来一往的时间(从 JS 发出请求，到 JS 收到结果的时间)。每个真机我做了三组测试，每组连续测试十次，每组测试前我都会把机器重启，结果如下：</p>
<ul>
<li>iPod Touch 4(时间单位：毫秒)：  </li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">组\序号</th>
<th style="text-align:center">第1次</th>
<th style="text-align:center">第2次</th>
<th style="text-align:center">第3次</th>
<th style="text-align:center">第4次</th>
<th style="text-align:center">第5次</th>
<th style="text-align:center">第6次</th>
<th style="text-align:center">第7次</th>
<th style="text-align:center">第8次</th>
<th style="text-align:center">第9次</th>
<th style="text-align:center">第10次</th>
<th style="text-align:center">组平均时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第一组</td>
<td style="text-align:center">10</td>
<td style="text-align:center">11</td>
<td style="text-align:center">8</td>
<td style="text-align:center">13</td>
<td style="text-align:center">11</td>
<td style="text-align:center">9</td>
<td style="text-align:center">14</td>
<td style="text-align:center">13</td>
<td style="text-align:center">9</td>
<td style="text-align:center">12</td>
<td style="text-align:center">11.0 </td>
</tr>
<tr>
<td style="text-align:center">第二组</td>
<td style="text-align:center">33</td>
<td style="text-align:center">13</td>
<td style="text-align:center">9</td>
<td style="text-align:center">13</td>
<td style="text-align:center">11</td>
<td style="text-align:center">8</td>
<td style="text-align:center">14</td>
<td style="text-align:center">12</td>
<td style="text-align:center">15</td>
<td style="text-align:center">37</td>
<td style="text-align:center">15.2</td>
</tr>
<tr>
<td style="text-align:center">第三组</td>
<td style="text-align:center">20</td>
<td style="text-align:center">19</td>
<td style="text-align:center">9</td>
<td style="text-align:center">16</td>
<td style="text-align:center">11</td>
<td style="text-align:center">17</td>
<td style="text-align:center">13</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
<td style="text-align:center">8</td>
<td style="text-align:center">13.2</td>
</tr>
</tbody>
</table>
<p>这三十次测试的平均时间是：(11.0 + 15.2 + 13.2) / 3 = 13.13 毫秒  </p>
<ul>
<li>iPhone 5(时间单位：毫秒)</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">组\序号</th>
<th style="text-align:center">第1次</th>
<th style="text-align:center">第2次</th>
<th style="text-align:center">第3次</th>
<th style="text-align:center">第4次</th>
<th style="text-align:center">第5次</th>
<th style="text-align:center">第6次</th>
<th style="text-align:center">第7次</th>
<th style="text-align:center">第8次</th>
<th style="text-align:center">第9次</th>
<th style="text-align:center">第10次</th>
<th style="text-align:center">组平均时间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第一组</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2.7 </td>
</tr>
<tr>
<td style="text-align:center">第二组</td>
<td style="text-align:center">7</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2.8</td>
</tr>
<tr>
<td style="text-align:center">第三组</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2.7</td>
</tr>
</tbody>
</table>
<p>这三十次测试的平均时间是：(2.7 + 2.8 + 2.7) / 3 = 2.73 毫秒  </p>
<p><strong>这通信的效率虽然比不上原生调原生，但是也是属于可接受的范围了。</strong></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2013/04/28/uiwindowde-[?]-ge-jian-rong-xing-wen-ti/" itemprop="url">
                  UIWindow的一个兼容性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2013-04-28T12:53:00+08:00" content="2013-04-28">
              2013-04-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程技术/" itemprop="url" rel="index">
                    <span itemprop="name">编程技术</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2013/04/28/uiwindowde-[?]-ge-jian-rong-xing-wen-ti/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2013/04/28/uiwindowde-[?]-ge-jian-rong-xing-wen-ti/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近发现了一个奇怪的 UIWindow 的兼容性问题，通过一种比较取巧的方式解决了，如果你有更好的解决办法，请在回复中告诉我。  </p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>如果应用中使用了额外的 UIWindow，并且此 UIWindow 中包含了 UIWebView，那么在<strong>iOS 5.1或者以下的系统版本</strong>中，可能会出现在 UIWebView中触发键盘时，<strong>键盘处于不可见的状态</strong>。</p>
<h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul>
<li>项目中使用了另一个 UIWindow (在这里给这个额外的 UIWindow 取个代号：HighLevelWindow)</li>
<li>设置此 HighLevelWindow 的 windowLevel 大于 UIWindowLevelNormal，确保在显示时能覆盖在应用默认的 UIWindow 上面 (UIWindowLevelNormal 级别为应用默认的 UIWindow 的 windowLevel 取值)</li>
<li>HighLevelWindow 中的 rootViewController 里面包含了一个 UIWebView  </li>
<li>在显示此 HighLevelWindow 时，已经调用<code>makeKeyAndVisible</code>方法将 HighLevelWindow 设置成应用的keyWindow，确保能正常的接收到触摸事件</li>
</ul>
<h3 id="重现步骤"><a href="#重现步骤" class="headerlink" title="重现步骤"></a>重现步骤</h3><ol>
<li>使用 iOS 5.1或者以下版本的设备运行应用，在应用默认的 UIWindow 中触发过键盘，如触发过一个输入框(UITextField)，见下图：</li>
</ol>
<p><img src="http://zhenbyphoto-wordpress.stor.sinaapp.com/uploads/2013/04/iOS-Simulator-Screen-shot-2013-4-28-%E4%B8%8B%E5%8D%8810.55.45.png" alt="在默认UIWindow中触发键盘"></p>
<p>2.调出 HighLevelWindow，将 HighLevelWindow 中的 UIWebView 载入 google.com，点击 google 的搜索输入框，会发现网页虽然上推了，但是键盘处于不可见的状态，见下图：</p>
<p><img src="http://zhenbyphoto-wordpress.stor.sinaapp.com/uploads/2013/04/iOS-Simulator-Screen-shot-2013-4-28-%E4%B8%8B%E5%8D%889.56.31.png" alt="键盘处于不可见的状态"></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>上 google 搜了很久，给出的解决方案都是说没把 HighLevelWindow 设置成应用的 KeyWindow，导致接收不到屏幕的触摸事件，但是从 google 网页上推可以看出，其实 HighLevelWindow 是可以接收到触摸事件的，而且我已经确定把 HightLevelWindow 设置成应用的 KeyWindow 了。  </p>
<p>现在的症状就是键盘在默认的 UIWindow 中触发过后，在 HinhLevelWindow 中再次触发，键盘其实是被挡在了 HighLevelWindow 后面，处于不可见，不可点击的状态。(此症状可通过将 HighLevelWindow 的 frame.size 设置成只有屏幕一半大小来确定)  </p>
<p>尝试了各种方法，都是不行的，而且从 iOS 6.0 开始，此 bug 是不存在的，那更可以确定是一个兼容性的问题了。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我突然想起，就在之前项目还没改用 UIWebView 前，使用一般的 UITextField 输入框是可以正常的显示键盘的，于是，就有以下这种取巧的解决方案：<br><strong>在包含了 UIWebView 的 UIViewController 显示时(<code>viewDidAppear:</code> 方法调用时)，插入一个 UITextField，迅速的获取焦点，然后取消焦点，删除此 UITextFiled </strong>，关键代码如下：<br><figure class="highlight objc"><figcaption><span>- FixedBugWindowViewController.m</span></figcaption><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidAppear:animated];</span><br><span class="line">	    </span><br><span class="line">	<span class="comment">// 在系统版本低于 iOS 6.0 时才做此操作</span></span><br><span class="line">	<span class="keyword">if</span> ([[[<span class="built_in">UIDevice</span> currentDevice] systemVersion] floatValue] &lt; <span class="number">6.0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 新建一个 UITextField，并添加到视图中</span></span><br><span class="line">		<span class="built_in">UITextField</span> *textFieldFixKeyBoardBug = [[<span class="built_in">UITextField</span> alloc] initWithFrame:<span class="keyword">self</span>.view.bounds];</span><br><span class="line">		[<span class="keyword">self</span>.view addSubview:textFieldFixKeyBoardBug];</span><br><span class="line">								        </span><br><span class="line">		<span class="comment">// 获取焦点，释放焦点</span></span><br><span class="line">		[textFieldFixKeyBoardBug becomeFirstResponder];</span><br><span class="line">		[textFieldFixKeyBoardBug resignFirstResponder];</span><br><span class="line">														        </span><br><span class="line">		<span class="comment">// 将 UITextField 从视图中移除，并释放</span></span><br><span class="line">		[textFieldFixKeyBoardBug removeFromSuperview];</span><br><span class="line">		[textFieldFixKeyBoardBug release];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>加上以上代码后，可以正常的显示键盘了。</p>
<p><img src="http://zhenbyphoto-wordpress.stor.sinaapp.com/uploads/2013/04/iOS-Simulator-Screen-shot-2013-4-28-%E4%B8%8B%E5%8D%8810.55.31.png" alt="可正常显示键盘"></p>
<h2 id="不单单是UIWebView，不单单是键盘"><a href="#不单单是UIWebView，不单单是键盘" class="headerlink" title="不单单是UIWebView，不单单是键盘"></a>不单单是UIWebView，不单单是键盘</h2><ul>
<li>不单单是 UIWebView，我在使用 MFMessageComposeViewController 时也遇过这个问题，类似的 MFMailComposeViewController 应该也会出现这个问题，可以使用相同的方法修复</li>
<li>不单单是键盘，在 UIWebView 中，页面有一个下拉框，会显示一个 UIPickerView，此 UIPickerView 也处于被隐藏，不可见的状态，也可以使用此方法修复</li>
</ul>
<h2 id="Demo源码"><a href="#Demo源码" class="headerlink" title="Demo源码"></a>Demo源码</h2><p>Demo源码地址：<a href="https://github.com/zhenby/UIWindowKeyboardBug" target="_blank" rel="external">https://github.com/zhenby/UIWindowKeyboardBug</a></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="zhenby" />
          <p class="site-author-name" itemprop="name">zhenby</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhenby</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"zhenby"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
