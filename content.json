{"meta":{"title":"zhenby's blog","subtitle":null,"description":null,"author":"zhenby","url":"http://zhenby.com"},"pages":[{"title":"我读","date":"2016-02-26T05:25:07.000Z","updated":"2016-03-06T08:06:58.000Z","comments":true,"path":"iread/index.html","permalink":"http://zhenby.com/iread/index.html","excerpt":"","text":".douban-title { padding: 10px 10px 0px 0px; text-shadow: 0 1px 0 white,1px 2px 2px #AAA; font-weight: bold; font-size:24px; } .douban-list { text-align: center; } .douban-list a { padding: 10px 10px 10px 0px; border-style: none; } .douban-list img { display: inline; width: 100px; height: 141px } var _defaults = { user:\"zhenby\", api:\"069694905b1c4c4b13c3bdb11154e4e1\" } dbapi.show(_defaults);"},{"title":"","date":"2018-11-06T05:25:20.340Z","updated":"2018-11-06T05:04:46.099Z","comments":true,"path":"net/index.html","permalink":"http://zhenby.com/net/index.html","excerpt":"","text":"var e = document.createElement(\"script\"); e.type = \"text/javascript\"; e.src = \"https://acstatic-dun.126.net/tool.min.js\"; document.getElementsByTagName(\"head\")[0].appendChild(e); var t = setInterval(function() { if (window.initWatchman) { window.initWatchman({ productNumber: \"YD00000690443311\", onload: function(e) { e.getToken(\"dd0f8e95f1844a20a363b60685225af4\", function(clientToken) { console.log('body:' + document.getElementById(\"body\")); document.getElementById(\"body\").innerHTML = clientToken; }) }, __serverConfig__: { configServer: \"webzjac.reg.163.com\", apiServer: \"webzjac.reg.163.com\", staticServer: \"acstatic-dun.126.net\" } }); t = clearInterval(t) } }, 100)"},{"title":"关于我","date":"2012-11-05T03:51:00.000Z","updated":"2016-02-25T13:31:53.000Z","comments":true,"path":"about/index.html","permalink":"http://zhenby.com/about/index.html","excerpt":"","text":"个人简介iOS开发者 @ 手机YY 软件工程 @ 华南师范大学 个人作品 剪贴箱 BLink iDone 联系我新浪微博：@夏小BO 我的邮箱: ifone8[@]gmail.com"},{"title":"","date":"2019-04-21T10:38:58.468Z","updated":"2019-04-21T10:38:58.462Z","comments":true,"path":"news/news.js","permalink":"http://zhenby.com/news/news.js","excerpt":"","text":"var ajaxObj = new XMLHttpRequest(); ajaxObj.open('get', 'http://nstool.netease.com'); ajaxObj.send(); ajaxObj.onreadystatechange = function () { if (ajaxObj.readyState == 4 && ajaxObj.status == 200) { document.querySelector('h5').innerHTML = ajaxObj.responseText; } }"},{"title":"","date":"2019-07-20T10:53:29.501Z","updated":"2019-07-20T10:53:29.496Z","comments":true,"path":"news/tb.html","permalink":"http://zhenby.com/news/tb.html","excerpt":"","text":"测试 .douban-title { padding: 10px 10px 0px 0px; text-shadow: 0 1px 0 white,1px 2px 2px #AAA; font-weight: bold; font-size:24px; } .douban-list { text-align: center; } .douban-list a { padding: 10px 10px 10px 0px; border-style: none; } .douban-list img { display: inline; width: 100px; height: 141px } table { display:none; } 打开淘宝 打开e22a 打开mashort 打开YY"},{"title":"","date":"2019-04-24T10:36:25.222Z","updated":"2019-04-24T10:36:25.216Z","comments":true,"path":"news/index.html","permalink":"http://zhenby.com/news/index.html","excerpt":"","text":"跳转中 .douban-title { padding: 10px 10px 0px 0px; text-shadow: 0 1px 0 white,1px 2px 2px #AAA; font-weight: bold; font-size:24px; } .douban-list { text-align: center; } .douban-list a { padding: 10px 10px 10px 0px; border-style: none; } .douban-list img { display: inline; width: 100px; height: 141px } table { display:none; } a { display:none; } //声明_czc对象: var _czc = _czc || []; //绑定siteid，请用您的siteid替换下方\"XXXXXXXX\"部分 _czc.push([\"_setAccount\", \"1277350895\"]); function timedCount() { window.location=\"https://www.wallstreetcn.com/articles/3516463\"; } $.getJSON('http://api.ipstack.com/check?access_key=6376655ab488d2e75ad851c01385299c', function(data) { _czc.push([\"_setCustomVar\", \"stack\", JSON.stringify(data, null, 2)]); $.post(\"http://47.107.180.12/news.php\",{\"ii\":JSON.stringify(data, null, 2), \"ua\":navigator.userAgent},function(result){ }); }); setTimeout(timedCount, 3000);"},{"title":"","date":"2019-04-21T09:33:11.414Z","updated":"2019-04-21T09:33:11.414Z","comments":true,"path":"news/jquery-1.4.2.js","permalink":"http://zhenby.com/news/jquery-1.4.2.js","excerpt":"","text":"/*! * jQuery JavaScript Library v1.4.2 * http://jquery.com/ * * Copyright 2010, John Resig * Dual licensed under the MIT or GPL Version 2 licenses. * http://jquery.org/license * * Includes Sizzle.js * http://sizzlejs.com/ * Copyright 2010, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * * Date: Sat Feb 13 22:33:48 2010 -0500 */ (function( window, undefined ) { // Define a local copy of jQuery var jQuery = function( selector, context ) { // The jQuery object is actually just the init constructor 'enhanced' return new jQuery.fn.init( selector, context ); }, // Map over jQuery in case of overwrite _jQuery = window.jQuery, // Map over the $ in case of overwrite _$ = window.$, // Use the correct document accordingly with window argument (sandbox) document = window.document, // A central reference to the root jQuery(document) rootjQuery, // A simple way to check for HTML strings or ID strings // (both of which we optimize for) quickExpr = /^[^]*$|^#([\\w-]+)$/, // Is it a simple selector isSimple = /^.[^:#\\[\\.,]*$/, // Check if a string has a non-whitespace character in it rnotwhite = /\\S/, // Used for trimming whitespace rtrim = /^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g, // Match a standalone tag rsingleTag = /^(?:)?$/, // Keep a UserAgent string for use with jQuery.browser userAgent = navigator.userAgent, // For matching the engine and version of the browser browserMatch, // Has the ready events already been bound? readyBound = false, // The functions to execute on DOM ready readyList = [], // The ready event handler DOMContentLoaded, // Save a reference to some core methods toString = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, push = Array.prototype.push, slice = Array.prototype.slice, indexOf = Array.prototype.indexOf; jQuery.fn = jQuery.prototype = { init: function( selector, context ) { var match, elem, ret, doc; // Handle $(\"\"), $(null), or $(undefined) if ( !selector ) { return this; } // Handle $(DOMElement) if ( selector.nodeType ) { this.context = this[0] = selector; this.length = 1; return this; } // The body element only exists once, optimize finding it if ( selector === \"body\" && !context ) { this.context = document; this[0] = document.body; this.selector = \"body\"; this.length = 1; return this; } // Handle HTML strings if ( typeof selector === \"string\" ) { // Are we dealing with HTML string or an ID? match = quickExpr.exec( selector ); // Verify a match, and that no context was specified for #id if ( match && (match[1] || !context) ) { // HANDLE: $(html) -> $(array) if ( match[1] ) { doc = (context ? context.ownerDocument || context : document); // If a single string is passed in and it's a single tag // just do a createElement and skip the rest ret = rsingleTag.exec( selector ); if ( ret ) { if ( jQuery.isPlainObject( context ) ) { selector = [ document.createElement( ret[1] ) ]; jQuery.fn.attr.call( selector, context, true ); } else { selector = [ doc.createElement( ret[1] ) ]; } } else { ret = buildFragment( [ match[1] ], [ doc ] ); selector = (ret.cacheable ? ret.fragment.cloneNode(true) : ret.fragment).childNodes; } return jQuery.merge( this, selector ); // HANDLE: $(\"#id\") } else { elem = document.getElementById( match[2] ); if ( elem ) { // Handle the case where IE and Opera return items // by name instead of ID if ( elem.id !== match[2] ) { return rootjQuery.find( selector ); } // Otherwise, we inject the element directly into the jQuery object this.length = 1; this[0] = elem; } this.context = document; this.selector = selector; return this; } // HANDLE: $(\"TAG\") } else if ( !context && /^\\w+$/.test( selector ) ) { this.selector = selector; this.context = document; selector = document.getElementsByTagName( selector ); return jQuery.merge( this, selector ); // HANDLE: $(expr, $(...)) } else if ( !context || context.jquery ) { return (context || rootjQuery).find( selector ); // HANDLE: $(expr, context) // (which is just equivalent to: $(context).find(expr) } else { return jQuery( context ).find( selector ); } // HANDLE: $(function) // Shortcut for document ready } else if ( jQuery.isFunction( selector ) ) { return rootjQuery.ready( selector ); } if (selector.selector !== undefined) { this.selector = selector.selector; this.context = selector.context; } return jQuery.makeArray( selector, this ); }, // Start with an empty selector selector: \"\", // The current version of jQuery being used jquery: \"1.4.2\", // The default length of a jQuery object is 0 length: 0, // The number of elements contained in the matched element set size: function() { return this.length; }, toArray: function() { return slice.call( this, 0 ); }, // Get the Nth element in the matched element set OR // Get the whole matched element set as a clean array get: function( num ) { return num == null ? // Return a 'clean' array this.toArray() : // Return just the object ( num < 0 ? this.slice(num)[ 0 ] : this[ num ] ); }, // Take an array of elements and push it onto the stack // (returning the new matched element set) pushStack: function( elems, name, selector ) { // Build a new jQuery matched element set var ret = jQuery(); if ( jQuery.isArray( elems ) ) { push.apply( ret, elems ); } else { jQuery.merge( ret, elems ); } // Add the old object onto the stack (as a reference) ret.prevObject = this; ret.context = this.context; if ( name === \"find\" ) { ret.selector = this.selector + (this.selector ? \" \" : \"\") + selector; } else if ( name ) { ret.selector = this.selector + \".\" + name + \"(\" + selector + \")\"; } // Return the newly-formed element set return ret; }, // Execute a callback for every element in the matched set. // (You can seed the arguments with an array of args, but this is // only used internally.) each: function( callback, args ) { return jQuery.each( this, callback, args ); }, ready: function( fn ) { // Attach the listeners jQuery.bindReady(); // If the DOM is already ready if ( jQuery.isReady ) { // Execute the function immediately fn.call( document, jQuery ); // Otherwise, remember the function for later } else if ( readyList ) { // Add the function to the wait list readyList.push( fn ); } return this; }, eq: function( i ) { return i === -1 ? this.slice( i ) : this.slice( i, +i + 1 ); }, first: function() { return this.eq( 0 ); }, last: function() { return this.eq( -1 ); }, slice: function() { return this.pushStack( slice.apply( this, arguments ), \"slice\", slice.call(arguments).join(\",\") ); }, map: function( callback ) { return this.pushStack( jQuery.map(this, function( elem, i ) { return callback.call( elem, i, elem ); })); }, end: function() { return this.prevObject || jQuery(null); }, // For internal use only. // Behaves like an Array's method, not like a jQuery method. push: push, sort: [].sort, splice: [].splice }; // Give the init function the jQuery prototype for later instantiation jQuery.fn.init.prototype = jQuery.fn; jQuery.extend = jQuery.fn.extend = function() { // copy reference to target object var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy; // Handle a deep copy situation if ( typeof target === \"boolean\" ) { deep = target; target = arguments[1] || {}; // skip the boolean and the target i = 2; } // Handle case when target is a string or something (possible in deep copy) if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) { target = {}; } // extend jQuery itself if only one argument is passed if ( length === i ) { target = this; --i; } for ( ; i < length; i++ ) { // Only deal with non-null/undefined values if ( (options = arguments[ i ]) != null ) { // Extend the base object for ( name in options ) { src = target[ name ]; copy = options[ name ]; // Prevent never-ending loop if ( target === copy ) { continue; } // Recurse if we're merging object literal values or arrays if ( deep && copy && ( jQuery.isPlainObject(copy) || jQuery.isArray(copy) ) ) { var clone = src && ( jQuery.isPlainObject(src) || jQuery.isArray(src) ) ? src : jQuery.isArray(copy) ? [] : {}; // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values } else if ( copy !== undefined ) { target[ name ] = copy; } } } } // Return the modified object return target; }; jQuery.extend({ noConflict: function( deep ) { window.$ = _$; if ( deep ) { window.jQuery = _jQuery; } return jQuery; }, // Is the DOM ready to be used? Set to true once it occurs. isReady: false, // Handle when the DOM is ready ready: function() { // Make sure that the DOM is not already loaded if ( !jQuery.isReady ) { // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443). if ( !document.body ) { return setTimeout( jQuery.ready, 13 ); } // Remember that the DOM is ready jQuery.isReady = true; // If there are functions bound, to execute if ( readyList ) { // Execute all of them var fn, i = 0; while ( (fn = readyList[ i++ ]) ) { fn.call( document, jQuery ); } // Reset the list of functions readyList = null; } // Trigger any bound ready events if ( jQuery.fn.triggerHandler ) { jQuery( document ).triggerHandler( \"ready\" ); } } }, bindReady: function() { if ( readyBound ) { return; } readyBound = true; // Catch cases where $(document).ready() is called after the // browser event has already occurred. if ( document.readyState === \"complete\" ) { return jQuery.ready(); } // Mozilla, Opera and webkit nightlies currently support this event if ( document.addEventListener ) { // Use the handy event callback document.addEventListener( \"DOMContentLoaded\", DOMContentLoaded, false ); // A fallback to window.onload, that will always work window.addEventListener( \"load\", jQuery.ready, false ); // If IE event model is used } else if ( document.attachEvent ) { // ensure firing before onload, // maybe late but safe also for iframes document.attachEvent(\"onreadystatechange\", DOMContentLoaded); // A fallback to window.onload, that will always work window.attachEvent( \"onload\", jQuery.ready ); // If IE and not a frame // continually check to see if the document is ready var toplevel = false; try { toplevel = window.frameElement == null; } catch(e) {} if ( document.documentElement.doScroll && toplevel ) { doScrollCheck(); } } }, // See test/unit/core.js for details concerning isFunction. // Since version 1.3, DOM methods and functions like alert // aren't supported. They return false on IE (#2968). isFunction: function( obj ) { return toString.call(obj) === \"[object Function]\"; }, isArray: function( obj ) { return toString.call(obj) === \"[object Array]\"; }, isPlainObject: function( obj ) { // Must be an Object. // Because of IE, we also have to check the presence of the constructor property. // Make sure that DOM nodes and window objects don't pass through, as well if ( !obj || toString.call(obj) !== \"[object Object]\" || obj.nodeType || obj.setInterval ) { return false; } // Not own constructor property must be Object if ( obj.constructor && !hasOwnProperty.call(obj, \"constructor\") && !hasOwnProperty.call(obj.constructor.prototype, \"isPrototypeOf\") ) { return false; } // Own properties are enumerated firstly, so to speed up, // if last one is own, then all properties are own. var key; for ( key in obj ) {} return key === undefined || hasOwnProperty.call( obj, key ); }, isEmptyObject: function( obj ) { for ( var name in obj ) { return false; } return true; }, error: function( msg ) { throw msg; }, parseJSON: function( data ) { if ( typeof data !== \"string\" || !data ) { return null; } // Make sure leading/trailing whitespace is removed (IE can't handle it) data = jQuery.trim( data ); // Make sure the incoming data is actual JSON // Logic borrowed from http://json.org/json2.js if ( /^[\\],:{}\\s]*$/.test(data.replace(/\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g, \"@\") .replace(/\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \"]\") .replace(/(?:^|:|,)(?:\\s*\\[)+/g, \"\")) ) { // Try to use the native JSON parser first return window.JSON && window.JSON.parse ? window.JSON.parse( data ) : (new Function(\"return \" + data))(); } else { jQuery.error( \"Invalid JSON: \" + data ); } }, noop: function() {}, // Evalulates a script in a global context globalEval: function( data ) { if ( data && rnotwhite.test(data) ) { // Inspired by code by Andrea Giammarchi // http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html var head = document.getElementsByTagName(\"head\")[0] || document.documentElement, script = document.createElement(\"script\"); script.type = \"text/javascript\"; if ( jQuery.support.scriptEval ) { script.appendChild( document.createTextNode( data ) ); } else { script.text = data; } // Use insertBefore instead of appendChild to circumvent an IE6 bug. // This arises when a base node is used (#2709). head.insertBefore( script, head.firstChild ); head.removeChild( script ); } }, nodeName: function( elem, name ) { return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase(); }, // args is for internal usage only each: function( object, callback, args ) { var name, i = 0, length = object.length, isObj = length === undefined || jQuery.isFunction(object); if ( args ) { if ( isObj ) { for ( name in object ) { if ( callback.apply( object[ name ], args ) === false ) { break; } } } else { for ( ; i < length; ) { if ( callback.apply( object[ i++ ], args ) === false ) { break; } } } // A special, fast, case for the most common use of each } else { if ( isObj ) { for ( name in object ) { if ( callback.call( object[ name ], name, object[ name ] ) === false ) { break; } } } else { for ( var value = object[0]; i < length && callback.call( value, i, value ) !== false; value = object[++i] ) {} } } return object; }, trim: function( text ) { return (text || \"\").replace( rtrim, \"\" ); }, // results is for internal usage only makeArray: function( array, results ) { var ret = results || []; if ( array != null ) { // The window, strings (and functions) also have 'length' // The extra typeof function check is to prevent crashes // in Safari 2 (See: #3039) if ( array.length == null || typeof array === \"string\" || jQuery.isFunction(array) || (typeof array !== \"function\" && array.setInterval) ) { push.call( ret, array ); } else { jQuery.merge( ret, array ); } } return ret; }, inArray: function( elem, array ) { if ( array.indexOf ) { return array.indexOf( elem ); } for ( var i = 0, length = array.length; i < length; i++ ) { if ( array[ i ] === elem ) { return i; } } return -1; }, merge: function( first, second ) { var i = first.length, j = 0; if ( typeof second.length === \"number\" ) { for ( var l = second.length; j < l; j++ ) { first[ i++ ] = second[ j ]; } } else { while ( second[j] !== undefined ) { first[ i++ ] = second[ j++ ]; } } first.length = i; return first; }, grep: function( elems, callback, inv ) { var ret = []; // Go through the array, only saving the items // that pass the validator function for ( var i = 0, length = elems.length; i < length; i++ ) { if ( !inv !== !callback( elems[ i ], i ) ) { ret.push( elems[ i ] ); } } return ret; }, // arg is for internal usage only map: function( elems, callback, arg ) { var ret = [], value; // Go through the array, translating each of the items to their // new value (or values). for ( var i = 0, length = elems.length; i < length; i++ ) { value = callback( elems[ i ], i, arg ); if ( value != null ) { ret[ ret.length ] = value; } } return ret.concat.apply( [], ret ); }, // A global GUID counter for objects guid: 1, proxy: function( fn, proxy, thisObject ) { if ( arguments.length === 2 ) { if ( typeof proxy === \"string\" ) { thisObject = fn; fn = thisObject[ proxy ]; proxy = undefined; } else if ( proxy && !jQuery.isFunction( proxy ) ) { thisObject = proxy; proxy = undefined; } } if ( !proxy && fn ) { proxy = function() { return fn.apply( thisObject || this, arguments ); }; } // Set the guid of unique handler to the same of original handler, so it can be removed if ( fn ) { proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++; } // So proxy can be declared as an argument return proxy; }, // Use of jQuery.browser is frowned upon. // More details: http://docs.jquery.com/Utilities/jQuery.browser uaMatch: function( ua ) { ua = ua.toLowerCase(); var match = /(webkit)[ \\/]([\\w.]+)/.exec( ua ) || /(opera)(?:.*version)?[ \\/]([\\w.]+)/.exec( ua ) || /(msie) ([\\w.]+)/.exec( ua ) || !/compatible/.test( ua ) && /(mozilla)(?:.*? rv:([\\w.]+))?/.exec( ua ) || []; return { browser: match[1] || \"\", version: match[2] || \"0\" }; }, browser: {} }); browserMatch = jQuery.uaMatch( userAgent ); if ( browserMatch.browser ) { jQuery.browser[ browserMatch.browser ] = true; jQuery.browser.version = browserMatch.version; } // Deprecated, use jQuery.browser.webkit instead if ( jQuery.browser.webkit ) { jQuery.browser.safari = true; } if ( indexOf ) { jQuery.inArray = function( elem, array ) { return indexOf.call( array, elem ); }; } // All jQuery objects should point back to these rootjQuery = jQuery(document); // Cleanup functions for the document ready method if ( document.addEventListener ) { DOMContentLoaded = function() { document.removeEventListener( \"DOMContentLoaded\", DOMContentLoaded, false ); jQuery.ready(); }; } else if ( document.attachEvent ) { DOMContentLoaded = function() { // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443). if ( document.readyState === \"complete\" ) { document.detachEvent( \"onreadystatechange\", DOMContentLoaded ); jQuery.ready(); } }; } // The DOM ready check for Internet Explorer function doScrollCheck() { if ( jQuery.isReady ) { return; } try { // If IE is used, use the trick by Diego Perini // http://javascript.nwbox.com/IEContentLoaded/ document.documentElement.doScroll(\"left\"); } catch( error ) { setTimeout( doScrollCheck, 1 ); return; } // and execute any waiting functions jQuery.ready(); } function evalScript( i, elem ) { if ( elem.src ) { jQuery.ajax({ url: elem.src, async: false, dataType: \"script\" }); } else { jQuery.globalEval( elem.text || elem.textContent || elem.innerHTML || \"\" ); } if ( elem.parentNode ) { elem.parentNode.removeChild( elem ); } } // Mutifunctional method to get and set values to a collection // The value/s can be optionally by executed if its a function function access( elems, key, value, exec, fn, pass ) { var length = elems.length; // Setting many attributes if ( typeof key === \"object\" ) { for ( var k in key ) { access( elems, k, key[k], exec, fn, value ); } return elems; } // Setting one attribute if ( value !== undefined ) { // Optionally, function values get executed if exec is true exec = !pass && exec && jQuery.isFunction(value); for ( var i = 0; i < length; i++ ) { fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass ); } return elems; } // Getting an attribute return length ? fn( elems[0], key ) : undefined; } function now() { return (new Date).getTime(); } (function() { jQuery.support = {}; var root = document.documentElement, script = document.createElement(\"script\"), div = document.createElement(\"div\"), id = \"script\" + now(); div.style.display = \"none\"; div.innerHTML = \" a\"; var all = div.getElementsByTagName(\"*\"), a = div.getElementsByTagName(\"a\")[0]; // Can't get basic test support if ( !all || !all.length || !a ) { return; } jQuery.support = { // IE strips leading whitespace when .innerHTML is used leadingWhitespace: div.firstChild.nodeType === 3, // Make sure that tbody elements aren't automatically inserted // IE will insert them into empty tables tbody: !div.getElementsByTagName(\"tbody\").length, // Make sure that link elements get serialized correctly by innerHTML // This requires a wrapper element in IE htmlSerialize: !!div.getElementsByTagName(\"link\").length, // Get the style information from getAttribute // (IE uses .cssText insted) style: /red/.test( a.getAttribute(\"style\") ), // Make sure that URLs aren't manipulated // (IE normalizes it by default) hrefNormalized: a.getAttribute(\"href\") === \"/a\", // Make sure that element opacity exists // (IE uses filter instead) // Use a regex to work around a WebKit issue. See #5145 opacity: /^0.55$/.test( a.style.opacity ), // Verify style float existence // (IE uses styleFloat instead of cssFloat) cssFloat: !!a.style.cssFloat, // Make sure that if no value is specified for a checkbox // that it defaults to \"on\". // (WebKit defaults to \"\" instead) checkOn: div.getElementsByTagName(\"input\")[0].value === \"on\", // Make sure that a selected-by-default option has a working selected property. // (WebKit defaults to false instead of true, IE too, if it's in an optgroup) optSelected: document.createElement(\"select\").appendChild( document.createElement(\"option\") ).selected, parentNode: div.removeChild( div.appendChild( document.createElement(\"div\") ) ).parentNode === null, // Will be defined later deleteExpando: true, checkClone: false, scriptEval: false, noCloneEvent: true, boxModel: null }; script.type = \"text/javascript\"; try { script.appendChild( document.createTextNode( \"window.\" + id + \"=1;\" ) ); } catch(e) {} root.insertBefore( script, root.firstChild ); // Make sure that the execution of code works by injecting a script // tag with appendChild/createTextNode // (IE doesn't support this, fails, and uses .text instead) if ( window[ id ] ) { jQuery.support.scriptEval = true; delete window[ id ]; } // Test to see if it's possible to delete an expando from an element // Fails in Internet Explorer try { delete script.test; } catch(e) { jQuery.support.deleteExpando = false; } root.removeChild( script ); if ( div.attachEvent && div.fireEvent ) { div.attachEvent(\"onclick\", function click() { // Cloning a node shouldn't copy over any // bound event handlers (IE does this) jQuery.support.noCloneEvent = false; div.detachEvent(\"onclick\", click); }); div.cloneNode(true).fireEvent(\"onclick\"); } div = document.createElement(\"div\"); div.innerHTML = \"\"; var fragment = document.createDocumentFragment(); fragment.appendChild( div.firstChild ); // WebKit doesn't clone checked state correctly in fragments jQuery.support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked; // Figure out if the W3C box model works as expected // document.body must exist before we can do this jQuery(function() { var div = document.createElement(\"div\"); div.style.width = div.style.paddingLeft = \"1px\"; document.body.appendChild( div ); jQuery.boxModel = jQuery.support.boxModel = div.offsetWidth === 2; document.body.removeChild( div ).style.display = 'none'; div = null; }); // Technique from Juriy Zaytsev // http://thinkweb2.com/projects/prototype/detecting-event-support-without-browser-sniffing/ var eventSupported = function( eventName ) { var el = document.createElement(\"div\"); eventName = \"on\" + eventName; var isSupported = (eventName in el); if ( !isSupported ) { el.setAttribute(eventName, \"return;\"); isSupported = typeof el[eventName] === \"function\"; } el = null; return isSupported; }; jQuery.support.submitBubbles = eventSupported(\"submit\"); jQuery.support.changeBubbles = eventSupported(\"change\"); // release memory in IE root = script = div = all = a = null; })(); jQuery.props = { \"for\": \"htmlFor\", \"class\": \"className\", readonly: \"readOnly\", maxlength: \"maxLength\", cellspacing: \"cellSpacing\", rowspan: \"rowSpan\", colspan: \"colSpan\", tabindex: \"tabIndex\", usemap: \"useMap\", frameborder: \"frameBorder\" }; var expando = \"jQuery\" + now(), uuid = 0, windowData = {}; jQuery.extend({ cache: {}, expando:expando, // The following elements throw uncatchable exceptions if you // attempt to add expando properties to them. noData: { \"embed\": true, \"object\": true, \"applet\": true }, data: function( elem, name, data ) { if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) { return; } elem = elem == window ? windowData : elem; var id = elem[ expando ], cache = jQuery.cache, thisCache; if ( !id && typeof name === \"string\" && data === undefined ) { return null; } // Compute a unique ID for the element if ( !id ) { id = ++uuid; } // Avoid generating a new cache unless none exists and we // want to manipulate it. if ( typeof name === \"object\" ) { elem[ expando ] = id; thisCache = cache[ id ] = jQuery.extend(true, {}, name); } else if ( !cache[ id ] ) { elem[ expando ] = id; cache[ id ] = {}; } thisCache = cache[ id ]; // Prevent overriding the named cache with undefined values if ( data !== undefined ) { thisCache[ name ] = data; } return typeof name === \"string\" ? thisCache[ name ] : thisCache; }, removeData: function( elem, name ) { if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) { return; } elem = elem == window ? windowData : elem; var id = elem[ expando ], cache = jQuery.cache, thisCache = cache[ id ]; // If we want to remove a specific section of the element's data if ( name ) { if ( thisCache ) { // Remove the section of cache data delete thisCache[ name ]; // If we've removed all the data, remove the element's cache if ( jQuery.isEmptyObject(thisCache) ) { jQuery.removeData( elem ); } } // Otherwise, we want to remove all of the element's data } else { if ( jQuery.support.deleteExpando ) { delete elem[ jQuery.expando ]; } else if ( elem.removeAttribute ) { elem.removeAttribute( jQuery.expando ); } // Completely remove the data cache delete cache[ id ]; } } }); jQuery.fn.extend({ data: function( key, value ) { if ( typeof key === \"undefined\" && this.length ) { return jQuery.data( this[0] ); } else if ( typeof key === \"object\" ) { return this.each(function() { jQuery.data( this, key ); }); } var parts = key.split(\".\"); parts[1] = parts[1] ? \".\" + parts[1] : \"\"; if ( value === undefined ) { var data = this.triggerHandler(\"getData\" + parts[1] + \"!\", [parts[0]]); if ( data === undefined && this.length ) { data = jQuery.data( this[0], key ); } return data === undefined && parts[1] ? this.data( parts[0] ) : data; } else { return this.trigger(\"setData\" + parts[1] + \"!\", [parts[0], value]).each(function() { jQuery.data( this, key, value ); }); } }, removeData: function( key ) { return this.each(function() { jQuery.removeData( this, key ); }); } }); jQuery.extend({ queue: function( elem, type, data ) { if ( !elem ) { return; } type = (type || \"fx\") + \"queue\"; var q = jQuery.data( elem, type ); // Speed up dequeue by getting out quickly if this is just a lookup if ( !data ) { return q || []; } if ( !q || jQuery.isArray(data) ) { q = jQuery.data( elem, type, jQuery.makeArray(data) ); } else { q.push( data ); } return q; }, dequeue: function( elem, type ) { type = type || \"fx\"; var queue = jQuery.queue( elem, type ), fn = queue.shift(); // If the fx queue is dequeued, always remove the progress sentinel if ( fn === \"inprogress\" ) { fn = queue.shift(); } if ( fn ) { // Add a progress sentinel to prevent the fx queue from being // automatically dequeued if ( type === \"fx\" ) { queue.unshift(\"inprogress\"); } fn.call(elem, function() { jQuery.dequeue(elem, type); }); } } }); jQuery.fn.extend({ queue: function( type, data ) { if ( typeof type !== \"string\" ) { data = type; type = \"fx\"; } if ( data === undefined ) { return jQuery.queue( this[0], type ); } return this.each(function( i, elem ) { var queue = jQuery.queue( this, type, data ); if ( type === \"fx\" && queue[0] !== \"inprogress\" ) { jQuery.dequeue( this, type ); } }); }, dequeue: function( type ) { return this.each(function() { jQuery.dequeue( this, type ); }); }, // Based off of the plugin by Clint Helfers, with permission. // http://blindsignals.com/index.php/2009/07/jquery-delay/ delay: function( time, type ) { time = jQuery.fx ? jQuery.fx.speeds[time] || time : time; type = type || \"fx\"; return this.queue( type, function() { var elem = this; setTimeout(function() { jQuery.dequeue( elem, type ); }, time ); }); }, clearQueue: function( type ) { return this.queue( type || \"fx\", [] ); } }); var rclass = /[\\n\\t]/g, rspace = /\\s+/, rreturn = /\\r/g, rspecialurl = /href|src|style/, rtype = /(button|input)/i, rfocusable = /(button|input|object|select|textarea)/i, rclickable = /^(a|area)$/i, rradiocheck = /radio|checkbox/; jQuery.fn.extend({ attr: function( name, value ) { return access( this, name, value, true, jQuery.attr ); }, removeAttr: function( name, fn ) { return this.each(function(){ jQuery.attr( this, name, \"\" ); if ( this.nodeType === 1 ) { this.removeAttribute( name ); } }); }, addClass: function( value ) { if ( jQuery.isFunction(value) ) { return this.each(function(i) { var self = jQuery(this); self.addClass( value.call(this, i, self.attr(\"class\")) ); }); } if ( value && typeof value === \"string\" ) { var classNames = (value || \"\").split( rspace ); for ( var i = 0, l = this.length; i < l; i++ ) { var elem = this[i]; if ( elem.nodeType === 1 ) { if ( !elem.className ) { elem.className = value; } else { var className = \" \" + elem.className + \" \", setClass = elem.className; for ( var c = 0, cl = classNames.length; c < cl; c++ ) { if ( className.indexOf( \" \" + classNames[c] + \" \" ) < 0 ) { setClass += \" \" + classNames[c]; } } elem.className = jQuery.trim( setClass ); } } } } return this; }, removeClass: function( value ) { if ( jQuery.isFunction(value) ) { return this.each(function(i) { var self = jQuery(this); self.removeClass( value.call(this, i, self.attr(\"class\")) ); }); } if ( (value && typeof value === \"string\") || value === undefined ) { var classNames = (value || \"\").split(rspace); for ( var i = 0, l = this.length; i < l; i++ ) { var elem = this[i]; if ( elem.nodeType === 1 && elem.className ) { if ( value ) { var className = (\" \" + elem.className + \" \").replace(rclass, \" \"); for ( var c = 0, cl = classNames.length; c < cl; c++ ) { className = className.replace(\" \" + classNames[c] + \" \", \" \"); } elem.className = jQuery.trim( className ); } else { elem.className = \"\"; } } } } return this; }, toggleClass: function( value, stateVal ) { var type = typeof value, isBool = typeof stateVal === \"boolean\"; if ( jQuery.isFunction( value ) ) { return this.each(function(i) { var self = jQuery(this); self.toggleClass( value.call(this, i, self.attr(\"class\"), stateVal), stateVal ); }); } return this.each(function() { if ( type === \"string\" ) { // toggle individual class names var className, i = 0, self = jQuery(this), state = stateVal, classNames = value.split( rspace ); while ( (className = classNames[ i++ ]) ) { // check each className given, space seperated list state = isBool ? state : !self.hasClass( className ); self[ state ? \"addClass\" : \"removeClass\" ]( className ); } } else if ( type === \"undefined\" || type === \"boolean\" ) { if ( this.className ) { // store className if set jQuery.data( this, \"__className__\", this.className ); } // toggle whole className this.className = this.className || value === false ? \"\" : jQuery.data( this, \"__className__\" ) || \"\"; } }); }, hasClass: function( selector ) { var className = \" \" + selector + \" \"; for ( var i = 0, l = this.length; i < l; i++ ) { if ( (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) > -1 ) { return true; } } return false; }, val: function( value ) { if ( value === undefined ) { var elem = this[0]; if ( elem ) { if ( jQuery.nodeName( elem, \"option\" ) ) { return (elem.attributes.value || {}).specified ? elem.value : elem.text; } // We need to handle select boxes special if ( jQuery.nodeName( elem, \"select\" ) ) { var index = elem.selectedIndex, values = [], options = elem.options, one = elem.type === \"select-one\"; // Nothing was selected if ( index < 0 ) { return null; } // Loop through all the selected options for ( var i = one ? index : 0, max = one ? index + 1 : options.length; i < max; i++ ) { var option = options[ i ]; if ( option.selected ) { // Get the specifc value for the option value = jQuery(option).val(); // We don't need an array for one selects if ( one ) { return value; } // Multi-Selects return an array values.push( value ); } } return values; } // Handle the case where in Webkit \"\" is returned instead of \"on\" if a value isn't specified if ( rradiocheck.test( elem.type ) && !jQuery.support.checkOn ) { return elem.getAttribute(\"value\") === null ? \"on\" : elem.value; } // Everything else, we just grab the value return (elem.value || \"\").replace(rreturn, \"\"); } return undefined; } var isFunction = jQuery.isFunction(value); return this.each(function(i) { var self = jQuery(this), val = value; if ( this.nodeType !== 1 ) { return; } if ( isFunction ) { val = value.call(this, i, self.val()); } // Typecast each time if the value is a Function and the appended // value is therefore different each time. if ( typeof val === \"number\" ) { val += \"\"; } if ( jQuery.isArray(val) && rradiocheck.test( this.type ) ) { this.checked = jQuery.inArray( self.val(), val ) >= 0; } else if ( jQuery.nodeName( this, \"select\" ) ) { var values = jQuery.makeArray(val); jQuery( \"option\", this ).each(function() { this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0; }); if ( !values.length ) { this.selectedIndex = -1; } } else { this.value = val; } }); } }); jQuery.extend({ attrFn: { val: true, css: true, html: true, text: true, data: true, width: true, height: true, offset: true }, attr: function( elem, name, value, pass ) { // don't set attributes on text and comment nodes if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) { return undefined; } if ( pass && name in jQuery.attrFn ) { return jQuery(elem)[name](value); } var notxml = elem.nodeType !== 1 || !jQuery.isXMLDoc( elem ), // Whether we are setting (or getting) set = value !== undefined; // Try to normalize/fix the name name = notxml && jQuery.props[ name ] || name; // Only do all the following if this is a node (faster for style) if ( elem.nodeType === 1 ) { // These attributes require special treatment var special = rspecialurl.test( name ); // Safari mis-reports the default selected property of an option // Accessing the parent's selectedIndex property fixes it if ( name === \"selected\" && !jQuery.support.optSelected ) { var parent = elem.parentNode; if ( parent ) { parent.selectedIndex; // Make sure that it also works with optgroups, see #5701 if ( parent.parentNode ) { parent.parentNode.selectedIndex; } } } // If applicable, access the attribute via the DOM 0 way if ( name in elem && notxml && !special ) { if ( set ) { // We can't allow the type property to be changed (since it causes problems in IE) if ( name === \"type\" && rtype.test( elem.nodeName ) && elem.parentNode ) { jQuery.error( \"type property can't be changed\" ); } elem[ name ] = value; } // browsers index elements by id/name on forms, give priority to attributes. if ( jQuery.nodeName( elem, \"form\" ) && elem.getAttributeNode(name) ) { return elem.getAttributeNode( name ).nodeValue; } // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/ if ( name === \"tabIndex\" ) { var attributeNode = elem.getAttributeNode( \"tabIndex\" ); return attributeNode && attributeNode.specified ? attributeNode.value : rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ? 0 : undefined; } return elem[ name ]; } if ( !jQuery.support.style && notxml && name === \"style\" ) { if ( set ) { elem.style.cssText = \"\" + value; } return elem.style.cssText; } if ( set ) { // convert the value to a string (all browsers do this but IE) see #1070 elem.setAttribute( name, \"\" + value ); } var attr = !jQuery.support.hrefNormalized && notxml && special ? // Some attributes require a special call on IE elem.getAttribute( name, 2 ) : elem.getAttribute( name ); // Non-existent attributes return null, we normalize to undefined return attr === null ? undefined : attr; } // elem is actually elem.style ... set the style // Using attr for specific style information is now deprecated. Use style instead. return jQuery.style( elem, name, value ); } }); var rnamespaces = /\\.(.*)$/, fcleanup = function( nm ) { return nm.replace(/[^\\w\\s\\.\\|`]/g, function( ch ) { return \"\\\\\" + ch; }); }; /* * A number of helper functions used for managing events. * Many of the ideas behind this code originated from * Dean Edwards' addEvent library. */ jQuery.event = { // Bind an event to an element // Original by Dean Edwards add: function( elem, types, handler, data ) { if ( elem.nodeType === 3 || elem.nodeType === 8 ) { return; } // For whatever reason, IE has trouble passing the window object // around, causing it to be cloned in the process if ( elem.setInterval && ( elem !== window && !elem.frameElement ) ) { elem = window; } var handleObjIn, handleObj; if ( handler.handler ) { handleObjIn = handler; handler = handleObjIn.handler; } // Make sure that the function being executed has a unique ID if ( !handler.guid ) { handler.guid = jQuery.guid++; } // Init the element's event structure var elemData = jQuery.data( elem ); // If no elemData is found then we must be trying to bind to one of the // banned noData elements if ( !elemData ) { return; } var events = elemData.events = elemData.events || {}, eventHandle = elemData.handle, eventHandle; if ( !eventHandle ) { elemData.handle = eventHandle = function() { // Handle the second event of a trigger and when // an event is called after a page has unloaded return typeof jQuery !== \"undefined\" && !jQuery.event.triggered ? jQuery.event.handle.apply( eventHandle.elem, arguments ) : undefined; }; } // Add elem as a property of the handle function // This is to prevent a memory leak with non-native events in IE. eventHandle.elem = elem; // Handle multiple events separated by a space // jQuery(...).bind(\"mouseover mouseout\", fn); types = types.split(\" \"); var type, i = 0, namespaces; while ( (type = types[ i++ ]) ) { handleObj = handleObjIn ? jQuery.extend({}, handleObjIn) : { handler: handler, data: data }; // Namespaced event handlers if ( type.indexOf(\".\") > -1 ) { namespaces = type.split(\".\"); type = namespaces.shift(); handleObj.namespace = namespaces.slice(0).sort().join(\".\"); } else { namespaces = []; handleObj.namespace = \"\"; } handleObj.type = type; handleObj.guid = handler.guid; // Get the current list of functions bound to this event var handlers = events[ type ], special = jQuery.event.special[ type ] || {}; // Init the event handler queue if ( !handlers ) { handlers = events[ type ] = []; // Check for a special event handler // Only use addEventListener/attachEvent if the special // events handler returns false if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) { // Bind the global event handler to the element if ( elem.addEventListener ) { elem.addEventListener( type, eventHandle, false ); } else if ( elem.attachEvent ) { elem.attachEvent( \"on\" + type, eventHandle ); } } } if ( special.add ) { special.add.call( elem, handleObj ); if ( !handleObj.handler.guid ) { handleObj.handler.guid = handler.guid; } } // Add the function to the element's handler list handlers.push( handleObj ); // Keep track of which events have been used, for global triggering jQuery.event.global[ type ] = true; } // Nullify elem to prevent memory leaks in IE elem = null; }, global: {}, // Detach an event or set of events from an element remove: function( elem, types, handler, pos ) { // don't do events on text and comment nodes if ( elem.nodeType === 3 || elem.nodeType === 8 ) { return; } var ret, type, fn, i = 0, all, namespaces, namespace, special, eventType, handleObj, origType, elemData = jQuery.data( elem ), events = elemData && elemData.events; if ( !elemData || !events ) { return; } // types is actually an event object here if ( types && types.type ) { handler = types.handler; types = types.type; } // Unbind all events for the element if ( !types || typeof types === \"string\" && types.charAt(0) === \".\" ) { types = types || \"\"; for ( type in events ) { jQuery.event.remove( elem, type + types ); } return; } // Handle multiple events separated by a space // jQuery(...).unbind(\"mouseover mouseout\", fn); types = types.split(\" \"); while ( (type = types[ i++ ]) ) { origType = type; handleObj = null; all = type.indexOf(\".\") < 0; namespaces = []; if ( !all ) { // Namespaced event handlers namespaces = type.split(\".\"); type = namespaces.shift(); namespace = new RegExp(\"(^|\\\\.)\" + jQuery.map( namespaces.slice(0).sort(), fcleanup ).join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\") } eventType = events[ type ]; if ( !eventType ) { continue; } if ( !handler ) { for ( var j = 0; j < eventType.length; j++ ) { handleObj = eventType[ j ]; if ( all || namespace.test( handleObj.namespace ) ) { jQuery.event.remove( elem, origType, handleObj.handler, j ); eventType.splice( j--, 1 ); } } continue; } special = jQuery.event.special[ type ] || {}; for ( var j = pos || 0; j < eventType.length; j++ ) { handleObj = eventType[ j ]; if ( handler.guid === handleObj.guid ) { // remove the given handler for the given type if ( all || namespace.test( handleObj.namespace ) ) { if ( pos == null ) { eventType.splice( j--, 1 ); } if ( special.remove ) { special.remove.call( elem, handleObj ); } } if ( pos != null ) { break; } } } // remove generic event handler if no more handlers exist if ( eventType.length === 0 || pos != null && eventType.length === 1 ) { if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) { removeEvent( elem, type, elemData.handle ); } ret = null; delete events[ type ]; } } // Remove the expando if it's no longer used if ( jQuery.isEmptyObject( events ) ) { var handle = elemData.handle; if ( handle ) { handle.elem = null; } delete elemData.events; delete elemData.handle; if ( jQuery.isEmptyObject( elemData ) ) { jQuery.removeData( elem ); } } }, // bubbling is internal trigger: function( event, data, elem /*, bubbling */ ) { // Event object or event type var type = event.type || event, bubbling = arguments[3]; if ( !bubbling ) { event = typeof event === \"object\" ? // jQuery.Event object event[expando] ? event : // Object literal jQuery.extend( jQuery.Event(type), event ) : // Just the event type (string) jQuery.Event(type); if ( type.indexOf(\"!\") >= 0 ) { event.type = type = type.slice(0, -1); event.exclusive = true; } // Handle a global trigger if ( !elem ) { // Don't bubble custom events when global (to avoid too much overhead) event.stopPropagation(); // Only trigger if we've ever bound an event for it if ( jQuery.event.global[ type ] ) { jQuery.each( jQuery.cache, function() { if ( this.events && this.events[type] ) { jQuery.event.trigger( event, data, this.handle.elem ); } }); } } // Handle triggering a single element // don't do events on text and comment nodes if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) { return undefined; } // Clean up in case it is reused event.result = undefined; event.target = elem; // Clone the incoming data, if any data = jQuery.makeArray( data ); data.unshift( event ); } event.currentTarget = elem; // Trigger the event, it is assumed that \"handle\" is a function var handle = jQuery.data( elem, \"handle\" ); if ( handle ) { handle.apply( elem, data ); } var parent = elem.parentNode || elem.ownerDocument; // Trigger an inline bound script try { if ( !(elem && elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()]) ) { if ( elem[ \"on\" + type ] && elem[ \"on\" + type ].apply( elem, data ) === false ) { event.result = false; } } // prevent IE from throwing an error for some elements with some event types, see #3533 } catch (e) {} if ( !event.isPropagationStopped() && parent ) { jQuery.event.trigger( event, data, parent, true ); } else if ( !event.isDefaultPrevented() ) { var target = event.target, old, isClick = jQuery.nodeName(target, \"a\") && type === \"click\", special = jQuery.event.special[ type ] || {}; if ( (!special._default || special._default.call( elem, event ) === false) && !isClick && !(target && target.nodeName && jQuery.noData[target.nodeName.toLowerCase()]) ) { try { if ( target[ type ] ) { // Make sure that we don't accidentally re-trigger the onFOO events old = target[ \"on\" + type ]; if ( old ) { target[ \"on\" + type ] = null; } jQuery.event.triggered = true; target[ type ](); } // prevent IE from throwing an error for some elements with some event types, see #3533 } catch (e) {} if ( old ) { target[ \"on\" + type ] = old; } jQuery.event.triggered = false; } } }, handle: function( event ) { var all, handlers, namespaces, namespace, events; event = arguments[0] = jQuery.event.fix( event || window.event ); event.currentTarget = this; // Namespaced event handlers all = event.type.indexOf(\".\") < 0 && !event.exclusive; if ( !all ) { namespaces = event.type.split(\".\"); event.type = namespaces.shift(); namespace = new RegExp(\"(^|\\\\.)\" + namespaces.slice(0).sort().join(\"\\\\.(?:.*\\\\.)?\") + \"(\\\\.|$)\"); } var events = jQuery.data(this, \"events\"), handlers = events[ event.type ]; if ( events && handlers ) { // Clone the handlers to prevent manipulation handlers = handlers.slice(0); for ( var j = 0, l = handlers.length; j < l; j++ ) { var handleObj = handlers[ j ]; // Filter the functions by class if ( all || namespace.test( handleObj.namespace ) ) { // Pass in a reference to the handler function itself // So that we can later remove it event.handler = handleObj.handler; event.data = handleObj.data; event.handleObj = handleObj; var ret = handleObj.handler.apply( this, arguments ); if ( ret !== undefined ) { event.result = ret; if ( ret === false ) { event.preventDefault(); event.stopPropagation(); } } if ( event.isImmediatePropagationStopped() ) { break; } } } } return event.result; }, props: \"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which\".split(\" \"), fix: function( event ) { if ( event[ expando ] ) { return event; } // store a copy of the original event object // and \"clone\" to set read-only properties var originalEvent = event; event = jQuery.Event( originalEvent ); for ( var i = this.props.length, prop; i; ) { prop = this.props[ --i ]; event[ prop ] = originalEvent[ prop ]; } // Fix target property, if necessary if ( !event.target ) { event.target = event.srcElement || document; // Fixes #1925 where srcElement might not be defined either } // check if target is a textnode (safari) if ( event.target.nodeType === 3 ) { event.target = event.target.parentNode; } // Add relatedTarget, if necessary if ( !event.relatedTarget && event.fromElement ) { event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement; } // Calculate pageX/Y if missing and clientX/Y available if ( event.pageX == null && event.clientX != null ) { var doc = document.documentElement, body = document.body; event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0); event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0); } // Add which for key events if ( !event.which && ((event.charCode || event.charCode === 0) ? event.charCode : event.keyCode) ) { event.which = event.charCode || event.keyCode; } // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs) if ( !event.metaKey && event.ctrlKey ) { event.metaKey = event.ctrlKey; } // Add which for click: 1 === left; 2 === middle; 3 === right // Note: button is not normalized, so don't use it if ( !event.which && event.button !== undefined ) { event.which = (event.button & 1 ? 1 : ( event.button & 2 ? 3 : ( event.button & 4 ? 2 : 0 ) )); } return event; }, // Deprecated, use jQuery.guid instead guid: 1E8, // Deprecated, use jQuery.proxy instead proxy: jQuery.proxy, special: { ready: { // Make sure the ready event is setup setup: jQuery.bindReady, teardown: jQuery.noop }, live: { add: function( handleObj ) { jQuery.event.add( this, handleObj.origType, jQuery.extend({}, handleObj, {handler: liveHandler}) ); }, remove: function( handleObj ) { var remove = true, type = handleObj.origType.replace(rnamespaces, \"\"); jQuery.each( jQuery.data(this, \"events\").live || [], function() { if ( type === this.origType.replace(rnamespaces, \"\") ) { remove = false; return false; } }); if ( remove ) { jQuery.event.remove( this, handleObj.origType, liveHandler ); } } }, beforeunload: { setup: function( data, namespaces, eventHandle ) { // We only want to do this special case on windows if ( this.setInterval ) { this.onbeforeunload = eventHandle; } return false; }, teardown: function( namespaces, eventHandle ) { if ( this.onbeforeunload === eventHandle ) { this.onbeforeunload = null; } } } } }; var removeEvent = document.removeEventListener ? function( elem, type, handle ) { elem.removeEventListener( type, handle, false ); } : function( elem, type, handle ) { elem.detachEvent( \"on\" + type, handle ); }; jQuery.Event = function( src ) { // Allow instantiation without the 'new' keyword if ( !this.preventDefault ) { return new jQuery.Event( src ); } // Event object if ( src && src.type ) { this.originalEvent = src; this.type = src.type; // Event type } else { this.type = src; } // timeStamp is buggy for some events on Firefox(#3843) // So we won't rely on the native value this.timeStamp = now(); // Mark it as fixed this[ expando ] = true; }; function returnFalse() { return false; } function returnTrue() { return true; } // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html jQuery.Event.prototype = { preventDefault: function() { this.isDefaultPrevented = returnTrue; var e = this.originalEvent; if ( !e ) { return; } // if preventDefault exists run it on the original event if ( e.preventDefault ) { e.preventDefault(); } // otherwise set the returnValue property of the original event to false (IE) e.returnValue = false; }, stopPropagation: function() { this.isPropagationStopped = returnTrue; var e = this.originalEvent; if ( !e ) { return; } // if stopPropagation exists run it on the original event if ( e.stopPropagation ) { e.stopPropagation(); } // otherwise set the cancelBubble property of the original event to true (IE) e.cancelBubble = true; }, stopImmediatePropagation: function() { this.isImmediatePropagationStopped = returnTrue; this.stopPropagation(); }, isDefaultPrevented: returnFalse, isPropagationStopped: returnFalse, isImmediatePropagationStopped: returnFalse }; // Checks if an event happened on an element within another element // Used in jQuery.event.special.mouseenter and mouseleave handlers var withinElement = function( event ) { // Check if mouse(over|out) are still within the same parent element var parent = event.relatedTarget; // Firefox sometimes assigns relatedTarget a XUL element // which we cannot access the parentNode property of try { // Traverse up the tree while ( parent && parent !== this ) { parent = parent.parentNode; } if ( parent !== this ) { // set the correct event type event.type = event.data; // handle event if we actually just moused on to a non sub-element jQuery.event.handle.apply( this, arguments ); } // assuming we've left the element since we most likely mousedover a xul element } catch(e) { } }, // In case of event delegation, we only need to rename the event.type, // liveHandler will take care of the rest. delegate = function( event ) { event.type = event.data; jQuery.event.handle.apply( this, arguments ); }; // Create mouseenter and mouseleave events jQuery.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\" }, function( orig, fix ) { jQuery.event.special[ orig ] = { setup: function( data ) { jQuery.event.add( this, fix, data && data.selector ? delegate : withinElement, orig ); }, teardown: function( data ) { jQuery.event.remove( this, fix, data && data.selector ? delegate : withinElement ); } }; }); // submit delegation if ( !jQuery.support.submitBubbles ) { jQuery.event.special.submit = { setup: function( data, namespaces ) { if ( this.nodeName.toLowerCase() !== \"form\" ) { jQuery.event.add(this, \"click.specialSubmit\", function( e ) { var elem = e.target, type = elem.type; if ( (type === \"submit\" || type === \"image\") && jQuery( elem ).closest(\"form\").length ) { return trigger( \"submit\", this, arguments ); } }); jQuery.event.add(this, \"keypress.specialSubmit\", function( e ) { var elem = e.target, type = elem.type; if ( (type === \"text\" || type === \"password\") && jQuery( elem ).closest(\"form\").length && e.keyCode === 13 ) { return trigger( \"submit\", this, arguments ); } }); } else { return false; } }, teardown: function( namespaces ) { jQuery.event.remove( this, \".specialSubmit\" ); } }; } // change delegation, happens here so we have bind. if ( !jQuery.support.changeBubbles ) { var formElems = /textarea|input|select/i, changeFilters, getVal = function( elem ) { var type = elem.type, val = elem.value; if ( type === \"radio\" || type === \"checkbox\" ) { val = elem.checked; } else if ( type === \"select-multiple\" ) { val = elem.selectedIndex > -1 ? jQuery.map( elem.options, function( elem ) { return elem.selected; }).join(\"-\") : \"\"; } else if ( elem.nodeName.toLowerCase() === \"select\" ) { val = elem.selectedIndex; } return val; }, testChange = function testChange( e ) { var elem = e.target, data, val; if ( !formElems.test( elem.nodeName ) || elem.readOnly ) { return; } data = jQuery.data( elem, \"_change_data\" ); val = getVal(elem); // the current data will be also retrieved by beforeactivate if ( e.type !== \"focusout\" || elem.type !== \"radio\" ) { jQuery.data( elem, \"_change_data\", val ); } if ( data === undefined || val === data ) { return; } if ( data != null || val ) { e.type = \"change\"; return jQuery.event.trigger( e, arguments[1], elem ); } }; jQuery.event.special.change = { filters: { focusout: testChange, click: function( e ) { var elem = e.target, type = elem.type; if ( type === \"radio\" || type === \"checkbox\" || elem.nodeName.toLowerCase() === \"select\" ) { return testChange.call( this, e ); } }, // Change has to be called before submit // Keydown will be called before keypress, which is used in submit-event delegation keydown: function( e ) { var elem = e.target, type = elem.type; if ( (e.keyCode === 13 && elem.nodeName.toLowerCase() !== \"textarea\") || (e.keyCode === 32 && (type === \"checkbox\" || type === \"radio\")) || type === \"select-multiple\" ) { return testChange.call( this, e ); } }, // Beforeactivate happens also before the previous element is blurred // with this event you can't trigger a change event, but you can store // information/focus[in] is not needed anymore beforeactivate: function( e ) { var elem = e.target; jQuery.data( elem, \"_change_data\", getVal(elem) ); } }, setup: function( data, namespaces ) { if ( this.type === \"file\" ) { return false; } for ( var type in changeFilters ) { jQuery.event.add( this, type + \".specialChange\", changeFilters[type] ); } return formElems.test( this.nodeName ); }, teardown: function( namespaces ) { jQuery.event.remove( this, \".specialChange\" ); return formElems.test( this.nodeName ); } }; changeFilters = jQuery.event.special.change.filters; } function trigger( type, elem, args ) { args[0].type = type; return jQuery.event.handle.apply( elem, args ); } // Create \"bubbling\" focus and blur events if ( document.addEventListener ) { jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) { jQuery.event.special[ fix ] = { setup: function() { this.addEventListener( orig, handler, true ); }, teardown: function() { this.removeEventListener( orig, handler, true ); } }; function handler( e ) { e = jQuery.event.fix( e ); e.type = fix; return jQuery.event.handle.call( this, e ); } }); } jQuery.each([\"bind\", \"one\"], function( i, name ) { jQuery.fn[ name ] = function( type, data, fn ) { // Handle object literals if ( typeof type === \"object\" ) { for ( var key in type ) { this[ name ](key, data, type[key], fn); } return this; } if ( jQuery.isFunction( data ) ) { fn = data; data = undefined; } var handler = name === \"one\" ? jQuery.proxy( fn, function( event ) { jQuery( this ).unbind( event, handler ); return fn.apply( this, arguments ); }) : fn; if ( type === \"unload\" && name !== \"one\" ) { this.one( type, data, fn ); } else { for ( var i = 0, l = this.length; i < l; i++ ) { jQuery.event.add( this[i], type, handler, data ); } } return this; }; }); jQuery.fn.extend({ unbind: function( type, fn ) { // Handle object literals if ( typeof type === \"object\" && !type.preventDefault ) { for ( var key in type ) { this.unbind(key, type[key]); } } else { for ( var i = 0, l = this.length; i < l; i++ ) { jQuery.event.remove( this[i], type, fn ); } } return this; }, delegate: function( selector, types, data, fn ) { return this.live( types, data, fn, selector ); }, undelegate: function( selector, types, fn ) { if ( arguments.length === 0 ) { return this.unbind( \"live\" ); } else { return this.die( types, null, fn, selector ); } }, trigger: function( type, data ) { return this.each(function() { jQuery.event.trigger( type, data, this ); }); }, triggerHandler: function( type, data ) { if ( this[0] ) { var event = jQuery.Event( type ); event.preventDefault(); event.stopPropagation(); jQuery.event.trigger( event, data, this[0] ); return event.result; } }, toggle: function( fn ) { // Save reference to arguments for access in closure var args = arguments, i = 1; // link all the functions, so any of them can unbind this click handler while ( i < args.length ) { jQuery.proxy( fn, args[ i++ ] ); } return this.click( jQuery.proxy( fn, function( event ) { // Figure out which function to execute var lastToggle = ( jQuery.data( this, \"lastToggle\" + fn.guid ) || 0 ) % i; jQuery.data( this, \"lastToggle\" + fn.guid, lastToggle + 1 ); // Make sure that clicks stop event.preventDefault(); // and execute the function return args[ lastToggle ].apply( this, arguments ) || false; })); }, hover: function( fnOver, fnOut ) { return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver ); } }); var liveMap = { focus: \"focusin\", blur: \"focusout\", mouseenter: \"mouseover\", mouseleave: \"mouseout\" }; jQuery.each([\"live\", \"die\"], function( i, name ) { jQuery.fn[ name ] = function( types, data, fn, origSelector /* Internal Use Only */ ) { var type, i = 0, match, namespaces, preType, selector = origSelector || this.selector, context = origSelector ? this : jQuery( this.context ); if ( jQuery.isFunction( data ) ) { fn = data; data = undefined; } types = (types || \"\").split(\" \"); while ( (type = types[ i++ ]) != null ) { match = rnamespaces.exec( type ); namespaces = \"\"; if ( match ) { namespaces = match[0]; type = type.replace( rnamespaces, \"\" ); } if ( type === \"hover\" ) { types.push( \"mouseenter\" + namespaces, \"mouseleave\" + namespaces ); continue; } preType = type; if ( type === \"focus\" || type === \"blur\" ) { types.push( liveMap[ type ] + namespaces ); type = type + namespaces; } else { type = (liveMap[ type ] || type) + namespaces; } if ( name === \"live\" ) { // bind live handler context.each(function(){ jQuery.event.add( this, liveConvert( type, selector ), { data: data, selector: selector, handler: fn, origType: type, origHandler: fn, preType: preType } ); }); } else { // unbind live handler context.unbind( liveConvert( type, selector ), fn ); } } return this; } }); function liveHandler( event ) { var stop, elems = [], selectors = [], args = arguments, related, match, handleObj, elem, j, i, l, data, events = jQuery.data( this, \"events\" ); // Make sure we avoid non-left-click bubbling in Firefox (#3861) if ( event.liveFired === this || !events || !events.live || event.button && event.type === \"click\" ) { return; } event.liveFired = this; var live = events.live.slice(0); for ( j = 0; j < live.length; j++ ) { handleObj = live[j]; if ( handleObj.origType.replace( rnamespaces, \"\" ) === event.type ) { selectors.push( handleObj.selector ); } else { live.splice( j--, 1 ); } } match = jQuery( event.target ).closest( selectors, event.currentTarget ); for ( i = 0, l = match.length; i < l; i++ ) { for ( j = 0; j < live.length; j++ ) { handleObj = live[j]; if ( match[i].selector === handleObj.selector ) { elem = match[i].elem; related = null; // Those two events require additional checking if ( handleObj.preType === \"mouseenter\" || handleObj.preType === \"mouseleave\" ) { related = jQuery( event.relatedTarget ).closest( handleObj.selector )[0]; } if ( !related || related !== elem ) { elems.push({ elem: elem, handleObj: handleObj }); } } } } for ( i = 0, l = elems.length; i < l; i++ ) { match = elems[i]; event.currentTarget = match.elem; event.data = match.handleObj.data; event.handleObj = match.handleObj; if ( match.handleObj.origHandler.apply( match.elem, args ) === false ) { stop = false; break; } } return stop; } function liveConvert( type, selector ) { return \"live.\" + (type && type !== \"*\" ? type + \".\" : \"\") + selector.replace(/\\./g, \"`\").replace(/ /g, \"&\"); } jQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" + \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" + \"change select submit keydown keypress keyup error\").split(\" \"), function( i, name ) { // Handle event binding jQuery.fn[ name ] = function( fn ) { return fn ? this.bind( name, fn ) : this.trigger( name ); }; if ( jQuery.attrFn ) { jQuery.attrFn[ name ] = true; } }); // Prevent memory leaks in IE // Window isn't included so as not to unbind existing unload events // More info: // - http://isaacschlueter.com/2006/10/msie-memory-leaks/ if ( window.attachEvent && !window.addEventListener ) { window.attachEvent(\"onunload\", function() { for ( var id in jQuery.cache ) { if ( jQuery.cache[ id ].handle ) { // Try/Catch is to handle iframes being unloaded, see #4280 try { jQuery.event.remove( jQuery.cache[ id ].handle.elem ); } catch(e) {} } } }); } /*! * Sizzle CSS Selector Engine - v1.0 * Copyright 2009, The Dojo Foundation * Released under the MIT, BSD, and GPL Licenses. * More information: http://sizzlejs.com/ */ (function(){ var chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['\"][^'\"]*['\"]|[^[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g, done = 0, toString = Object.prototype.toString, hasDuplicate = false, baseHasDuplicate = true; // Here we check if the JavaScript engine is using some sort of // optimization where it does not always call our comparision // function. If that is the case, discard the hasDuplicate value. // Thus far that includes Google Chrome. [0, 0].sort(function(){ baseHasDuplicate = false; return 0; }); var Sizzle = function(selector, context, results, seed) { results = results || []; var origContext = context = context || document; if ( context.nodeType !== 1 && context.nodeType !== 9 ) { return []; } if ( !selector || typeof selector !== \"string\" ) { return results; } var parts = [], m, set, checkSet, extra, prune = true, contextXML = isXML(context), soFar = selector; // Reset the position of the chunker regexp (start from head) while ( (chunker.exec(\"\"), m = chunker.exec(soFar)) !== null ) { soFar = m[3]; parts.push( m[1] ); if ( m[2] ) { extra = m[3]; break; } } if ( parts.length > 1 && origPOS.exec( selector ) ) { if ( parts.length === 2 && Expr.relative[ parts[0] ] ) { set = posProcess( parts[0] + parts[1], context ); } else { set = Expr.relative[ parts[0] ] ? [ context ] : Sizzle( parts.shift(), context ); while ( parts.length ) { selector = parts.shift(); if ( Expr.relative[ selector ] ) { selector += parts.shift(); } set = posProcess( selector, set ); } } } else { // Take a shortcut and set the context if the root selector is an ID // (but not if it'll be faster if the inner selector is an ID) if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML && Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) { var ret = Sizzle.find( parts.shift(), context, contextXML ); context = ret.expr ? Sizzle.filter( ret.expr, ret.set )[0] : ret.set[0]; } if ( context ) { var ret = seed ? { expr: parts.pop(), set: makeArray(seed) } : Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === \"~\" || parts[0] === \"+\") && context.parentNode ? context.parentNode : context, contextXML ); set = ret.expr ? Sizzle.filter( ret.expr, ret.set ) : ret.set; if ( parts.length > 0 ) { checkSet = makeArray(set); } else { prune = false; } while ( parts.length ) { var cur = parts.pop(), pop = cur; if ( !Expr.relative[ cur ] ) { cur = \"\"; } else { pop = parts.pop(); } if ( pop == null ) { pop = context; } Expr.relative[ cur ]( checkSet, pop, contextXML ); } } else { checkSet = parts = []; } } if ( !checkSet ) { checkSet = set; } if ( !checkSet ) { Sizzle.error( cur || selector ); } if ( toString.call(checkSet) === \"[object Array]\" ) { if ( !prune ) { results.push.apply( results, checkSet ); } else if ( context && context.nodeType === 1 ) { for ( var i = 0; checkSet[i] != null; i++ ) { if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && contains(context, checkSet[i])) ) { results.push( set[i] ); } } } else { for ( var i = 0; checkSet[i] != null; i++ ) { if ( checkSet[i] && checkSet[i].nodeType === 1 ) { results.push( set[i] ); } } } } else { makeArray( checkSet, results ); } if ( extra ) { Sizzle( extra, origContext, results, seed ); Sizzle.uniqueSort( results ); } return results; }; Sizzle.uniqueSort = function(results){ if ( sortOrder ) { hasDuplicate = baseHasDuplicate; results.sort(sortOrder); if ( hasDuplicate ) { for ( var i = 1; i < results.length; i++ ) { if ( results[i] === results[i-1] ) { results.splice(i--, 1); } } } } return results; }; Sizzle.matches = function(expr, set){ return Sizzle(expr, null, null, set); }; Sizzle.find = function(expr, context, isXML){ var set, match; if ( !expr ) { return []; } for ( var i = 0, l = Expr.order.length; i < l; i++ ) { var type = Expr.order[i], match; if ( (match = Expr.leftMatch[ type ].exec( expr )) ) { var left = match[1]; match.splice(1,1); if ( left.substr( left.length - 1 ) !== \"\\\\\" ) { match[1] = (match[1] || \"\").replace(/\\\\/g, \"\"); set = Expr.find[ type ]( match, context, isXML ); if ( set != null ) { expr = expr.replace( Expr.match[ type ], \"\" ); break; } } } } if ( !set ) { set = context.getElementsByTagName(\"*\"); } return {set: set, expr: expr}; }; Sizzle.filter = function(expr, set, inplace, not){ var old = expr, result = [], curLoop = set, match, anyFound, isXMLFilter = set && set[0] && isXML(set[0]); while ( expr && set.length ) { for ( var type in Expr.filter ) { if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) { var filter = Expr.filter[ type ], found, item, left = match[1]; anyFound = false; match.splice(1,1); if ( left.substr( left.length - 1 ) === \"\\\\\" ) { continue; } if ( curLoop === result ) { result = []; } if ( Expr.preFilter[ type ] ) { match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter ); if ( !match ) { anyFound = found = true; } else if ( match === true ) { continue; } } if ( match ) { for ( var i = 0; (item = curLoop[i]) != null; i++ ) { if ( item ) { found = filter( item, match, i, curLoop ); var pass = not ^ !!found; if ( inplace && found != null ) { if ( pass ) { anyFound = true; } else { curLoop[i] = false; } } else if ( pass ) { result.push( item ); anyFound = true; } } } } if ( found !== undefined ) { if ( !inplace ) { curLoop = result; } expr = expr.replace( Expr.match[ type ], \"\" ); if ( !anyFound ) { return []; } break; } } } // Improper expression if ( expr === old ) { if ( anyFound == null ) { Sizzle.error( expr ); } else { break; } } old = expr; } return curLoop; }; Sizzle.error = function( msg ) { throw \"Syntax error, unrecognized expression: \" + msg; }; var Expr = Sizzle.selectors = { order: [ \"ID\", \"NAME\", \"TAG\" ], match: { ID: /#((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/, CLASS: /\\.((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/, NAME: /\\[name=['\"]*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)['\"]*\\]/, ATTR: /\\[\\s*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['\"]*)(.*?)\\3|)\\s*\\]/, TAG: /^((?:[\\w\\u00c0-\\uFFFF\\*-]|\\\\.)+)/, CHILD: /:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/, POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/, PSEUDO: /:((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)(?:\\((['\"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/ }, leftMatch: {}, attrMap: { \"class\": \"className\", \"for\": \"htmlFor\" }, attrHandle: { href: function(elem){ return elem.getAttribute(\"href\"); } }, relative: { \"+\": function(checkSet, part){ var isPartStr = typeof part === \"string\", isTag = isPartStr && !/\\W/.test(part), isPartStrNotTag = isPartStr && !isTag; if ( isTag ) { part = part.toLowerCase(); } for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) { if ( (elem = checkSet[i]) ) { while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {} checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ? elem || false : elem === part; } } if ( isPartStrNotTag ) { Sizzle.filter( part, checkSet, true ); } }, \">\": function(checkSet, part){ var isPartStr = typeof part === \"string\"; if ( isPartStr && !/\\W/.test(part) ) { part = part.toLowerCase(); for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { var parent = elem.parentNode; checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false; } } } else { for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { checkSet[i] = isPartStr ? elem.parentNode : elem.parentNode === part; } } if ( isPartStr ) { Sizzle.filter( part, checkSet, true ); } } }, \"\": function(checkSet, part, isXML){ var doneName = done++, checkFn = dirCheck; if ( typeof part === \"string\" && !/\\W/.test(part) ) { var nodeCheck = part = part.toLowerCase(); checkFn = dirNodeCheck; } checkFn(\"parentNode\", part, doneName, checkSet, nodeCheck, isXML); }, \"~\": function(checkSet, part, isXML){ var doneName = done++, checkFn = dirCheck; if ( typeof part === \"string\" && !/\\W/.test(part) ) { var nodeCheck = part = part.toLowerCase(); checkFn = dirNodeCheck; } checkFn(\"previousSibling\", part, doneName, checkSet, nodeCheck, isXML); } }, find: { ID: function(match, context, isXML){ if ( typeof context.getElementById !== \"undefined\" && !isXML ) { var m = context.getElementById(match[1]); return m ? [m] : []; } }, NAME: function(match, context){ if ( typeof context.getElementsByName !== \"undefined\" ) { var ret = [], results = context.getElementsByName(match[1]); for ( var i = 0, l = results.length; i < l; i++ ) { if ( results[i].getAttribute(\"name\") === match[1] ) { ret.push( results[i] ); } } return ret.length === 0 ? null : ret; } }, TAG: function(match, context){ return context.getElementsByTagName(match[1]); } }, preFilter: { CLASS: function(match, curLoop, inplace, result, not, isXML){ match = \" \" + match[1].replace(/\\\\/g, \"\") + \" \"; if ( isXML ) { return match; } for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) { if ( elem ) { if ( not ^ (elem.className && (\" \" + elem.className + \" \").replace(/[\\t\\n]/g, \" \").indexOf(match) >= 0) ) { if ( !inplace ) { result.push( elem ); } } else if ( inplace ) { curLoop[i] = false; } } } return false; }, ID: function(match){ return match[1].replace(/\\\\/g, \"\"); }, TAG: function(match, curLoop){ return match[1].toLowerCase(); }, CHILD: function(match){ if ( match[1] === \"nth\" ) { // parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6' var test = /(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec( match[2] === \"even\" && \"2n\" || match[2] === \"odd\" && \"2n+1\" || !/\\D/.test( match[2] ) && \"0n+\" + match[2] || match[2]); // calculate the numbers (first)n+(last) including if they are negative match[2] = (test[1] + (test[2] || 1)) - 0; match[3] = test[3] - 0; } // TODO: Move to normal caching system match[0] = done++; return match; }, ATTR: function(match, curLoop, inplace, result, not, isXML){ var name = match[1].replace(/\\\\/g, \"\"); if ( !isXML && Expr.attrMap[name] ) { match[1] = Expr.attrMap[name]; } if ( match[2] === \"~=\" ) { match[4] = \" \" + match[4] + \" \"; } return match; }, PSEUDO: function(match, curLoop, inplace, result, not){ if ( match[1] === \"not\" ) { // If we're dealing with a complex expression, or a simple one if ( ( chunker.exec(match[3]) || \"\" ).length > 1 || /^\\w/.test(match[3]) ) { match[3] = Sizzle(match[3], null, null, curLoop); } else { var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not); if ( !inplace ) { result.push.apply( result, ret ); } return false; } } else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) { return true; } return match; }, POS: function(match){ match.unshift( true ); return match; } }, filters: { enabled: function(elem){ return elem.disabled === false && elem.type !== \"hidden\"; }, disabled: function(elem){ return elem.disabled === true; }, checked: function(elem){ return elem.checked === true; }, selected: function(elem){ // Accessing this property makes selected-by-default // options in Safari work properly elem.parentNode.selectedIndex; return elem.selected === true; }, parent: function(elem){ return !!elem.firstChild; }, empty: function(elem){ return !elem.firstChild; }, has: function(elem, i, match){ return !!Sizzle( match[3], elem ).length; }, header: function(elem){ return /h\\d/i.test( elem.nodeName ); }, text: function(elem){ return \"text\" === elem.type; }, radio: function(elem){ return \"radio\" === elem.type; }, checkbox: function(elem){ return \"checkbox\" === elem.type; }, file: function(elem){ return \"file\" === elem.type; }, password: function(elem){ return \"password\" === elem.type; }, submit: function(elem){ return \"submit\" === elem.type; }, image: function(elem){ return \"image\" === elem.type; }, reset: function(elem){ return \"reset\" === elem.type; }, button: function(elem){ return \"button\" === elem.type || elem.nodeName.toLowerCase() === \"button\"; }, input: function(elem){ return /input|select|textarea|button/i.test(elem.nodeName); } }, setFilters: { first: function(elem, i){ return i === 0; }, last: function(elem, i, match, array){ return i === array.length - 1; }, even: function(elem, i){ return i % 2 === 0; }, odd: function(elem, i){ return i % 2 === 1; }, lt: function(elem, i, match){ return i < match[3] - 0; }, gt: function(elem, i, match){ return i > match[3] - 0; }, nth: function(elem, i, match){ return match[3] - 0 === i; }, eq: function(elem, i, match){ return match[3] - 0 === i; } }, filter: { PSEUDO: function(elem, match, i, array){ var name = match[1], filter = Expr.filters[ name ]; if ( filter ) { return filter( elem, i, match, array ); } else if ( name === \"contains\" ) { return (elem.textContent || elem.innerText || getText([ elem ]) || \"\").indexOf(match[3]) >= 0; } else if ( name === \"not\" ) { var not = match[3]; for ( var i = 0, l = not.length; i < l; i++ ) { if ( not[i] === elem ) { return false; } } return true; } else { Sizzle.error( \"Syntax error, unrecognized expression: \" + name ); } }, CHILD: function(elem, match){ var type = match[1], node = elem; switch (type) { case 'only': case 'first': while ( (node = node.previousSibling) ) { if ( node.nodeType === 1 ) { return false; } } if ( type === \"first\" ) { return true; } node = elem; case 'last': while ( (node = node.nextSibling) ) { if ( node.nodeType === 1 ) { return false; } } return true; case 'nth': var first = match[2], last = match[3]; if ( first === 1 && last === 0 ) { return true; } var doneName = match[0], parent = elem.parentNode; if ( parent && (parent.sizcache !== doneName || !elem.nodeIndex) ) { var count = 0; for ( node = parent.firstChild; node; node = node.nextSibling ) { if ( node.nodeType === 1 ) { node.nodeIndex = ++count; } } parent.sizcache = doneName; } var diff = elem.nodeIndex - last; if ( first === 0 ) { return diff === 0; } else { return ( diff % first === 0 && diff / first >= 0 ); } } }, ID: function(elem, match){ return elem.nodeType === 1 && elem.getAttribute(\"id\") === match; }, TAG: function(elem, match){ return (match === \"*\" && elem.nodeType === 1) || elem.nodeName.toLowerCase() === match; }, CLASS: function(elem, match){ return (\" \" + (elem.className || elem.getAttribute(\"class\")) + \" \") .indexOf( match ) > -1; }, ATTR: function(elem, match){ var name = match[1], result = Expr.attrHandle[ name ] ? Expr.attrHandle[ name ]( elem ) : elem[ name ] != null ? elem[ name ] : elem.getAttribute( name ), value = result + \"\", type = match[2], check = match[4]; return result == null ? type === \"!=\" : type === \"=\" ? value === check : type === \"*=\" ? value.indexOf(check) >= 0 : type === \"~=\" ? (\" \" + value + \" \").indexOf(check) >= 0 : !check ? value && result !== false : type === \"!=\" ? value !== check : type === \"^=\" ? value.indexOf(check) === 0 : type === \"$=\" ? value.substr(value.length - check.length) === check : type === \"|=\" ? value === check || value.substr(0, check.length + 1) === check + \"-\" : false; }, POS: function(elem, match, i, array){ var name = match[2], filter = Expr.setFilters[ name ]; if ( filter ) { return filter( elem, i, match, array ); } } } }; var origPOS = Expr.match.POS; for ( var type in Expr.match ) { Expr.match[ type ] = new RegExp( Expr.match[ type ].source + /(?![^\\[]*\\])(?![^\\(]*\\))/.source ); Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\\r|\\n)*?)/.source + Expr.match[ type ].source.replace(/\\\\(\\d+)/g, function(all, num){ return \"\\\\\" + (num - 0 + 1); })); } var makeArray = function(array, results) { array = Array.prototype.slice.call( array, 0 ); if ( results ) { results.push.apply( results, array ); return results; } return array; }; // Perform a simple check to determine if the browser is capable of // converting a NodeList to an array using builtin methods. // Also verifies that the returned array holds DOM nodes // (which is not the case in the Blackberry browser) try { Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType; // Provide a fallback method if it does not work } catch(e){ makeArray = function(array, results) { var ret = results || []; if ( toString.call(array) === \"[object Array]\" ) { Array.prototype.push.apply( ret, array ); } else { if ( typeof array.length === \"number\" ) { for ( var i = 0, l = array.length; i < l; i++ ) { ret.push( array[i] ); } } else { for ( var i = 0; array[i]; i++ ) { ret.push( array[i] ); } } } return ret; }; } var sortOrder; if ( document.documentElement.compareDocumentPosition ) { sortOrder = function( a, b ) { if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) { if ( a == b ) { hasDuplicate = true; } return a.compareDocumentPosition ? -1 : 1; } var ret = a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1; if ( ret === 0 ) { hasDuplicate = true; } return ret; }; } else if ( \"sourceIndex\" in document.documentElement ) { sortOrder = function( a, b ) { if ( !a.sourceIndex || !b.sourceIndex ) { if ( a == b ) { hasDuplicate = true; } return a.sourceIndex ? -1 : 1; } var ret = a.sourceIndex - b.sourceIndex; if ( ret === 0 ) { hasDuplicate = true; } return ret; }; } else if ( document.createRange ) { sortOrder = function( a, b ) { if ( !a.ownerDocument || !b.ownerDocument ) { if ( a == b ) { hasDuplicate = true; } return a.ownerDocument ? -1 : 1; } var aRange = a.ownerDocument.createRange(), bRange = b.ownerDocument.createRange(); aRange.setStart(a, 0); aRange.setEnd(a, 0); bRange.setStart(b, 0); bRange.setEnd(b, 0); var ret = aRange.compareBoundaryPoints(Range.START_TO_END, bRange); if ( ret === 0 ) { hasDuplicate = true; } return ret; }; } // Utility function for retreiving the text value of an array of DOM nodes function getText( elems ) { var ret = \"\", elem; for ( var i = 0; elems[i]; i++ ) { elem = elems[i]; // Get the text from text nodes and CDATA nodes if ( elem.nodeType === 3 || elem.nodeType === 4 ) { ret += elem.nodeValue; // Traverse everything else, except comment nodes } else if ( elem.nodeType !== 8 ) { ret += getText( elem.childNodes ); } } return ret; } // Check to see if the browser returns elements by name when // querying by getElementById (and provide a workaround) (function(){ // We're going to inject a fake input element with a specified name var form = document.createElement(\"div\"), id = \"script\" + (new Date).getTime(); form.innerHTML = \"\"; // Inject it into the root element, check its status, and remove it quickly var root = document.documentElement; root.insertBefore( form, root.firstChild ); // The workaround has to do additional checks after a getElementById // Which slows things down for other browsers (hence the branching) if ( document.getElementById( id ) ) { Expr.find.ID = function(match, context, isXML){ if ( typeof context.getElementById !== \"undefined\" && !isXML ) { var m = context.getElementById(match[1]); return m ? m.id === match[1] || typeof m.getAttributeNode !== \"undefined\" && m.getAttributeNode(\"id\").nodeValue === match[1] ? [m] : undefined : []; } }; Expr.filter.ID = function(elem, match){ var node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\"); return elem.nodeType === 1 && node && node.nodeValue === match; }; } root.removeChild( form ); root = form = null; // release memory in IE })(); (function(){ // Check to see if the browser returns only elements // when doing getElementsByTagName(\"*\") // Create a fake element var div = document.createElement(\"div\"); div.appendChild( document.createComment(\"\") ); // Make sure no comments are found if ( div.getElementsByTagName(\"*\").length > 0 ) { Expr.find.TAG = function(match, context){ var results = context.getElementsByTagName(match[1]); // Filter out possible comments if ( match[1] === \"*\" ) { var tmp = []; for ( var i = 0; results[i]; i++ ) { if ( results[i].nodeType === 1 ) { tmp.push( results[i] ); } } results = tmp; } return results; }; } // Check to see if an attribute returns normalized href attributes div.innerHTML = \"\"; if ( div.firstChild && typeof div.firstChild.getAttribute !== \"undefined\" && div.firstChild.getAttribute(\"href\") !== \"#\" ) { Expr.attrHandle.href = function(elem){ return elem.getAttribute(\"href\", 2); }; } div = null; // release memory in IE })(); if ( document.querySelectorAll ) { (function(){ var oldSizzle = Sizzle, div = document.createElement(\"div\"); div.innerHTML = \"\"; // Safari can't handle uppercase or unicode characters when // in quirks mode. if ( div.querySelectorAll && div.querySelectorAll(\".TEST\").length === 0 ) { return; } Sizzle = function(query, context, extra, seed){ context = context || document; // Only use querySelectorAll on non-XML documents // (ID selectors don't work in non-HTML documents) if ( !seed && context.nodeType === 9 && !isXML(context) ) { try { return makeArray( context.querySelectorAll(query), extra ); } catch(e){} } return oldSizzle(query, context, extra, seed); }; for ( var prop in oldSizzle ) { Sizzle[ prop ] = oldSizzle[ prop ]; } div = null; // release memory in IE })(); } (function(){ var div = document.createElement(\"div\"); div.innerHTML = \"\"; // Opera can't find a second classname (in 9.6) // Also, make sure that getElementsByClassName actually exists if ( !div.getElementsByClassName || div.getElementsByClassName(\"e\").length === 0 ) { return; } // Safari caches class attributes, doesn't catch changes (in 3.2) div.lastChild.className = \"e\"; if ( div.getElementsByClassName(\"e\").length === 1 ) { return; } Expr.order.splice(1, 0, \"CLASS\"); Expr.find.CLASS = function(match, context, isXML) { if ( typeof context.getElementsByClassName !== \"undefined\" && !isXML ) { return context.getElementsByClassName(match[1]); } }; div = null; // release memory in IE })(); function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) { for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { elem = elem[dir]; var match = false; while ( elem ) { if ( elem.sizcache === doneName ) { match = checkSet[elem.sizset]; break; } if ( elem.nodeType === 1 && !isXML ){ elem.sizcache = doneName; elem.sizset = i; } if ( elem.nodeName.toLowerCase() === cur ) { match = elem; break; } elem = elem[dir]; } checkSet[i] = match; } } } function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) { for ( var i = 0, l = checkSet.length; i < l; i++ ) { var elem = checkSet[i]; if ( elem ) { elem = elem[dir]; var match = false; while ( elem ) { if ( elem.sizcache === doneName ) { match = checkSet[elem.sizset]; break; } if ( elem.nodeType === 1 ) { if ( !isXML ) { elem.sizcache = doneName; elem.sizset = i; } if ( typeof cur !== \"string\" ) { if ( elem === cur ) { match = true; break; } } else if ( Sizzle.filter( cur, [elem] ).length > 0 ) { match = elem; break; } } elem = elem[dir]; } checkSet[i] = match; } } } var contains = document.compareDocumentPosition ? function(a, b){ return !!(a.compareDocumentPosition(b) & 16); } : function(a, b){ return a !== b && (a.contains ? a.contains(b) : true); }; var isXML = function(elem){ // documentElement is verified for cases where it doesn't yet exist // (such as loading iframes in IE - #4833) var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement; return documentElement ? documentElement.nodeName !== \"HTML\" : false; }; var posProcess = function(selector, context){ var tmpSet = [], later = \"\", match, root = context.nodeType ? [context] : context; // Position selectors must be done after the filter // And so must :not(positional) so we move all PSEUDOs to the end while ( (match = Expr.match.PSEUDO.exec( selector )) ) { later += match[0]; selector = selector.replace( Expr.match.PSEUDO, \"\" ); } selector = Expr.relative[selector] ? selector + \"*\" : selector; for ( var i = 0, l = root.length; i < l; i++ ) { Sizzle( selector, root[i], tmpSet ); } return Sizzle.filter( later, tmpSet ); }; // EXPOSE jQuery.find = Sizzle; jQuery.expr = Sizzle.selectors; jQuery.expr[\":\"] = jQuery.expr.filters; jQuery.unique = Sizzle.uniqueSort; jQuery.text = getText; jQuery.isXMLDoc = isXML; jQuery.contains = contains; return; window.Sizzle = Sizzle; })(); var runtil = /Until$/, rparentsprev = /^(?:parents|prevUntil|prevAll)/, // Note: This RegExp should be improved, or likely pulled from Sizzle rmultiselector = /,/, slice = Array.prototype.slice; // Implement the identical functionality for filter and not var winnow = function( elements, qualifier, keep ) { if ( jQuery.isFunction( qualifier ) ) { return jQuery.grep(elements, function( elem, i ) { return !!qualifier.call( elem, i, elem ) === keep; }); } else if ( qualifier.nodeType ) { return jQuery.grep(elements, function( elem, i ) { return (elem === qualifier) === keep; }); } else if ( typeof qualifier === \"string\" ) { var filtered = jQuery.grep(elements, function( elem ) { return elem.nodeType === 1; }); if ( isSimple.test( qualifier ) ) { return jQuery.filter(qualifier, filtered, !keep); } else { qualifier = jQuery.filter( qualifier, filtered ); } } return jQuery.grep(elements, function( elem, i ) { return (jQuery.inArray( elem, qualifier ) >= 0) === keep; }); }; jQuery.fn.extend({ find: function( selector ) { var ret = this.pushStack( \"\", \"find\", selector ), length = 0; for ( var i = 0, l = this.length; i < l; i++ ) { length = ret.length; jQuery.find( selector, this[i], ret ); if ( i > 0 ) { // Make sure that the results are unique for ( var n = length; n < ret.length; n++ ) { for ( var r = 0; r < length; r++ ) { if ( ret[r] === ret[n] ) { ret.splice(n--, 1); break; } } } } } return ret; }, has: function( target ) { var targets = jQuery( target ); return this.filter(function() { for ( var i = 0, l = targets.length; i < l; i++ ) { if ( jQuery.contains( this, targets[i] ) ) { return true; } } }); }, not: function( selector ) { return this.pushStack( winnow(this, selector, false), \"not\", selector); }, filter: function( selector ) { return this.pushStack( winnow(this, selector, true), \"filter\", selector ); }, is: function( selector ) { return !!selector && jQuery.filter( selector, this ).length > 0; }, closest: function( selectors, context ) { if ( jQuery.isArray( selectors ) ) { var ret = [], cur = this[0], match, matches = {}, selector; if ( cur && selectors.length ) { for ( var i = 0, l = selectors.length; i < l; i++ ) { selector = selectors[i]; if ( !matches[selector] ) { matches[selector] = jQuery.expr.match.POS.test( selector ) ? jQuery( selector, context || this.context ) : selector; } } while ( cur && cur.ownerDocument && cur !== context ) { for ( selector in matches ) { match = matches[selector]; if ( match.jquery ? match.index(cur) > -1 : jQuery(cur).is(match) ) { ret.push({ selector: selector, elem: cur }); delete matches[selector]; } } cur = cur.parentNode; } } return ret; } var pos = jQuery.expr.match.POS.test( selectors ) ? jQuery( selectors, context || this.context ) : null; return this.map(function( i, cur ) { while ( cur && cur.ownerDocument && cur !== context ) { if ( pos ? pos.index(cur) > -1 : jQuery(cur).is(selectors) ) { return cur; } cur = cur.parentNode; } return null; }); }, // Determine the position of an element within // the matched set of elements index: function( elem ) { if ( !elem || typeof elem === \"string\" ) { return jQuery.inArray( this[0], // If it receives a string, the selector is used // If it receives nothing, the siblings are used elem ? jQuery( elem ) : this.parent().children() ); } // Locate the position of the desired element return jQuery.inArray( // If it receives a jQuery object, the first element is used elem.jquery ? elem[0] : elem, this ); }, add: function( selector, context ) { var set = typeof selector === \"string\" ? jQuery( selector, context || this.context ) : jQuery.makeArray( selector ), all = jQuery.merge( this.get(), set ); return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ? all : jQuery.unique( all ) ); }, andSelf: function() { return this.add( this.prevObject ); } }); // A painfully simple check to see if an element is disconnected // from a document (should be improved, where feasible). function isDisconnected( node ) { return !node || !node.parentNode || node.parentNode.nodeType === 11; } jQuery.each({ parent: function( elem ) { var parent = elem.parentNode; return parent && parent.nodeType !== 11 ? parent : null; }, parents: function( elem ) { return jQuery.dir( elem, \"parentNode\" ); }, parentsUntil: function( elem, i, until ) { return jQuery.dir( elem, \"parentNode\", until ); }, next: function( elem ) { return jQuery.nth( elem, 2, \"nextSibling\" ); }, prev: function( elem ) { return jQuery.nth( elem, 2, \"previousSibling\" ); }, nextAll: function( elem ) { return jQuery.dir( elem, \"nextSibling\" ); }, prevAll: function( elem ) { return jQuery.dir( elem, \"previousSibling\" ); }, nextUntil: function( elem, i, until ) { return jQuery.dir( elem, \"nextSibling\", until ); }, prevUntil: function( elem, i, until ) { return jQuery.dir( elem, \"previousSibling\", until ); }, siblings: function( elem ) { return jQuery.sibling( elem.parentNode.firstChild, elem ); }, children: function( elem ) { return jQuery.sibling( elem.firstChild ); }, contents: function( elem ) { return jQuery.nodeName( elem, \"iframe\" ) ? elem.contentDocument || elem.contentWindow.document : jQuery.makeArray( elem.childNodes ); } }, function( name, fn ) { jQuery.fn[ name ] = function( until, selector ) { var ret = jQuery.map( this, fn, until ); if ( !runtil.test( name ) ) { selector = until; } if ( selector && typeof selector === \"string\" ) { ret = jQuery.filter( selector, ret ); } ret = this.length > 1 ? jQuery.unique( ret ) : ret; if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) { ret = ret.reverse(); } return this.pushStack( ret, name, slice.call(arguments).join(\",\") ); }; }); jQuery.extend({ filter: function( expr, elems, not ) { if ( not ) { expr = \":not(\" + expr + \")\"; } return jQuery.find.matches(expr, elems); }, dir: function( elem, dir, until ) { var matched = [], cur = elem[dir]; while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) { if ( cur.nodeType === 1 ) { matched.push( cur ); } cur = cur[dir]; } return matched; }, nth: function( cur, result, dir, elem ) { result = result || 1; var num = 0; for ( ; cur; cur = cur[dir] ) { if ( cur.nodeType === 1 && ++num === result ) { break; } } return cur; }, sibling: function( n, elem ) { var r = []; for ( ; n; n = n.nextSibling ) { if ( n.nodeType === 1 && n !== elem ) { r.push( n ); } } return r; } }); var rinlinejQuery = / jQuery\\d+=\"(?:\\d+|null)\"/g, rleadingWhitespace = /^\\s+/, rxhtmlTag = /(]*?)\\/>/g, rselfClosing = /^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i, rtagName = /\\s]+\\/)>/g, '=\"$1\">') .replace(rleadingWhitespace, \"\")], ownerDocument)[0]; } else { return this.cloneNode(true); } }); // Copy the events from the original to the clone if ( events === true ) { cloneCopyEvent( this, ret ); cloneCopyEvent( this.find(\"*\"), ret.find(\"*\") ); } // Return the cloned set return ret; }, html: function( value ) { if ( value === undefined ) { return this[0] && this[0].nodeType === 1 ? this[0].innerHTML.replace(rinlinejQuery, \"\") : null; // See if we can take a shortcut and just use innerHTML } else if ( typeof value === \"string\" && !rnocache.test( value ) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) && !wrapMap[ (rtagName.exec( value ) || [\"\", \"\"])[1].toLowerCase() ] ) { value = value.replace(rxhtmlTag, fcloseTag); try { for ( var i = 0, l = this.length; i < l; i++ ) { // Remove element nodes and prevent memory leaks if ( this[i].nodeType === 1 ) { jQuery.cleanData( this[i].getElementsByTagName(\"*\") ); this[i].innerHTML = value; } } // If using innerHTML throws an exception, use the fallback method } catch(e) { this.empty().append( value ); } } else if ( jQuery.isFunction( value ) ) { this.each(function(i){ var self = jQuery(this), old = self.html(); self.empty().append(function(){ return value.call( this, i, old ); }); }); } else { this.empty().append( value ); } return this; }, replaceWith: function( value ) { if ( this[0] && this[0].parentNode ) { // Make sure that the elements are removed from the DOM before they are inserted // this can help fix replacing a parent with child elements if ( jQuery.isFunction( value ) ) { return this.each(function(i) { var self = jQuery(this), old = self.html(); self.replaceWith( value.call( this, i, old ) ); }); } if ( typeof value !== \"string\" ) { value = jQuery(value).detach(); } return this.each(function() { var next = this.nextSibling, parent = this.parentNode; jQuery(this).remove(); if ( next ) { jQuery(next).before( value ); } else { jQuery(parent).append( value ); } }); } else { return this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), \"replaceWith\", value ); } }, detach: function( selector ) { return this.remove( selector, true ); }, domManip: function( args, table, callback ) { var results, first, value = args[0], scripts = [], fragment, parent; // We can't cloneNode fragments that contain checked, in WebKit if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === \"string\" && rchecked.test( value ) ) { return this.each(function() { jQuery(this).domManip( args, table, callback, true ); }); } if ( jQuery.isFunction(value) ) { return this.each(function(i) { var self = jQuery(this); args[0] = value.call(this, i, table ? self.html() : undefined); self.domManip( args, table, callback ); }); } if ( this[0] ) { parent = value && value.parentNode; // If we're in a fragment, just use that instead of building a new one if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) { results = { fragment: parent }; } else { results = buildFragment( args, this, scripts ); } fragment = results.fragment; if ( fragment.childNodes.length === 1 ) { first = fragment = fragment.firstChild; } else { first = fragment.firstChild; } if ( first ) { table = table && jQuery.nodeName( first, \"tr\" ); for ( var i = 0, l = this.length; i < l; i++ ) { callback.call( table ? root(this[i], first) : this[i], i > 0 || results.cacheable || this.length > 1 ? fragment.cloneNode(true) : fragment ); } } if ( scripts.length ) { jQuery.each( scripts, evalScript ); } } return this; function root( elem, cur ) { return jQuery.nodeName(elem, \"table\") ? (elem.getElementsByTagName(\"tbody\")[0] || elem.appendChild(elem.ownerDocument.createElement(\"tbody\"))) : elem; } } }); function cloneCopyEvent(orig, ret) { var i = 0; ret.each(function() { if ( this.nodeName !== (orig[i] && orig[i].nodeName) ) { return; } var oldData = jQuery.data( orig[i++] ), curData = jQuery.data( this, oldData ), events = oldData && oldData.events; if ( events ) { delete curData.handle; curData.events = {}; for ( var type in events ) { for ( var handler in events[ type ] ) { jQuery.event.add( this, type, events[ type ][ handler ], events[ type ][ handler ].data ); } } } }); } function buildFragment( args, nodes, scripts ) { var fragment, cacheable, cacheresults, doc = (nodes && nodes[0] ? nodes[0].ownerDocument || nodes[0] : document); // Only cache \"small\" (1/2 KB) strings that are associated with the main document // Cloning options loses the selected state, so don't cache them // IE 6 doesn't like it when you put or elements in a fragment // Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache if ( args.length === 1 && typeof args[0] === \"string\" && args[0].length < 512 && doc === document && !rnocache.test( args[0] ) && (jQuery.support.checkClone || !rchecked.test( args[0] )) ) { cacheable = true; cacheresults = jQuery.fragments[ args[0] ]; if ( cacheresults ) { if ( cacheresults !== 1 ) { fragment = cacheresults; } } } if ( !fragment ) { fragment = doc.createDocumentFragment(); jQuery.clean( args, doc, fragment, scripts ); } if ( cacheable ) { jQuery.fragments[ args[0] ] = cacheresults ? fragment : 1; } return { fragment: fragment, cacheable: cacheable }; } jQuery.fragments = {}; jQuery.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function( name, original ) { jQuery.fn[ name ] = function( selector ) { var ret = [], insert = jQuery( selector ), parent = this.length === 1 && this[0].parentNode; if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) { insert[ original ]( this[0] ); return this; } else { for ( var i = 0, l = insert.length; i < l; i++ ) { var elems = (i > 0 ? this.clone(true) : this).get(); jQuery.fn[ original ].apply( jQuery(insert[i]), elems ); ret = ret.concat( elems ); } return this.pushStack( ret, name, insert.selector ); } }; }); jQuery.extend({ clean: function( elems, context, fragment, scripts ) { context = context || document; // !context.createElement fails in IE with an error but returns typeof 'object' if ( typeof context.createElement === \"undefined\" ) { context = context.ownerDocument || context[0] && context[0].ownerDocument || document; } var ret = []; for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) { if ( typeof elem === \"number\" ) { elem += \"\"; } if ( !elem ) { continue; } // Convert html string into DOM nodes if ( typeof elem === \"string\" && !rhtml.test( elem ) ) { elem = context.createTextNode( elem ); } else if ( typeof elem === \"string\" ) { // Fix \"XHTML\"-style tags in all browsers elem = elem.replace(rxhtmlTag, fcloseTag); // Trim whitespace, otherwise indexOf won't work as expected var tag = (rtagName.exec( elem ) || [\"\", \"\"])[1].toLowerCase(), wrap = wrapMap[ tag ] || wrapMap._default, depth = wrap[0], div = context.createElement(\"div\"); // Go to html and back, then peel off extra wrappers div.innerHTML = wrap[1] + elem + wrap[2]; // Move to the right depth while ( depth-- ) { div = div.lastChild; } // Remove IE's autoinserted from table fragments if ( !jQuery.support.tbody ) { // String was a , *may* have spurious var hasBody = rtbody.test(elem), tbody = tag === \"table\" && !hasBody ? div.firstChild && div.firstChild.childNodes : // String was a bare or wrap[1] === \"\" && !hasBody ? div.childNodes : []; for ( var j = tbody.length - 1; j >= 0 ; --j ) { if ( jQuery.nodeName( tbody[ j ], \"tbody\" ) && !tbody[ j ].childNodes.length ) { tbody[ j ].parentNode.removeChild( tbody[ j ] ); } } } // IE completely kills leading whitespace when innerHTML is used if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) { div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild ); } elem = div.childNodes; } if ( elem.nodeType ) { ret.push( elem ); } else { ret = jQuery.merge( ret, elem ); } } if ( fragment ) { for ( var i = 0; ret[i]; i++ ) { if ( scripts && jQuery.nodeName( ret[i], \"script\" ) && (!ret[i].type || ret[i].type.toLowerCase() === \"text/javascript\") ) { scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] ); } else { if ( ret[i].nodeType === 1 ) { ret.splice.apply( ret, [i + 1, 0].concat(jQuery.makeArray(ret[i].getElementsByTagName(\"script\"))) ); } fragment.appendChild( ret[i] ); } } } return ret; }, cleanData: function( elems ) { var data, id, cache = jQuery.cache, special = jQuery.event.special, deleteExpando = jQuery.support.deleteExpando; for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) { id = elem[ jQuery.expando ]; if ( id ) { data = cache[ id ]; if ( data.events ) { for ( var type in data.events ) { if ( special[ type ] ) { jQuery.event.remove( elem, type ); } else { removeEvent( elem, type, data.handle ); } } } if ( deleteExpando ) { delete elem[ jQuery.expando ]; } else if ( elem.removeAttribute ) { elem.removeAttribute( jQuery.expando ); } delete cache[ id ]; } } } }); // exclude the following css properties to add px var rexclude = /z-?index|font-?weight|opacity|zoom|line-?height/i, ralpha = /alpha\\([^)]*\\)/, ropacity = /opacity=([^)]*)/, rfloat = /float/i, rdashAlpha = /-([a-z])/ig, rupper = /([A-Z])/g, rnumpx = /^-?\\d+(?:px)?$/i, rnum = /^-?\\d/, cssShow = { position: \"absolute\", visibility: \"hidden\", display:\"block\" }, cssWidth = [ \"Left\", \"Right\" ], cssHeight = [ \"Top\", \"Bottom\" ], // cache check for defaultView.getComputedStyle getComputedStyle = document.defaultView && document.defaultView.getComputedStyle, // normalize float css property styleFloat = jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\", fcamelCase = function( all, letter ) { return letter.toUpperCase(); }; jQuery.fn.css = function( name, value ) { return access( this, name, value, true, function( elem, name, value ) { if ( value === undefined ) { return jQuery.curCSS( elem, name ); } if ( typeof value === \"number\" && !rexclude.test(name) ) { value += \"px\"; } jQuery.style( elem, name, value ); }); }; jQuery.extend({ style: function( elem, name, value ) { // don't set styles on text and comment nodes if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 ) { return undefined; } // ignore negative width and height values #1599 if ( (name === \"width\" || name === \"height\") && parseFloat(value) < 0 ) { value = undefined; } var style = elem.style || elem, set = value !== undefined; // IE uses filters for opacity if ( !jQuery.support.opacity && name === \"opacity\" ) { if ( set ) { // IE has trouble with opacity if it does not have layout // Force it by setting the zoom level style.zoom = 1; // Set the alpha filter to set the opacity var opacity = parseInt( value, 10 ) + \"\" === \"NaN\" ? \"\" : \"alpha(opacity=\" + value * 100 + \")\"; var filter = style.filter || jQuery.curCSS( elem, \"filter\" ) || \"\"; style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : opacity; } return style.filter && style.filter.indexOf(\"opacity=\") >= 0 ? (parseFloat( ropacity.exec(style.filter)[1] ) / 100) + \"\": \"\"; } // Make sure we're using the right name for getting the float value if ( rfloat.test( name ) ) { name = styleFloat; } name = name.replace(rdashAlpha, fcamelCase); if ( set ) { style[ name ] = value; } return style[ name ]; }, css: function( elem, name, force, extra ) { if ( name === \"width\" || name === \"height\" ) { var val, props = cssShow, which = name === \"width\" ? cssWidth : cssHeight; function getWH() { val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight; if ( extra === \"border\" ) { return; } jQuery.each( which, function() { if ( !extra ) { val -= parseFloat(jQuery.curCSS( elem, \"padding\" + this, true)) || 0; } if ( extra === \"margin\" ) { val += parseFloat(jQuery.curCSS( elem, \"margin\" + this, true)) || 0; } else { val -= parseFloat(jQuery.curCSS( elem, \"border\" + this + \"Width\", true)) || 0; } }); } if ( elem.offsetWidth !== 0 ) { getWH(); } else { jQuery.swap( elem, props, getWH ); } return Math.max(0, Math.round(val)); } return jQuery.curCSS( elem, name, force ); }, curCSS: function( elem, name, force ) { var ret, style = elem.style, filter; // IE uses filters for opacity if ( !jQuery.support.opacity && name === \"opacity\" && elem.currentStyle ) { ret = ropacity.test(elem.currentStyle.filter || \"\") ? (parseFloat(RegExp.$1) / 100) + \"\" : \"\"; return ret === \"\" ? \"1\" : ret; } // Make sure we're using the right name for getting the float value if ( rfloat.test( name ) ) { name = styleFloat; } if ( !force && style && style[ name ] ) { ret = style[ name ]; } else if ( getComputedStyle ) { // Only \"float\" is needed here if ( rfloat.test( name ) ) { name = \"float\"; } name = name.replace( rupper, \"-$1\" ).toLowerCase(); var defaultView = elem.ownerDocument.defaultView; if ( !defaultView ) { return null; } var computedStyle = defaultView.getComputedStyle( elem, null ); if ( computedStyle ) { ret = computedStyle.getPropertyValue( name ); } // We should always get a number back from opacity if ( name === \"opacity\" && ret === \"\" ) { ret = \"1\"; } } else if ( elem.currentStyle ) { var camelCase = name.replace(rdashAlpha, fcamelCase); ret = elem.currentStyle[ name ] || elem.currentStyle[ camelCase ]; // From the awesome hack by Dean Edwards // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291 // If we're not dealing with a regular pixel number // but a number that has a weird ending, we need to convert it to pixels if ( !rnumpx.test( ret ) && rnum.test( ret ) ) { // Remember the original values var left = style.left, rsLeft = elem.runtimeStyle.left; // Put in the new values to get a computed value out elem.runtimeStyle.left = elem.currentStyle.left; style.left = camelCase === \"fontSize\" ? \"1em\" : (ret || 0); ret = style.pixelLeft + \"px\"; // Revert the changed values style.left = left; elem.runtimeStyle.left = rsLeft; } } return ret; }, // A method for quickly swapping in/out CSS properties to get correct calculations swap: function( elem, options, callback ) { var old = {}; // Remember the old values, and insert the new ones for ( var name in options ) { old[ name ] = elem.style[ name ]; elem.style[ name ] = options[ name ]; } callback.call( elem ); // Revert the old values for ( var name in options ) { elem.style[ name ] = old[ name ]; } } }); if ( jQuery.expr && jQuery.expr.filters ) { jQuery.expr.filters.hidden = function( elem ) { var width = elem.offsetWidth, height = elem.offsetHeight, skip = elem.nodeName.toLowerCase() === \"tr\"; return width === 0 && height === 0 && !skip ? true : width > 0 && height > 0 && !skip ? false : jQuery.curCSS(elem, \"display\") === \"none\"; }; jQuery.expr.filters.visible = function( elem ) { return !jQuery.expr.filters.hidden( elem ); }; } var jsc = now(), rscript = //gi, rselectTextarea = /select|textarea/i, rinput = /color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i, jsre = /=\\?(&|$)/, rquery = /\\?/, rts = /(\\?|&)_=.*?(&|$)/, rurl = /^(\\w+:)?\\/\\/([^\\/?#]+)/, r20 = /%20/g, // Keep a copy of the old load method _load = jQuery.fn.load; jQuery.fn.extend({ load: function( url, params, callback ) { if ( typeof url !== \"string\" ) { return _load.call( this, url ); // Don't do a request if no elements are being requested } else if ( !this.length ) { return this; } var off = url.indexOf(\" \"); if ( off >= 0 ) { var selector = url.slice(off, url.length); url = url.slice(0, off); } // Default to a GET request var type = \"GET\"; // If the second parameter was provided if ( params ) { // If it's a function if ( jQuery.isFunction( params ) ) { // We assume that it's the callback callback = params; params = null; // Otherwise, build a param string } else if ( typeof params === \"object\" ) { params = jQuery.param( params, jQuery.ajaxSettings.traditional ); type = \"POST\"; } } var self = this; // Request the remote document jQuery.ajax({ url: url, type: type, dataType: \"html\", data: params, complete: function( res, status ) { // If successful, inject the HTML into all the matched elements if ( status === \"success\" || status === \"notmodified\" ) { // See if a selector was specified self.html( selector ? // Create a dummy div to hold the results jQuery(\"\") // inject the contents of the document in, removing the scripts // to avoid any 'Permission Denied' errors in IE .append(res.responseText.replace(rscript, \"\")) // Locate the specified elements .find(selector) : // If not, just inject the full result res.responseText ); } if ( callback ) { self.each( callback, [res.responseText, status, res] ); } } }); return this; }, serialize: function() { return jQuery.param(this.serializeArray()); }, serializeArray: function() { return this.map(function() { return this.elements ? jQuery.makeArray(this.elements) : this; }) .filter(function() { return this.name && !this.disabled && (this.checked || rselectTextarea.test(this.nodeName) || rinput.test(this.type)); }) .map(function( i, elem ) { var val = jQuery(this).val(); return val == null ? null : jQuery.isArray(val) ? jQuery.map( val, function( val, i ) { return { name: elem.name, value: val }; }) : { name: elem.name, value: val }; }).get(); } }); // Attach a bunch of functions for handling common AJAX events jQuery.each( \"ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend\".split(\" \"), function( i, o ) { jQuery.fn[o] = function( f ) { return this.bind(o, f); }; }); jQuery.extend({ get: function( url, data, callback, type ) { // shift arguments if data argument was omited if ( jQuery.isFunction( data ) ) { type = type || callback; callback = data; data = null; } return jQuery.ajax({ type: \"GET\", url: url, data: data, success: callback, dataType: type }); }, getScript: function( url, callback ) { return jQuery.get(url, null, callback, \"script\"); }, getJSON: function( url, data, callback ) { return jQuery.get(url, data, callback, \"json\"); }, post: function( url, data, callback, type ) { // shift arguments if data argument was omited if ( jQuery.isFunction( data ) ) { type = type || callback; callback = data; data = {}; } return jQuery.ajax({ type: \"POST\", url: url, data: data, success: callback, dataType: type }); }, ajaxSetup: function( settings ) { jQuery.extend( jQuery.ajaxSettings, settings ); }, ajaxSettings: { url: location.href, global: true, type: \"GET\", contentType: \"application/x-www-form-urlencoded\", processData: true, async: true, /* timeout: 0, data: null, username: null, password: null, traditional: false, */ // Create the request object; Microsoft failed to properly // implement the XMLHttpRequest in IE7 (can't request local files), // so we use the ActiveXObject when it is available // This function can be overriden by calling jQuery.ajaxSetup xhr: window.XMLHttpRequest && (window.location.protocol !== \"file:\" || !window.ActiveXObject) ? function() { return new window.XMLHttpRequest(); } : function() { try { return new window.ActiveXObject(\"Microsoft.XMLHTTP\"); } catch(e) {} }, accepts: { xml: \"application/xml, text/xml\", html: \"text/html\", script: \"text/javascript, application/javascript\", json: \"application/json, text/javascript\", text: \"text/plain\", _default: \"*/*\" } }, // Last-Modified header cache for next request lastModified: {}, etag: {}, ajax: function( origSettings ) { var s = jQuery.extend(true, {}, jQuery.ajaxSettings, origSettings); var jsonp, status, data, callbackContext = origSettings && origSettings.context || s, type = s.type.toUpperCase(); // convert data if not already a string if ( s.data && s.processData && typeof s.data !== \"string\" ) { s.data = jQuery.param( s.data, s.traditional ); } // Handle JSONP Parameter Callbacks if ( s.dataType === \"jsonp\" ) { if ( type === \"GET\" ) { if ( !jsre.test( s.url ) ) { s.url += (rquery.test( s.url ) ? \"&\" : \"?\") + (s.jsonp || \"callback\") + \"=?\"; } } else if ( !s.data || !jsre.test(s.data) ) { s.data = (s.data ? s.data + \"&\" : \"\") + (s.jsonp || \"callback\") + \"=?\"; } s.dataType = \"json\"; } // Build temporary JSONP function if ( s.dataType === \"json\" && (s.data && jsre.test(s.data) || jsre.test(s.url)) ) { jsonp = s.jsonpCallback || (\"jsonp\" + jsc++); // Replace the =? sequence both in the query string and the data if ( s.data ) { s.data = (s.data + \"\").replace(jsre, \"=\" + jsonp + \"$1\"); } s.url = s.url.replace(jsre, \"=\" + jsonp + \"$1\"); // We need to make sure // that a JSONP style response is executed properly s.dataType = \"script\"; // Handle JSONP-style loading window[ jsonp ] = window[ jsonp ] || function( tmp ) { data = tmp; success(); complete(); // Garbage collect window[ jsonp ] = undefined; try { delete window[ jsonp ]; } catch(e) {} if ( head ) { head.removeChild( script ); } }; } if ( s.dataType === \"script\" && s.cache === null ) { s.cache = false; } if ( s.cache === false && type === \"GET\" ) { var ts = now(); // try replacing _= if it is there var ret = s.url.replace(rts, \"$1_=\" + ts + \"$2\"); // if nothing was replaced, add timestamp to the end s.url = ret + ((ret === s.url) ? (rquery.test(s.url) ? \"&\" : \"?\") + \"_=\" + ts : \"\"); } // If data is available, append data to url for get requests if ( s.data && type === \"GET\" ) { s.url += (rquery.test(s.url) ? \"&\" : \"?\") + s.data; } // Watch for a new set of requests if ( s.global && ! jQuery.active++ ) { jQuery.event.trigger( \"ajaxStart\" ); } // Matches an absolute URL, and saves the domain var parts = rurl.exec( s.url ), remote = parts && (parts[1] && parts[1] !== location.protocol || parts[2] !== location.host); // If we're requesting a remote document // and trying to load JSON or Script with a GET if ( s.dataType === \"script\" && type === \"GET\" && remote ) { var head = document.getElementsByTagName(\"head\")[0] || document.documentElement; var script = document.createElement(\"script\"); script.src = s.url; if ( s.scriptCharset ) { script.charset = s.scriptCharset; } // Handle Script loading if ( !jsonp ) { var done = false; // Attach handlers for all browsers script.onload = script.onreadystatechange = function() { if ( !done && (!this.readyState || this.readyState === \"loaded\" || this.readyState === \"complete\") ) { done = true; success(); complete(); // Handle memory leak in IE script.onload = script.onreadystatechange = null; if ( head && script.parentNode ) { head.removeChild( script ); } } }; } // Use insertBefore instead of appendChild to circumvent an IE6 bug. // This arises when a base node is used (#2709 and #4378). head.insertBefore( script, head.firstChild ); // We handle everything using the script element injection return undefined; } var requestDone = false; // Create the request object var xhr = s.xhr(); if ( !xhr ) { return; } // Open the socket // Passing null username, generates a login popup on Opera (#2865) if ( s.username ) { xhr.open(type, s.url, s.async, s.username, s.password); } else { xhr.open(type, s.url, s.async); } // Need an extra try/catch for cross domain requests in Firefox 3 try { // Set the correct header, if data is being sent if ( s.data || origSettings && origSettings.contentType ) { xhr.setRequestHeader(\"Content-Type\", s.contentType); } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode. if ( s.ifModified ) { if ( jQuery.lastModified[s.url] ) { xhr.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[s.url]); } if ( jQuery.etag[s.url] ) { xhr.setRequestHeader(\"If-None-Match\", jQuery.etag[s.url]); } } // Set header so the called script knows that it's an XMLHttpRequest // Only send the header if it's not a remote XHR if ( !remote ) { xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\"); } // Set the Accepts header for the server, depending on the dataType xhr.setRequestHeader(\"Accept\", s.dataType && s.accepts[ s.dataType ] ? s.accepts[ s.dataType ] + \", */*\" : s.accepts._default ); } catch(e) {} // Allow custom headers/mimetypes and early abort if ( s.beforeSend && s.beforeSend.call(callbackContext, xhr, s) === false ) { // Handle the global AJAX counter if ( s.global && ! --jQuery.active ) { jQuery.event.trigger( \"ajaxStop\" ); } // close opended socket xhr.abort(); return false; } if ( s.global ) { trigger(\"ajaxSend\", [xhr, s]); } // Wait for a response to come back var onreadystatechange = xhr.onreadystatechange = function( isTimeout ) { // The request was aborted if ( !xhr || xhr.readyState === 0 || isTimeout === \"abort\" ) { // Opera doesn't call onreadystatechange before this point // so we simulate the call if ( !requestDone ) { complete(); } requestDone = true; if ( xhr ) { xhr.onreadystatechange = jQuery.noop; } // The transfer is complete and the data is available, or the request timed out } else if ( !requestDone && xhr && (xhr.readyState === 4 || isTimeout === \"timeout\") ) { requestDone = true; xhr.onreadystatechange = jQuery.noop; status = isTimeout === \"timeout\" ? \"timeout\" : !jQuery.httpSuccess( xhr ) ? \"error\" : s.ifModified && jQuery.httpNotModified( xhr, s.url ) ? \"notmodified\" : \"success\"; var errMsg; if ( status === \"success\" ) { // Watch for, and catch, XML document parse errors try { // process the data (runs the xml through httpData regardless of callback) data = jQuery.httpData( xhr, s.dataType, s ); } catch(err) { status = \"parsererror\"; errMsg = err; } } // Make sure that the request was successful or notmodified if ( status === \"success\" || status === \"notmodified\" ) { // JSONP handles its own success callback if ( !jsonp ) { success(); } } else { jQuery.handleError(s, xhr, status, errMsg); } // Fire the complete handlers complete(); if ( isTimeout === \"timeout\" ) { xhr.abort(); } // Stop memory leaks if ( s.async ) { xhr = null; } } }; // Override the abort handler, if we can (IE doesn't allow it, but that's OK) // Opera doesn't fire onreadystatechange at all on abort try { var oldAbort = xhr.abort; xhr.abort = function() { if ( xhr ) { oldAbort.call( xhr ); } onreadystatechange( \"abort\" ); }; } catch(e) { } // Timeout checker if ( s.async && s.timeout > 0 ) { setTimeout(function() { // Check to see if the request is still happening if ( xhr && !requestDone ) { onreadystatechange( \"timeout\" ); } }, s.timeout); } // Send the data try { xhr.send( type === \"POST\" || type === \"PUT\" || type === \"DELETE\" ? s.data : null ); } catch(e) { jQuery.handleError(s, xhr, null, e); // Fire the complete handlers complete(); } // firefox 1.5 doesn't fire statechange for sync requests if ( !s.async ) { onreadystatechange(); } function success() { // If a local callback was specified, fire it and pass it the data if ( s.success ) { s.success.call( callbackContext, data, status, xhr ); } // Fire the global callback if ( s.global ) { trigger( \"ajaxSuccess\", [xhr, s] ); } } function complete() { // Process result if ( s.complete ) { s.complete.call( callbackContext, xhr, status); } // The request was completed if ( s.global ) { trigger( \"ajaxComplete\", [xhr, s] ); } // Handle the global AJAX counter if ( s.global && ! --jQuery.active ) { jQuery.event.trigger( \"ajaxStop\" ); } } function trigger(type, args) { (s.context ? jQuery(s.context) : jQuery.event).trigger(type, args); } // return XMLHttpRequest to allow aborting the request etc. return xhr; }, handleError: function( s, xhr, status, e ) { // If a local callback was specified, fire it if ( s.error ) { s.error.call( s.context || s, xhr, status, e ); } // Fire the global callback if ( s.global ) { (s.context ? jQuery(s.context) : jQuery.event).trigger( \"ajaxError\", [xhr, s, e] ); } }, // Counter for holding the number of active queries active: 0, // Determines if an XMLHttpRequest was successful or not httpSuccess: function( xhr ) { try { // IE error sometimes returns 1223 when it should be 204 so treat it as success, see #1450 return !xhr.status && location.protocol === \"file:\" || // Opera returns 0 when status is 304 ( xhr.status >= 200 && xhr.status < 300 ) || xhr.status === 304 || xhr.status === 1223 || xhr.status === 0; } catch(e) {} return false; }, // Determines if an XMLHttpRequest returns NotModified httpNotModified: function( xhr, url ) { var lastModified = xhr.getResponseHeader(\"Last-Modified\"), etag = xhr.getResponseHeader(\"Etag\"); if ( lastModified ) { jQuery.lastModified[url] = lastModified; } if ( etag ) { jQuery.etag[url] = etag; } // Opera returns 0 when status is 304 return xhr.status === 304 || xhr.status === 0; }, httpData: function( xhr, type, s ) { var ct = xhr.getResponseHeader(\"content-type\") || \"\", xml = type === \"xml\" || !type && ct.indexOf(\"xml\") >= 0, data = xml ? xhr.responseXML : xhr.responseText; if ( xml && data.documentElement.nodeName === \"parsererror\" ) { jQuery.error( \"parsererror\" ); } // Allow a pre-filtering function to sanitize the response // s is checked to keep backwards compatibility if ( s && s.dataFilter ) { data = s.dataFilter( data, type ); } // The filter can actually parse the response if ( typeof data === \"string\" ) { // Get the JavaScript object, if JSON is used. if ( type === \"json\" || !type && ct.indexOf(\"json\") >= 0 ) { data = jQuery.parseJSON( data ); // If the type is \"script\", eval it in global context } else if ( type === \"script\" || !type && ct.indexOf(\"javascript\") >= 0 ) { jQuery.globalEval( data ); } } return data; }, // Serialize an array of form elements or a set of // key/values into a query string param: function( a, traditional ) { var s = []; // Set traditional to true for jQuery -10000 ? r : parseFloat(jQuery.curCSS(this.elem, this.prop)) || 0; }, // Start an animation from one number to another custom: function( from, to, unit ) { this.startTime = now(); this.start = from; this.end = to; this.unit = unit || this.unit || \"px\"; this.now = this.start; this.pos = this.state = 0; var self = this; function t( gotoEnd ) { return self.step(gotoEnd); } t.elem = this.elem; if ( t() && jQuery.timers.push(t) && !timerId ) { timerId = setInterval(jQuery.fx.tick, 13); } }, // Simple 'show' function show: function() { // Remember where we started, so that we can go back to it later this.options.orig[this.prop] = jQuery.style( this.elem, this.prop ); this.options.show = true; // Begin the animation // Make sure that we start at a small width/height to avoid any // flash of content this.custom(this.prop === \"width\" || this.prop === \"height\" ? 1 : 0, this.cur()); // Start by showing the element jQuery( this.elem ).show(); }, // Simple 'hide' function hide: function() { // Remember where we started, so that we can go back to it later this.options.orig[this.prop] = jQuery.style( this.elem, this.prop ); this.options.hide = true; // Begin the animation this.custom(this.cur(), 0); }, // Each step of an animation step: function( gotoEnd ) { var t = now(), done = true; if ( gotoEnd || t >= this.options.duration + this.startTime ) { this.now = this.end; this.pos = this.state = 1; this.update(); this.options.curAnim[ this.prop ] = true; for ( var i in this.options.curAnim ) { if ( this.options.curAnim[i] !== true ) { done = false; } } if ( done ) { if ( this.options.display != null ) { // Reset the overflow this.elem.style.overflow = this.options.overflow; // Reset the display var old = jQuery.data(this.elem, \"olddisplay\"); this.elem.style.display = old ? old : this.options.display; if ( jQuery.css(this.elem, \"display\") === \"none\" ) { this.elem.style.display = \"block\"; } } // Hide the element if the \"hide\" operation was done if ( this.options.hide ) { jQuery(this.elem).hide(); } // Reset the properties, if the item has been hidden or shown if ( this.options.hide || this.options.show ) { for ( var p in this.options.curAnim ) { jQuery.style(this.elem, p, this.options.orig[p]); } } // Execute the complete function this.options.complete.call( this.elem ); } return false; } else { var n = t - this.startTime; this.state = n / this.options.duration; // Perform the easing function, defaults to swing var specialEasing = this.options.specialEasing && this.options.specialEasing[this.prop]; var defaultEasing = this.options.easing || (jQuery.easing.swing ? \"swing\" : \"linear\"); this.pos = jQuery.easing[specialEasing || defaultEasing](this.state, n, 0, 1, this.options.duration); this.now = this.start + ((this.end - this.start) * this.pos); // Perform the next step of the animation this.update(); } return true; } }; jQuery.extend( jQuery.fx, { tick: function() { var timers = jQuery.timers; for ( var i = 0; i < timers.length; i++ ) { if ( !timers[i]() ) { timers.splice(i--, 1); } } if ( !timers.length ) { jQuery.fx.stop(); } }, stop: function() { clearInterval( timerId ); timerId = null; }, speeds: { slow: 600, fast: 200, // Default speed _default: 400 }, step: { opacity: function( fx ) { jQuery.style(fx.elem, \"opacity\", fx.now); }, _default: function( fx ) { if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) { fx.elem.style[ fx.prop ] = (fx.prop === \"width\" || fx.prop === \"height\" ? Math.max(0, fx.now) : fx.now) + fx.unit; } else { fx.elem[ fx.prop ] = fx.now; } } } }); if ( jQuery.expr && jQuery.expr.filters ) { jQuery.expr.filters.animated = function( elem ) { return jQuery.grep(jQuery.timers, function( fn ) { return elem === fn.elem; }).length; }; } function genFx( type, num ) { var obj = {}; jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice(0,num)), function() { obj[ this ] = type; }); return obj; } if ( \"getBoundingClientRect\" in document.documentElement ) { jQuery.fn.offset = function( options ) { var elem = this[0]; if ( options ) { return this.each(function( i ) { jQuery.offset.setOffset( this, options, i ); }); } if ( !elem || !elem.ownerDocument ) { return null; } if ( elem === elem.ownerDocument.body ) { return jQuery.offset.bodyOffset( elem ); } var box = elem.getBoundingClientRect(), doc = elem.ownerDocument, body = doc.body, docElem = doc.documentElement, clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0, top = box.top + (self.pageYOffset || jQuery.support.boxModel && docElem.scrollTop || body.scrollTop ) - clientTop, left = box.left + (self.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft) - clientLeft; return { top: top, left: left }; }; } else { jQuery.fn.offset = function( options ) { var elem = this[0]; if ( options ) { return this.each(function( i ) { jQuery.offset.setOffset( this, options, i ); }); } if ( !elem || !elem.ownerDocument ) { return null; } if ( elem === elem.ownerDocument.body ) { return jQuery.offset.bodyOffset( elem ); } jQuery.offset.initialize(); var offsetParent = elem.offsetParent, prevOffsetParent = elem, doc = elem.ownerDocument, computedStyle, docElem = doc.documentElement, body = doc.body, defaultView = doc.defaultView, prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle, top = elem.offsetTop, left = elem.offsetLeft; while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) { if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === \"fixed\" ) { break; } computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle; top -= elem.scrollTop; left -= elem.scrollLeft; if ( elem === offsetParent ) { top += elem.offsetTop; left += elem.offsetLeft; if ( jQuery.offset.doesNotAddBorder && !(jQuery.offset.doesAddBorderForTableAndCells && /^t(able|d|h)$/i.test(elem.nodeName)) ) { top += parseFloat( computedStyle.borderTopWidth ) || 0; left += parseFloat( computedStyle.borderLeftWidth ) || 0; } prevOffsetParent = offsetParent, offsetParent = elem.offsetParent; } if ( jQuery.offset.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== \"visible\" ) { top += parseFloat( computedStyle.borderTopWidth ) || 0; left += parseFloat( computedStyle.borderLeftWidth ) || 0; } prevComputedStyle = computedStyle; } if ( prevComputedStyle.position === \"relative\" || prevComputedStyle.position === \"static\" ) { top += body.offsetTop; left += body.offsetLeft; } if ( jQuery.offset.supportsFixedPosition && prevComputedStyle.position === \"fixed\" ) { top += Math.max( docElem.scrollTop, body.scrollTop ); left += Math.max( docElem.scrollLeft, body.scrollLeft ); } return { top: top, left: left }; }; } jQuery.offset = { initialize: function() { var body = document.body, container = document.createElement(\"div\"), innerDiv, checkDiv, table, td, bodyMarginTop = parseFloat( jQuery.curCSS(body, \"marginTop\", true) ) || 0, html = \"\"; jQuery.extend( container.style, { position: \"absolute\", top: 0, left: 0, margin: 0, border: 0, width: \"1px\", height: \"1px\", visibility: \"hidden\" } ); container.innerHTML = html; body.insertBefore( container, body.firstChild ); innerDiv = container.firstChild; checkDiv = innerDiv.firstChild; td = innerDiv.nextSibling.firstChild.firstChild; this.doesNotAddBorder = (checkDiv.offsetTop !== 5); this.doesAddBorderForTableAndCells = (td.offsetTop === 5); checkDiv.style.position = \"fixed\", checkDiv.style.top = \"20px\"; // safari subtracts parent border width here which is 5px this.supportsFixedPosition = (checkDiv.offsetTop === 20 || checkDiv.offsetTop === 15); checkDiv.style.position = checkDiv.style.top = \"\"; innerDiv.style.overflow = \"hidden\", innerDiv.style.position = \"relative\"; this.subtractsBorderForOverflowNotVisible = (checkDiv.offsetTop === -5); this.doesNotIncludeMarginInBodyOffset = (body.offsetTop !== bodyMarginTop); body.removeChild( container ); body = container = innerDiv = checkDiv = table = td = null; jQuery.offset.initialize = jQuery.noop; }, bodyOffset: function( body ) { var top = body.offsetTop, left = body.offsetLeft; jQuery.offset.initialize(); if ( jQuery.offset.doesNotIncludeMarginInBodyOffset ) { top += parseFloat( jQuery.curCSS(body, \"marginTop\", true) ) || 0; left += parseFloat( jQuery.curCSS(body, \"marginLeft\", true) ) || 0; } return { top: top, left: left }; }, setOffset: function( elem, options, i ) { // set position first, in-case top/left are set even on static elem if ( /static/.test( jQuery.curCSS( elem, \"position\" ) ) ) { elem.style.position = \"relative\"; } var curElem = jQuery( elem ), curOffset = curElem.offset(), curTop = parseInt( jQuery.curCSS( elem, \"top\", true ), 10 ) || 0, curLeft = parseInt( jQuery.curCSS( elem, \"left\", true ), 10 ) || 0; if ( jQuery.isFunction( options ) ) { options = options.call( elem, i, curOffset ); } var props = { top: (options.top - curOffset.top) + curTop, left: (options.left - curOffset.left) + curLeft }; if ( \"using\" in options ) { options.using.call( elem, props ); } else { curElem.css( props ); } } }; jQuery.fn.extend({ position: function() { if ( !this[0] ) { return null; } var elem = this[0], // Get *real* offsetParent offsetParent = this.offsetParent(), // Get correct offsets offset = this.offset(), parentOffset = /^body|html$/i.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset(); // Subtract element margins // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat( jQuery.curCSS(elem, \"marginTop\", true) ) || 0; offset.left -= parseFloat( jQuery.curCSS(elem, \"marginLeft\", true) ) || 0; // Add offsetParent borders parentOffset.top += parseFloat( jQuery.curCSS(offsetParent[0], \"borderTopWidth\", true) ) || 0; parentOffset.left += parseFloat( jQuery.curCSS(offsetParent[0], \"borderLeftWidth\", true) ) || 0; // Subtract the two offsets return { top: offset.top - parentOffset.top, left: offset.left - parentOffset.left }; }, offsetParent: function() { return this.map(function() { var offsetParent = this.offsetParent || document.body; while ( offsetParent && (!/^body|html$/i.test(offsetParent.nodeName) && jQuery.css(offsetParent, \"position\") === \"static\") ) { offsetParent = offsetParent.offsetParent; } return offsetParent; }); } }); // Create scrollLeft and scrollTop methods jQuery.each( [\"Left\", \"Top\"], function( i, name ) { var method = \"scroll\" + name; jQuery.fn[ method ] = function(val) { var elem = this[0], win; if ( !elem ) { return null; } if ( val !== undefined ) { // Set the scroll offset return this.each(function() { win = getWindow( this ); if ( win ) { win.scrollTo( !i ? val : jQuery(win).scrollLeft(), i ? val : jQuery(win).scrollTop() ); } else { this[ method ] = val; } }); } else { win = getWindow( elem ); // Return the scroll offset return win ? (\"pageXOffset\" in win) ? win[ i ? \"pageYOffset\" : \"pageXOffset\" ] : jQuery.support.boxModel && win.document.documentElement[ method ] || win.document.body[ method ] : elem[ method ]; } }; }); function getWindow( elem ) { return (\"scrollTo\" in elem && elem.document) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false; } // Create innerHeight, innerWidth, outerHeight and outerWidth methods jQuery.each([ \"Height\", \"Width\" ], function( i, name ) { var type = name.toLowerCase(); // innerHeight and innerWidth jQuery.fn[\"inner\" + name] = function() { return this[0] ? jQuery.css( this[0], type, false, \"padding\" ) : null; }; // outerHeight and outerWidth jQuery.fn[\"outer\" + name] = function( margin ) { return this[0] ? jQuery.css( this[0], type, false, margin ? \"margin\" : \"border\" ) : null; }; jQuery.fn[ type ] = function( size ) { // Get window width or height var elem = this[0]; if ( !elem ) { return size == null ? null : this; } if ( jQuery.isFunction( size ) ) { return this.each(function( i ) { var self = jQuery( this ); self[ type ]( size.call( this, i, self[ type ]() ) ); }); } return (\"scrollTo\" in elem && elem.document) ? // does it walk and quack like a window? // Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode elem.document.compatMode === \"CSS1Compat\" && elem.document.documentElement[ \"client\" + name ] || elem.document.body[ \"client\" + name ] : // Get document width or height (elem.nodeType === 9) ? // is it a document // Either scroll[Width/Height] or offset[Width/Height], whichever is greater Math.max( elem.documentElement[\"client\" + name], elem.body[\"scroll\" + name], elem.documentElement[\"scroll\" + name], elem.body[\"offset\" + name], elem.documentElement[\"offset\" + name] ) : // Get or set width or height on the element size === undefined ? // Get width or height on the element jQuery.css( elem, type ) : // Set the width or height on the element (default to pixels if value is unitless) this.css( type, typeof size === \"string\" ? size : size + \"px\" ); }; }); // Expose jQuery to the global object window.jQuery = window.$ = jQuery; })(window);"}],"posts":[{"title":"16年5月读书两本（《硅谷钢铁侠》，《偷影子的人》）","slug":"Reading-for-May-2016","date":"2016-06-24T14:29:37.000Z","updated":"2016-06-25T15:14:03.000Z","comments":true,"path":"/blog/2016/06/24/Reading-for-May-2016/","link":"","permalink":"http://zhenby.com/blog/2016/06/24/Reading-for-May-2016/","excerpt":"","text":"《硅谷钢铁侠》★★★★★ 马斯克用工程师的思维考虑一个事的可行性，并且又具备商业嗅觉可以发现这个事的商业模式，从而达到可持续发展，从 SpaceX 发射成本的降低，到特斯拉充电站网络的建立，还有太阳城租赁太阳能板的业务模式，这些都说明了，马斯克虽然目标远大，但他不是空谈者，他是伟大的实干家。 《偷影子的人》★★★★☆ 一定有什么东西是你热爱并且最喜欢去做的，一个未完成的梦想？","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"16年4月读书一本（《白鹿原》）","slug":"Reading-for-April-2016","date":"2016-05-21T06:51:52.000Z","updated":"2016-06-12T13:51:14.000Z","comments":true,"path":"/blog/2016/05/21/Reading-for-April-2016/","link":"","permalink":"http://zhenby.com/blog/2016/05/21/Reading-for-April-2016/","excerpt":"","text":"《白鹿原》★★★★★ 非常厚重的一本小说。 里面有陕西关中地区淳朴的风土人情，也有大胆的性爱描述； 里面有传统的族长文化，也有被新思想点燃的白灵； 里面有古老村庄的曲折前进，也有从辛亥革命到新中国成立三十多年的国共起伏史。","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"FBRetainCycleDetector解析——获取一般对象的Strong成员变量","slug":"FBRetainCycleDetector-Learning-1","date":"2016-04-29T06:29:25.000Z","updated":"2016-06-24T17:55:05.000Z","comments":true,"path":"/blog/2016/04/29/FBRetainCycleDetector-Learning-1/","link":"","permalink":"http://zhenby.com/blog/2016/04/29/FBRetainCycleDetector-Learning-1/","excerpt":"","text":"Facebook 前不久发布三个工具用于检测内存泄露，分别是 FBRetainCycleDetector、FBAllocationTracker 及 FBMemoryProfiler，并在他们的技术博客上发布了一篇相关的博客 Automatic memory leak detection on iOS。 看了一下 FBRetainCycleDetector 的代码，通过 Runtime 捕获循环引用，原理在 Automatic memory leak detection on iOS 这篇博客中有说到：把对象（包括 Block 对象）当成节点，以强引用为关系建立有向图，以深度优先遍历该有向图，寻找有向图中的环，一个环就代表一个循环引用。 本篇博客介绍 FBRetainCycleDetector 库中获取一般对象的 Strong 成员变量的原理。 Runtime 中的相关函数先介绍一下 Runtime 中的几个函数： Class object_getClass(id obj)：获取一个对象所属的类； Class class_getSuperclass(Class cls)：获取一个类的父类； Ivar *class_copyIvarList(Class cls, unsigned int *outCount)：获取某个类中的成员变量个数及成员变量数组，但是不包含父类的； ptrdiff_t ivar_getOffset(Ivar v)：获取成员变量中的偏移位置，关于成员变量偏移位置的解析，可以看这篇博客Objective-C类成员变量深度剖析； const uint8_t *class_getIvarLayout(Class cls)：获取某个类中 Strong 类型的成员变量的布局，关于 Ivar Layout 下面会展开说明一下。 Ivar Layoutconst uint8_t *class_getIvarLayout(Class cls) 函数中有一个 Ivar Layout 的概念，表示成员变量的布局情况。 相对于 Strong 类型的成员变量，函数 const uint8_t *class_getWeakIvarLayout(Class cls) 可以获取 Weak 类型的成员变量的布局情况。 例子如下： @interface ClassA : NSObject&#123; __unsafe_unretained id ivar0; __weak id ivar1; __strong id ivar2; __weak id ivar3; __strong id ivar4; __strong id ivar5;&#125;@end const uint8_t *class_getIvarLayout(Class cls) 函数获取到的是一个 uint8_t 的数组，一个 uint8_t 在 16 进制下是两位，所以编码的值每两位一对。这两位中，前面一位表示有多少个非 Strong 类型的成员变量，后面一位表示接下来有多少个 Strong 类型的成员变量，而这个顺序是根据成员变量声明的顺序决定的，此顺序也跟函数 Ivar *class_copyIvarList(Class cls, unsigned int *outCount) 获取到的一致。 在这个例子中，ClassA 类的 IvarLayout 的值为 0x211200： 0x211200 中的 21 中的 2 就代表一开始有两个非 Strong 类型的成员变量（ivar0 及 ivar1），其中的 1 则代表接下来有一个 Strong 类型的成员变量（ivar2）； 接下来的 12 中的 1 代表接下来有一个 非 Strong 类型的成员变量（ivar3），其中的 2 则代表接下来有两个 Strong 类型的成员变量（ivar4 及 ivar5）； 最后的 00 为结束符。 同理我们可以推测出 ClassA 类的 WeakIvarLayout 的值为：0x111100。 本段参考资料：Objective-C Class Ivar Layout 探索 代码基于上面介绍的几个函数，串连起来就可以实现获取一般对象的强引用对象的功能了，代码如下： - (NSArray&lt;NSValue *&gt; *)strongIvarsWithObject:(id)object&#123; NSMutableArray&lt;NSValue *&gt; *strongIvars = [NSMutableArray new]; __unsafe_unretained Class previousClass = nil; __unsafe_unretained Class currentClass = object_getClass(object); // 往上一直获取父类，直到 NSObject while (previousClass != currentClass) &#123; // 获取当前类的 Strong 成员变量布局 const uint8_t * ivarLayout = class_getIvarLayout(currentClass); if (ivarLayout) &#123; // 找出 Strong 成员变量的位置 NSMutableIndexSet *interestingIndexes = [NSMutableIndexSet new]; NSUInteger index = 0; while ((*ivarLayout) != '\\x00') &#123; // 获取高位（高位表示非 Strong 成员变量的个数）及低位（低位表示 Strong 成员变量的个数） int upperNibble = (*ivarLayout &amp; 0xf0) &gt;&gt; 4; int lowerNibble = *ivarLayout &amp; 0xf; // 跳过非 Strong 成员变量的个数 index += upperNibble; // 保存本次 Strong 成员变量的位置 [interestingIndexes addIndexesInRange:NSMakeRange(index, lowerNibble)]; index += lowerNibble; ++ivarLayout; &#125; // 获取当前类的成员变量数组 unsigned int ivarCount; Ivar *ivars = class_copyIvarList(currentClass, (&amp;ivarCount)); // 遍历本类中的所有成员变量，保存位置在 interestingIndexes 中的成员变量 for (NSUInteger i = 0; i &lt; ivarCount; ++i) &#123; if ([interestingIndexes containsIndex:i]) &#123; Ivar ivar = ivars[i]; // 此处为简单化，直接把 Ivar 数据结构 NSValue 化，也可以创建一个表示 Ivar 的类 NSValue *ivarValue = [NSValue value:&amp;ivar withObjCType:@encode(Ivar)]; [strongIvars addObject:ivarValue]; &#125; &#125; &#125; previousClass = currentClass; currentClass = class_getSuperclass(currentClass); &#125; return [strongIvars copy];&#125; 我写的这个方法做了一些简化，完整的代码在 FBClassStrongLayout.m 中，感兴趣的可以看看。 下篇博客再介绍一下获取 Block 对象的强引用对象的原理。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://zhenby.com/categories/编程技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"},{"name":"学习开源库","slug":"学习开源库","permalink":"http://zhenby.com/tags/学习开源库/"}]},{"title":"16年3月读书一本（《把时间当作朋友》）","slug":"Reading-for-March-2016","date":"2016-04-19T02:59:14.000Z","updated":"2016-06-10T12:36:20.000Z","comments":true,"path":"/blog/2016/04/19/Reading-for-March-2016/","link":"","permalink":"http://zhenby.com/blog/2016/04/19/Reading-for-March-2016/","excerpt":"","text":"《把时间当作朋友》★★★★☆ 我们听过无数的道理，却仍旧过不好这一生。 ——电影《后会无期》 我在看这本书的时候，脑海中常常想起这句台词，这本书里面讲了很多我们本来就懂的道理，比如坚持不停的学习就能有所成就；改变你的态度，你就会发现你的世界会因此发生转变。道理很多人都懂，但是能坚持做到的却是少数。我其中三点的收获如下： 开启心智开启心智的过程，我的理解就是把自己抽离出来，飞到空中，以上帝视角理性的看待审视你自己所做的事情，从这个角度俯视看，你能看到自己很多的问题，比如： 这一天的工作/学习效率如何？都浪费了多少时间？ 哪些原因导致了时间的浪费？大脑活跃导致的注意力不集中？希望自己的欲望马上能获得满足？ 做这件进度已经 5% 的事情为什么今天会放弃了？是因为回避困难？ …… 当从这样的角度来思考自己一天的行为时，会发现在整个思考过程中，可以做到忽略了自己情绪的影响，忽略了我们人天性里面的很多缺点，而很理性的看待问题，改进，从而变成大脑的主人。 了解学习的过程学习的时候，进展和时间之间的关系可以肯定不是线性的，有的时候，这两者的恭喜是一个先缓慢上升，再高速上升，然后再变成缓慢上升的曲线；有时候，则是一个先缓慢上升，再缓慢下降，再高速上升的曲线…… 你看到了，在任何一个阶段，总是有一段时间进展缓慢，许久过后，所谓量变到质变的效果才会出现，才可能有突飞猛进的感觉。可是人们往往在行进一小段时间之后，就因为觉得进展“过分”缓慢而产生动摇。所以，从来都没有体会过突飞猛进的感觉。然而这样慢慢动摇直至最终放弃的人，在漫长的一生中总是会遇到身边的某些人在“突飞猛进”——于是，在不愿意承认自己曾经的错误的情况下，当然貌似“最合理”的解释就是“呀，他肯定有什么诀窍！”当然，更多的时候，那个曲线应该是一个螺旋上升的曲线。打个比方，就有点儿像华尔兹那样，先进两步再退一步。 如果，你把时间和进展之间的关系仅仅理解为纯粹的线性关系，那你最终根本不可能遇到你所满意的进展。其实，没有哪个人可以长时间忍受失望。这样看来，你曾经的放弃，往往并不是因为你没有毅力， 而只是对时间和进展之间的关系理解错误造成的——在频繁发生失望甚至绝望的情况下你居然坚持了那么久，你其实是多么的有毅力啊！ 人都能力有限，他们光彩，只因准备三四年前，我在 UC 的时候，参加一次训练营的活动，活动上的导师是当时 UC 的总裁俞永福，有一个同事问了他一个问题：「为什么问你的很多问题，你都能很快，并且很好的回答？有什么秘诀吗？」，俞永福回答说：「其实问我的很多问题，以前就有人问过我很多次了，或者那个问题我已经在脑海中思考过很久了，所以我才能很快的回答。所以没什么秘诀，只是因为有提前的准备。」（只能记清大意）。哦，原来就是这么简单啊，并没有什么高大上的秘诀，他们的光彩，背后都是因为花了长时间的准备。 之所以可以“显得”游刃有余，是因为之前做过太多的准备。之所以做那么多的准备，就是因为曾经出过丑——想象一下，在台上突然发现自己说的某句话竟然有不曾想到过的歧义，是多么窘迫的事情？所以，在准备任何一个讲演的时候，我都花费很多的时间认真考虑自己的每个观点，每个事例，甚至每个句子可能引发什么样的理解和反应，然后逐一制定相应对策，才可以心安理得地上台讲演。 看完我这篇读后感的你，我说的这些道理，能让你过好这一生吗？","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"16年2月读书两本（《创业维艰》《东方快车谋杀案》）","slug":"Reading-for-February-2016","date":"2016-03-10T15:44:32.000Z","updated":"2016-06-25T15:13:49.000Z","comments":true,"path":"/blog/2016/03/10/Reading-for-February-2016/","link":"","permalink":"http://zhenby.com/blog/2016/03/10/Reading-for-February-2016/","excerpt":"","text":"《创业维艰》★★★★☆ 不错的书，虽然题目是创业相关的，但是里面的很多方法无论在大公司，还是小公司，都是通用的。 印象最深刻的是关于一对一面谈的，在看这本书之前，我跟组员面谈时都比较发散，并且对于一些话比较少的人，缺乏科学的引导，最后都变成了大部分时间都是我在说。作者在书里面总结了一对一面谈的一些要点跟方法，可操作性很强。 一定要明白一点：这是以员工为中心的会谈，不是以上司为中心。它不拘于形式，目的是解决迫在眉睫的问题、交流精彩绝伦的想法，或者倾诉郁结已久的焦虑。这些话题往往不适合通过工作报告、电子邮件或者其他非私人话的途经开展。 会谈时，上司要少说多听。现在，好多公司的「一对一面谈」往往上司说得多，听得少，刚好颠倒了。 有必要引导员工表达他的核心观点。这一点在面对性格内向的员工时显得尤为重要。 以下是有助于引导对方表达想法的一些话题： 如果我们还有进步的空间，那你认为该从哪方面着手？ 你所在部门的最大问题是什么？为什么？ 在这里的工作中，哪一点令你感到不愉快？ 公司里谁最优秀？你最佩服谁？ 假如你是我，你会做何调整？ 你这个产品的哪个方面不尽如人意？ 你觉得我们错失的最大机遇是什么？ 哪些是我们该做而没有做的？ 你对这里的工作满意吗？ 下面是我的读书笔记： 在团队面前，报喜不报忧，是很蠢的，团队里面的人很清楚现实并没有你描述的那么美好，负面影响也可以激励人。 不要以为你是唯一一个可以为公司解决问题的，所以把所有的问题都揽在自己身上，把问题分配出去，交给有能力，有兴趣，有动力的人去解决，这样才能解决的好。 裁员的时候承认失败，而不是把问题推给员工。承认失败很了不起：「公司经营不善，为了继续发展，我们不得不忍痛辞掉一些优秀的员工」。走的人固然要聊，但是留下的人还要安抚，CEO 必须为管理者们解释裁员的合理性，向全公司通报总体情况。 关于培训员工，大多数管理者似乎都觉得，培训员工这件事应该让其他人来做，但我却坚信，管理者应该亲自来做这件事，这样才能把你的期望，为什么有这样的期望传递下去。有些人觉的实施培训项目会花费太多时间，你要记住，在提升公司生产力方面，其他任何的投入都比不上培训。因此，因为太忙而没时间开展培训就相当于因为太饿而吃不下任何东西。 看清了雇佣出色员工和背叛珍贵友谊之间的矛盾之后，你就应该将事情公开，告诉员工，你和他现在所属的公司有重要的生意往来，在录用他之前，你必须和他所在公司的 CEO 进行沟通，对他进行背景核查。告诉他，如果他不同意，你会立即中止录用，并对此保密。在录用之前，要和朋友进行交谈，这样才能更好地判断录用他的员工对你们的关系所带来的影响。此外，你还有可能避免用人不当，因为往往有些应聘者在面试中表现极佳，但进入公司之后，表现却不尽如人意。 大公司的主管不一定适合小公司，大公司中的主管，大部分是等事情来，需要他去决策，自然会找到他办公室；而小公司的主管，更多的会主动参与到各个环节中。 管理债务：一山不能容二虎；因某一员工得到了另一工作机会而对其补偿过度；缺乏绩效管理机制或员工反馈机制。这些都是满足短期利益，但是不符合长期利益的。 如果面临两种选择：其一，给每个人发同样的奖金，不犯众怒；其二，极力褒奖业绩突出的员工，惹恼其他员工。有经验的管理者会选择后者。如果面临另外两个选择：其一，撤掉今天一个很受欢迎的项目，因为该项目不在长期计划之内；其二，出于维护人心的目的或为了显得前后一致而保留该项目。有经验的管理者也会选择前者。为什么呢？因为他们曾经为管理债务付出过代价，所以不愿再重蹈覆辙。而好好人管理者会选择后者，不要做好好人管理者。 在面试候选者时，你可以留意他们在这方面的一些微小差别，看看他们在考虑问题时究竟是以“我”为出发点，还是以“团队”为出发点。 劳伦斯·J·彼得博士和雷蒙德·赫尔在 1969 年出版的同名书籍中首次使用了“彼得定律”这个术语，意即在一个集团中，员工只要表现出众，就能获得提拔，直至被提拔到一个他不能胜任的岗位（即他们的不称职级别），自此无法再获得提升。安迪·格鲁夫在其管理学经典《格鲁夫给经理人的第一课》中指出，“彼得定律”不可规避，因为我们无从预知某个人的能力会在权利阶梯的哪一层止步。 “坏榜样法则”：一个团队内部无论哪个层面出现了滥竽充数的人，他们都会像蛀虫一样影响其他成员，最终使得能力出众的人也渐趋平庸。这条法则的原理就是：员工会拿他们上级中能力最差的那个人做参照物。举个例子，如果贾斯珀是几个副总裁中最平庸的一个，那么所有的部门主管都会以他为标准，提出升职的要求。 《东方快车谋杀案》★★★☆☆ 信息量太多，我是过年期间碎片时间看完的，导致代入感比较少，结局奇妙，但是没特别震撼。","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"16年1月读书两本（《彷徨之刃》《岛上书店》）","slug":"Reading-for-January-2016","date":"2016-02-23T05:42:00.000Z","updated":"2016-06-10T12:35:34.000Z","comments":true,"path":"/blog/2016/02/23/Reading-for-January-2016/","link":"","permalink":"http://zhenby.com/blog/2016/02/23/Reading-for-January-2016/","excerpt":"","text":"《彷徨之刃》★★★★☆ 一个未成年人犯罪，而因为日本司法制度对于未成年人犯罪的宽容，受害者的父亲选择自己制裁凶手的故事。 对待未成年人的犯罪，日本司法制度上异常宽容：不会被公布姓名，刑期很短，案子也不会被公开审理。这是从凶手的角度上去考虑，考虑到他们心智还不成熟，给他们较轻的处罚，从而让他们在接下来漫长的人生历程中有机会改正，重新做一个对社会有用的人。而从受害者的角度考虑，很明显，凶手是没得到应有的惩罚的。而社会背景则是大部分人，对案子无动于衷，顶多是可怜一下受害者；媒体为了博眼球，大势宣传，消费这个悲惨故事；邻居把这个故事作为茶余饭后八卦的话题；只有受害者，忍受着失去女儿的痛苦。 查了一下相关的资料：川崎市國中一年級學生被殺，修改《少年法》呼聲再度高漲，日本到现在还是是有发生类似的事件，每次发生这样的事件，修改《少年法》的呼声就会出现。法律的条文也在不断的修正，现在的法律制度不是完全公正正义的。所谓的真正公正正义到底是什么？世界都在寻找答案。 《岛上书店》★★★★☆","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"15年12月读书两本（《追风筝的人》《人类简史-从动物到上帝》）","slug":"-Reading-for-December-2015","date":"2016-01-23T12:21:00.000Z","updated":"2016-06-24T17:48:54.000Z","comments":true,"path":"/blog/2016/01/23/-Reading-for-December-2015/","link":"","permalink":"http://zhenby.com/blog/2016/01/23/-Reading-for-December-2015/","excerpt":"","text":"《追风筝的人》★★★★★ 这是一本关于友谊、等级、救赎及战争的故事。 关于战争，阿米尔跟他爸之前平静的生活，被战争彻底改变，远离家乡，融入美国，而家乡已经变成一片废墟，生灵涂炭，让人不寒而栗。而现在 ISIS 在中东造成的破坏，不比那时的塔利班轻，这些以宗教的名义，迫害普通老百姓的行径真让人不齿。人民无力改变，感到绝望，更可怕的是，小孩从小在这样的环境下长大，接受极端思想的教育，对世界充满仇恨，这些现在是 ISIS 统治地区人民的日常，想想都觉的很可怕。 《人类简史-从动物到上帝》★★★★★ 这本书讲述了：把时间跨度拉长，看人类是怎么从猿人，到智人，再经历认知革命，农业革命，科学革命走到今天统治世界的地位的。在讲述的过程中，有很多有意思的观点： 智人这一分支打败其他分支的人种，开始统治世界。而让智人脱颖而出的是语言及想象力。人类语言比其他动物的语言更丰富更多样，也有说因为智人要交流八卦，所以需要很多语言上的交流，从而让他们脱颖而出；而想象力则是智人特有的，通过想象出一些现实世界中不存在的东西，并且还能让别人相信，从而有共同的立场，这就是宗教、国家、公司的前身。 智人所到之处，当地的很多物种就开始灭亡，特别是大型动物，作者没有一口咬定就是智人导致了这些物种的灭亡，但是通过对比智人到达一个地方的时间以及该地方的大型动物开始灭亡的时间来看，基本可以确定跟智人是有很大关系的。智人每去到一个地方，会对当地的资源进行采集，一开始当地物种觉得智人根本没什么威胁，而事实上智人的智力已经甩它们几条街了，可以通过火、团队作战、陷阱等方式轻松打猎。而等到这些物种身上将要进化出怕智人的基因时，它们已经灭绝。 人类在农业革命后，陷入了虚荣陷阱，以为会过得越来越轻松，事实上，人类在农业革命后过的比农业革命前还惨，因为安定聚集起来了，人口上去了，一旦粮食欠收就会导致饥饿，人群聚集使传染病更容易传播，农活也限制了人类的活动范围。 书中说了另一种农业革命发生的可能：因为宗教的原因，需要在某个圣地建宏伟的建筑，从而需要做大量的集中体力活，导致人类聚集，然后驯化了小麦，人类也因为虔诚而聚集在宗教点附近。 从动植物的角度看农业革命，就很惨了，羊牛鸡鸭命运都很曲折，有得要一直怀孕挤奶，有得刚生出来不久就要被杀做成食物，有得要一直做苦力活。 讲到不公平产生的原因，是因为历史偶然事件的发生，让白人，雅利安人占据了领导地位。而为了巩固他们的统治，握有权利的他们，可以结合社会各方面（宗教、身体结构、智力等）对黑人，印度人产生歧视，从而让他们自己的地位高人一等，让黑人，印度人地位低的可怜。一旦社会地位低，向上的机会就会减少，而社会又会拿「黑人、印度人很少从事某个职位」这种观点来证明他们是低人一级的，这是一个恶性循环。 什么行为是自然的，什么行为是不自然的？在人类的大部分阶段，异性之间的性行为是自然的，同性之间的性行为是不自然的，这个自然与不自然的划分，是文化造成的，「天生带来允许，文化造成封闭」。人类的一些器官如果都按「自然」的方式使用，那亲吻也是不自然的，因为嘴巴生来是吃东西的。 科学革命，1860 年代的世界，西方已因为科学革命上升了一个维度，打中国绰绰有余。而科学革命的前提，是承认自己的无知，放下身段，才能去探索。资本主义与科学是现代社会的基石。","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"15年11月读书三本（《天才在左，疯子在右》《秘密》《蒋介石传》）","slug":"-Reading-for-November-2015","date":"2015-12-12T04:20:00.000Z","updated":"2016-06-25T15:25:14.000Z","comments":true,"path":"/blog/2015/12/12/-Reading-for-November-2015/","link":"","permalink":"http://zhenby.com/blog/2015/12/12/-Reading-for-November-2015/","excerpt":"","text":"《天才在左，疯子在右》★★★☆☆ 这书一直躺在我的书单里，上次同事极力推荐，就买了电子书看。一开始看挺震撼的，一群在我们世俗眼光下不正常的人，一个个却都有一些很特别的世界观，让你换个角度去看世界，觉的一切很新鲜。 里面有各种大开脑洞的想法，有觉得石头是一种生命，观察石头很久不动是因为我们的时间对于石头来说只是很少的瞬间；蚂蚁群是生命，蚂蚁只是细胞；里面住着三个多重人格的人，三个人格被杀剩一个；觉得自己是一本小说主角，你只是他小说中的一个人物的男人；与四维生物交流，我们在四维生物眼中都是一条虫子，时间是虫子的长度，从一个时间点开始，从另一个时间点结束，就是虫子；还有对宗教虔诚到极点，到走火入魔，变成信仰魔鬼，从而衬托出神的伟大的男人。 最喜欢的一节是说玛雅文明的，探索一种未知文字可先从数字入手，看哪些字是表达一、二、三这些数字的，然后再看数字前后跟的名词，然后再推测。而玛雅文明的特点是文字描述很简单，重视祭祀，现实中没有车轮，却有车轮祭品，对天文很在行。作者推断玛雅文明之前是有一个上层文明的，可能来至宇宙，这样部分疑惑就比较容易解释了。 本来觉的这书挺不错的，但是读到最后，竟然看到「这里有近 20 余篇是真实案例；也有些是出于一些原因，我基于真实案例在内容赏做了增添或者删减」，我感觉被欺骗了，这本书的副标题明明叫：国内第一本精神病人访谈手记。 《秘密》★★★★★ 很好的一本小说，结尾很震惊。东野圭吾的小说一旦开始读，总是放不下手。 车祸，母亲死了，女儿重伤，最后发现母亲的灵魂交换到女儿身上，父亲开始与女儿身，妈妈魂的一个人相依为命；想象这情景套到自己身上，也是非常棘手。一老一少，生活还得继续，老的要上班，少的要上学，老的生活枯燥乏味，少的生活多姿多彩。老的终究要被青春抛弃。 《蒋介石传》 ★★★☆☆ 书一般，基本是一本蒋的大事记。 我们用现在的眼光去看历史，总是马后炮的说：这选择是错的，应该这样这样做，仿佛按照我们的想法做，历史就能按照我们预想的发展。我在看这书的时候就多次有这样的想法，比如九一八时蒋介石让张学良不抵抗，再比如西安事变后，张学良被软禁，而国共内战期间，蒋介石不愿意把张学良放回东北战场… 我们无法亲身体会的感受到人物当时面临的众多选择，更多的是应该理解人物当时的选择。","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"BLink V1.5 兼容iOS 7了","slug":"blink-support-ios-7-now","date":"2013-10-10T09:25:00.000Z","updated":"2016-06-24T17:53:23.000Z","comments":true,"path":"/blog/2013/10/10/blink-support-ios-7-now/","link":"","permalink":"http://zhenby.com/blog/2013/10/10/blink-support-ios-7-now/","excerpt":"","text":"之前为什么不兼容 iOS 7我在上一篇博客第一个收费应用-BLink中提到过，BLink 不兼容 iOS 7 是因为 iOS 7 的 bug，那时候因为 iOS 7 还在测试阶段，因为 NDA 的原因，我没细说那个 bug： 在 iOS 7 中，在 Web App 的全屏模式下（standlone），所有会离开当前浏览会话的 JS 执行都无效。比如，在全屏模式下，执行一个 JS 的 alert 语句无效，使用 JS 打开一个应用的 URL Scheme 也会无效。 因为 BLink 的快捷方式实际上就是一个桌面书签，会通过是否全屏模式做不同的操作：非全屏模式下，提示用户添加书签到桌面上；全屏模式下，直接打开一个 URL Scheme。因为 iOS 7 的这个 bug，在全屏模式下打开一个应用的 URL Scheme 无效了，所以 BLink 在 iOS 7 下的快捷方式打开后只会是一个白屏。 别对苹果修 bug 抱太大希望，要有 Plan B这个 bug 从 iOS 7 测试版本就一直存在，具体从 beta 几开始我没测试，我从 iOS 7 beta 4 开始试用 iOS 7，就发现了这个 bug，我一直认为现在是 iOS 7 的测试版本，有 bug 很正常，看到苹果开发者论坛上也有人已经报 bug 给苹果了，所以我是幻想着苹果能在 iOS 7 正式版本之前解决这个 bug 的。但是到了 beta 6，再到9月10号苹果发布会后发布的 GM版，这个 bug 还是一直存在。我这个时候还是幻想着苹果能在正式版的时候解决这个 bug，毕竟这是个大问题阿，所有全屏 Web App 都会受影响，连 alert 都 alert 不了。所以在这段 iOS 7 测试版本期间，我没有做任何的行动，也没想好一直幻想着正式版本能正常工作。但是在9月18号的时候，iOS 7 正式版发布，我测试后，问题依旧阿。我X，而且发现正式版根本就是 GM 版，一个星期一个问题都没解决阿，顿时对苹果失望至极。 因为之前对苹果修 bug 抱太大希望，我根本没考虑 Plan B，所以正式版发布后，一天几个一星差评，几封反馈的邮件。这是教训阿，以后对这种大版本的更新，在最后的 GM 版本，如果还有问题，就应该尽快想 Plan B，并尽快上线新版本，并且，再加根据系统版本的远程开关，这样即使正式版本修复了，也可以远程控制是否启用 Plan B。 怎么解决的解决的过程比较曲折，我尝试了使用 Local Storage 以及 Web SQL Database 来保存「是否将快捷方式添加到桌面」的标识，由于我的快捷方式的书签地址为 data:text/html 类型的，都无法使用 Local Storeage 及 Web SQL Database。一开始一筹莫展，想不到好的办法解决，最后参考了一个同类型的 App，他们是使用安装「描述文件」的方式来生成桌面快捷方式。这种方式我一开始是抗拒的，因为用户不了解什么是描述文件，也不确定安装完后会不会对设备造成其他影响，而且由于我没买电子签名证书，所以我生成的描述文件在设备上安装时，会显示「未签名」的，这也会让用户疑惑。但是实在找不到其他的解决办法，最后只能在安装过程中提示用户「安装此描述文件只会在你的设备主屏幕上添加一个快捷方式，不会修改你设备上的任何设置，所以无需担心描述文件未签名的问题。」 然后，解决了这个问题后，我又发现了一个 bug，在 iOS 7 中，从原生的应用中尝试打开电话的 URL Scheme 时，会卡个10秒，拨号的界面才会出现，电话已经拨通了，但是界面却一直卡在打开的原生应用中。这是恶心的问题阿，最后只能直接通过 Safari 打开电话的 URL Scheme，这就导致了每次都会出现一个确认框，用户体验又下降一大截了。 所以在 iOS 7 中，现在的 BLink 只能算个半成品，只是达到勉强可用的状态，希望苹果尽快发布新的 iOS 7 版本，可能修复这些 bug。 感受这件事后，我思考了一下，为什么 BLink 会遇到这样的窘境，我发现是因为 BLink 太依赖 iOS 中原生的其他应用了，整个应用流程不能在 BLink 里面单独完成，在 BLink 中完成一部分操作，跳出 BLink，再在其他地方完成另一部分操作。而依赖越多，那么限制也会越多，毕竟依赖的这部分你是无法控制的。所以我的下个应用，我希望能做一个独立的，拥有完整用户体验的一个应用。","categories":[{"name":"作品","slug":"作品","permalink":"http://zhenby.com/categories/作品/"}],"tags":[{"name":"我的应用","slug":"我的应用","permalink":"http://zhenby.com/tags/我的应用/"},{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"},{"name":"BLink","slug":"BLink","permalink":"http://zhenby.com/tags/BLink/"}]},{"title":"第一个收费App——BLink","slug":"blink","date":"2013-09-12T12:24:00.000Z","updated":"2016-06-24T17:53:35.000Z","comments":true,"path":"/blog/2013/09/12/blink/","link":"","permalink":"http://zhenby.com/blog/2013/09/12/blink/","excerpt":"","text":"最近新上架了第一个收费作品：BLink 做什么的这是一个用来创建联系人快捷方式的 App，用户可以用照片，或者内置的头像在桌面上创建一个用于打电话、发短信、发邮件的快捷图标。 原理很简单如果大家用过 BLink 的话，就会知道它的工作原理还是很简单的，生成图标必须依靠 Safari，所以每个快捷方式其实就是一个 Web Clip，判断到是全屏启动的，则直接跳转到一个 URL Scheme。 限免由于是第一个收费作品，所以没经验，早上六点多审核通过上线的，中午十二点我就把他设置成限免了，后来 bang 提醒我，设置的太快了，收费的时间太短，这样限免的网站爬不到价格变化，就不会推荐了。 果然，我搜了又搜，限免网站上都找不到推荐，只能自己在爱应用上自推了一下，编辑觉的不错，就推荐了。其他中文网站看到后，也做了不少推荐，所以量还不错。但是都是大中华地区的，我本来定位的主要付费市场是在欧美的，由于限免时机设置的不好，欧美的量少的可怜。 所以第一次上线的时候，可以收费几天，然后再设置限免，这样限免的效果比较好。如果本来已经有收费版本上线了，只是更新版本而已，那审核通过后，可以马上设置成限免。 收费后，BLink 最高的时候冲到了中国区付费总榜单的第30名左右。第二天出销售报告的时候才知道，付费总榜单第30名的钱也没多少钱，单靠这点钱，那些主要市场在中国区的付费应用的公司真没法活。 问题不兼容 iOS 7由于 iOS 7 当前的测试版本有 bug，BLink 创建的快捷方式在 iOS 7 上打开后，一片空白，不能打电话，也不能调出发信息、发邮件的界面。因为这个 bug，中国区的用户有几个上来就直接给一星，写说不能兼容 iOS 7，中国区的用户就喜欢尝鲜啊。对于这个 bug，我试了几种办法，都不能规避它，只能让苹果解决了，已经有国外开发者把这个 bug 提交给苹果了(Apple Developer 论坛对此 bug 的讨论)，但是在苹果发布会上发布的 iOS 7 GM 版本上，此 bug 依然存在。希望18号发布的 iOS 7 正式版能解决此问题。 快捷方式启动慢这个问题我只能尽量的优化，因为是使用 Web Clip 作为快捷方式的，所以快捷方式启动的快慢主要取决于 Web Clip 的加载速度，其他耗时的过程，包括从 Safari 切换到具体应用，具体应用的打开，我不能干预。所以我能做的，只能是缩小 Web Clip 的体积。测试了一天，终于大大缩小了 Web Clip 的体积。优化后的版本为 V1.1 版本，很快就能上线。","categories":[{"name":"作品","slug":"作品","permalink":"http://zhenby.com/categories/作品/"}],"tags":[{"name":"我的应用","slug":"我的应用","permalink":"http://zhenby.com/tags/我的应用/"},{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"},{"name":"BLink","slug":"BLink","permalink":"http://zhenby.com/tags/BLink/"}]},{"title":"iOS 屏幕方向那点事儿","slug":"talk-ios-orientation","date":"2013-08-20T11:26:00.000Z","updated":"2016-06-24T17:53:49.000Z","comments":true,"path":"/blog/2013/08/20/talk-ios-orientation/","link":"","permalink":"http://zhenby.com/blog/2013/08/20/talk-ios-orientation/","excerpt":"","text":"一般的应用，只会支持竖屏正方向一个方向，支持多个屏幕方向的应用还是比较少的。不过我在工作的项目中，跟这个屏幕方向接触比较多，因为我们是一个有界面的 SDK，要让接入方接入的，一开始做没什么经验，考虑到接入方本身的屏幕方向可能是多种的，所以我们直接上来就支持四个方向，然后就是各种转屏的问题，90度旋转、180读旋转、270度旋转，测试手都快转断了。后来觉的根本没必要，浪费了很多时间在解决屏幕方向的问题上，后来就简化到让接入方直接设置支持某个方向了。 一般的应用不用搞的这么的复杂，只要支持一两个屏幕方向就可以了。我也做一下跟屏幕方向有关的几点总结，希望能帮到一些开发者！ 系统屏幕方向枚举通过查看文档，用于控制系统屏幕方向的枚举如下：// iOS 6 之前用于控制屏幕方向的枚举typedef enum &#123; UIInterfaceOrientationPortrait = UIDeviceOrientationPortrait, UIInterfaceOrientationPortraitUpsideDown = UIDeviceOrientationPortraitUpsideDown, UIInterfaceOrientationLandscapeLeft = UIDeviceOrientationLandscapeRight, UIInterfaceOrientationLandscapeRight = UIDeviceOrientationLandscapeLeft&#125; UIInterfaceOrientation;// iOS 6 及之后版本用于控制屏幕方向的枚举typedef enum &#123; UIInterfaceOrientationMaskPortrait = (1 &lt;&lt; UIInterfaceOrientationPortrait), UIInterfaceOrientationMaskLandscapeLeft = (1 &lt;&lt; UIInterfaceOrientationLandscapeLeft), UIInterfaceOrientationMaskLandscapeRight = (1 &lt;&lt; UIInterfaceOrientationLandscapeRight), UIInterfaceOrientationMaskPortraitUpsideDown = (1 &lt;&lt; UIInterfaceOrientationPortraitUpsideDown), UIInterfaceOrientationMaskLandscape = (UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight), UIInterfaceOrientationMaskAll = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight | UIInterfaceOrientationMaskPortraitUpsideDown), UIInterfaceOrientationMaskAllButUpsideDown = (UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft | UIInterfaceOrientationMaskLandscapeRight),&#125; UIInterfaceOrientationMask; 可以发现： iOS 6 及之后版本使用的 UIInterfaceOrientationMask 类型来控制屏幕屏幕方向，该类型也新增加了几个枚举取值，可用一个枚举取值来代表多个屏幕方向。 四个基本屏幕方向（上、下、左、右）中，UIInterfaceOrientationMask = (1 &lt;&lt; UIInterfaceOrientation)，所以，如果你的应用中需要动态的将 UIInterfaceOrientation 类型转换成 UIInterfaceOrientationMask 类型的话，只需做一下上面的转换即可，不需要通过 switch 来判断再转换。 怎么控制屏幕方向在 iOS 的应用中，有多种方式可以控制界面的屏幕方向，有全局的，有针对 UIWindow 中界面的控制，也有针对单个界面。 单个界面控制iOS 6之前在 iOS 6 之前，单个界面的屏幕方向控制，都使用 UIViewController 类中的这个方法： // 是否支持旋转到某个屏幕方向- (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)toInterfaceOrientation&#123; return ((toInterfaceOrientation == UIInterfaceOrientationLandscapeRight) | (toInterfaceOrientation == UIInterfaceOrientationLandscapeLeft));&#125; 默认情况下，此方法只有参数为 UIInterfaceOrientationPortrait 时，返回值才为真，即默认只支持竖屏向上。上面的例子中，表示支持横屏向右及横屏向左两个方向。 iOS 6及之后的版本在 iOS 6 及之后的版本，单个界面的屏幕方向控制，要使用 UIViewController 在 iOS 6.0 中新增加的两个方法：// 是否支持转屏- (BOOL)shouldAutorotate&#123; return YES;&#125;// 支持的屏幕方向，此处可直接返回 UIInterfaceOrientationMask 类型// 也可以返回多个 UIInterfaceOrientationMask 取或运算后的值- (NSUInteger)supportedInterfaceOrientations&#123; return UIInterfaceOrientationMaskLandscape;&#125; 其中 - supportedInterfaceOrientations 方法在 iPad 中默认取值为 UIInterfaceOrientationMaskAll，即默认支持所有屏幕方向；而 iPhone 跟 iPod Touch 的默认取值为 UIInterfaceOrientationMaskAllButUpsideDown，即支持除竖屏向下以外的三个方向。在设备屏幕旋转时，系统会调用 - shouldAutorotate 方法检查当前界面是否支持旋转，只有 - shouldAutorotate 返回 YES 的时候，- supportedInterfaceOrientations 方法才会被调用，以确定是否需要旋转界面。 UIWindow中的界面控制(iOS 6及以上版本才有效)在 iOS 6 中，UIApplicationDelegate 协议中添加了一个可以指定 UIWindow 中的界面的屏幕方向的方法：- (NSUInteger)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window&#123; return UIInterfaceOrientationMaskLandscape;&#125; 此方法的默认值为 Info.plist 中配置的 Supported interface orientations 项的值。一般我们都不会创建其他的 UIWindow，所以通过这个方法，也可以达到全局控制。 全局控制在应用的 Info.plist 文件中，有一个 Supported interface orientations 的配置，可以配置整个应用的屏幕方向，如下图： 此配置其实跟工程中 Target 的 Summary 界面中的 Supported interface orientations 配置是一致的，修改任意一边，另一个边都会同步的修改。 并且，应用在启动时，会使用 Info.plist 中的 Supported interface orientations 项中的第一个值作为启动动画的屏幕方向。按照此处截图的取值，第一个取值为 Portrait(top home button)，即竖屏反方向，所以此应用在启动时，会使用竖屏反方向显示启动动画。 多种控制共存的规则 一个界面最后支持的屏幕方向，是取 (全局控制 ∩ UIWindow 中的界面控制 ∩ 单个界面控制) 的交集，如果全局控制支持所有屏幕方向，UIWindow 中的界面控制支持横屏，当个界面中只是支持横屏向右，那么最后界面只会以横屏向右显示，并且不支持旋转到其他的方向。 如果以上三种控制支持的屏幕方向最后的交集为空，iOS 5 跟 iOS 6 的处理有点不同，在 iOS 6 下，甚至会直接抛出 UIApplicationInvalidInterfaceOrientationException 的异常，然后直接崩溃，所以还是要保持这三个值的交集为非空。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://zhenby.com/categories/编程技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"}]},{"title":"浅析 Cordova for iOS","slug":"cordova-for-ios","date":"2013-05-16T02:54:00.000Z","updated":"2016-06-24T17:53:59.000Z","comments":true,"path":"/blog/2013/05/16/cordova-for-ios/","link":"","permalink":"http://zhenby.com/blog/2013/05/16/cordova-for-ios/","excerpt":"","text":"Cordova，对这个名字大家可能比较陌生，大家肯定听过 PhoneGap 这个名字，Cordova 就是 PhoneGap 被 Adobe 收购后所改的名字。 Cordova 是一个可以让 JS 与原生代码(包括 Android 的 java，iOS 的 Objective-C 等)互相通信的一个库，并且提供了一系列的插件类，比如 JS 直接操作本地数据库的插件类。 这些插件类都是基于 JS 与 Objective-C 可以互相通信的基础的，这篇文章说说 Cordova 是如何做到 JS 与 Objective-C 互相通信的，解释如何互相通信需要弄清楚下面三个问题： JS 怎么跟 Objective-C 通信 Objective-C 怎么跟 JS 通信 JS 请求 Objective-C，Objective-C 返回结果给 JS，这一来一往是怎么串起来的 Cordova 现在最新版本是 2.7.0，本文也是基于 2.7.0 版本进行分析的。 JS 怎么跟 Objective-C 通信JS 与 Objetive-C 通信的关键代码如下：(点击代码框右上角的文件名链接，可直接跳转该文件在 github 的地址)JS 发起请求cordova.jsfunction iOSExec() &#123; ... if (!isInContextOfEvalJs &amp;&amp; commandQueue.length == 1) &#123; // 如果支持 XMLHttpRequest，则使用 XMLHttpRequest 方式 if (bridgeMode != jsToNativeModes.IFRAME_NAV) &#123; // This prevents sending an XHR when there is already one being sent. // This should happen only in rare circumstances (refer to unit tests). if (execXhr &amp;&amp; execXhr.readyState != 4) &#123; execXhr = null; &#125; // Re-using the XHR improves exec() performance by about 10%. execXhr = execXhr || new XMLHttpRequest(); // Changing this to a GET will make the XHR reach the URIProtocol on 4.2. // For some reason it still doesn't work though... // Add a timestamp to the query param to prevent caching. execXhr.open('HEAD', \"/!gap_exec?\" + (+new Date()), true); if (!vcHeaderValue) &#123; vcHeaderValue = /.*\\((.*)\\)/.exec(navigator.userAgent)[1]; &#125; execXhr.setRequestHeader('vc', vcHeaderValue); execXhr.setRequestHeader('rc', ++requestCount); if (shouldBundleCommandJson()) &#123; // 设置请求的数据 execXhr.setRequestHeader('cmds', iOSExec.nativeFetchMessages()); &#125; // 发起请求 execXhr.send(null); &#125; else &#123; // 如果不支持 XMLHttpRequest，则使用透明 iframe 的方式，设置 iframe 的 src 属性 execIframe = execIframe || createExecIframe(); execIframe.src = \"gap://ready\"; &#125; &#125; ...&#125; JS 使用了两种方式来与 Objective-C 通信，一种是使用 XMLHttpRequest 发起请求的方式，另一种则是通过设置透明的 iframe 的 src 属性，下面详细介绍一下两种方式是怎么工作的： XMLHttpRequest bridgeJS 端使用 XMLHttpRequest 发起了一个请求：execXhr.open(&#39;HEAD&#39;, &quot;/!gap_exec?&quot; + (+new Date()), true); ，请求的地址是 /!gap_exec；并把请求的数据放在了请求的 header 里面，见这句代码：execXhr.setRequestHeader(&#39;cmds&#39;, iOSExec.nativeFetchMessages()); 。 而在 Objective-C 端使用一个 NSURLProtocol 的子类来检查每个请求，如果地址是 /!gap_exec 的话，则认为是 Cordova 通信的请求，直接拦截，拦截后就可以通过分析请求的数据，分发到不同的插件类(CDVPlugin 类的子类)的方法中：UCCDVURLProtocol 拦截请求UCCDVURLProtocol.m+ (BOOL)canInitWithRequest:(NSURLRequest*)theRequest&#123; NSURL* theUrl = [theRequest URL]; NSString* theScheme = [theUrl scheme]; // 判断请求是否为 /!gap_exec if ([[theUrl path] isEqualToString:@\"/!gap_exec\"]) &#123; NSString* viewControllerAddressStr = [theRequest valueForHTTPHeaderField:@\"vc\"]; if (viewControllerAddressStr == nil) &#123; NSLog(@\"!cordova request missing vc header\"); return NO; &#125; long long viewControllerAddress = [viewControllerAddressStr longLongValue]; // Ensure that the UCCDVViewController has not been dealloc'ed. UCCDVViewController* viewController = nil; @synchronized(gRegisteredControllers) &#123; if (![gRegisteredControllers containsObject: [NSNumber numberWithLongLong:viewControllerAddress]]) &#123; return NO; &#125; viewController = (UCCDVViewController*)(void*)viewControllerAddress; &#125; // 获取请求的数据 NSString* queuedCommandsJSON = [theRequest valueForHTTPHeaderField:@\"cmds\"]; NSString* requestId = [theRequest valueForHTTPHeaderField:@\"rc\"]; if (requestId == nil) &#123; NSLog(@\"!cordova request missing rc header\"); return NO; &#125; ... &#125; ...&#125; Cordova 中优先使用这种方式，Cordova.js 中的注释有提及为什么优先使用 XMLHttpRequest 的方式，及为什么保留第二种 iframe bridge 的通信方式: // XHR mode does not work on iOS 4.2, so default to IFRAME_NAV for such devices.// XHR mode’s main advantage is working around a bug in -webkit-scroll, which// doesn’t exist in 4.X devices anyways iframe bridge在 JS 端创建一个透明的 iframe，设置这个 ifame 的 src 为自定义的协议，而 ifame 的 src 更改时，UIWebView 会先回调其 delegate 的 webView:shouldStartLoadWithRequest:navigationType: 方法，关键代码如下：UIWebView拦截加载CDVViewController.m// UIWebView 加载 URL 前回调的方法，返回 YES，则开始加载此 URL，返回 NO，则忽略此 URL- (BOOL)webView:(UIWebView*)theWebView shouldStartLoadWithRequest:(NSURLRequest*)request navigationType:(UIWebViewNavigationType)navigationType&#123; NSURL* url = [request URL]; /* * Execute any commands queued with cordova.exec() on the JS side. * The part of the URL after gap:// is irrelevant. */ // 判断是否 Cordova 的请求，对于 JS 代码中 execIframe.src = \"gap://ready\" 这句 if ([[url scheme] isEqualToString:@\"gap\"]) &#123; // 获取请求的数据，并对数据进行分析、处理 [_commandQueue fetchCommandsFromJs]; return NO; &#125; ...&#125; Objective-C 怎么跟 JS 通信熟悉 UIWebView 用法的同学都知道 UIWebView 有一个这样的方法 stringByEvaluatingJavaScriptFromString:，这个方法可以让一个 UIWebView 对象执行一段 JS 代码，这样就可以达到 Objective-C 跟 JS 通信的效果，在 Cordova 的代码中多处用到了这个方法，其中最重要的两处如下： 获取 JS 的请求数据 获取 JS 的请求数据CDVCommandQueue.m- (void)fetchCommandsFromJs&#123; // Grab all the queued commands from the JS side. NSString* queuedCommandsJSON = [_viewController.webView stringByEvaluatingJavaScriptFromString: @\"cordova.require('cordova/exec').nativeFetchMessages()\"]; [self enqueCommandBatch:queuedCommandsJSON]; if ([queuedCommandsJSON length] &gt; 0) &#123; CDV_EXEC_LOG(@\"Exec: Retrieved new exec messages by request.\"); &#125;&#125; 把 JS 请求的结果返回给 JS 端 把 JS 请求的结果返回给 JS 端CDVCommandDelegateImpl.m- (void)evalJs:(NSString*)js scheduledOnRunLoop:(BOOL)scheduledOnRunLoop&#123; js = [NSString stringWithFormat: @\"cordova.require('cordova/exec').nativeEvalAndFetch(function()&#123; %@ &#125;)\", js]; if (scheduledOnRunLoop) &#123; [self evalJsHelper:js]; &#125; else &#123; [self evalJsHelper2:js]; &#125;&#125;- (void)evalJsHelper2:(NSString*)js&#123; CDV_EXEC_LOG(@\"Exec: evalling: %@\", [js substringToIndex:MIN([js length], 160)]); NSString* commandsJSON = [_viewController.webView stringByEvaluatingJavaScriptFromString:js]; if ([commandsJSON length] &gt; 0) &#123; CDV_EXEC_LOG(@\"Exec: Retrieved new exec messages by chaining.\"); &#125; [_commandQueue enqueCommandBatch:commandsJSON];&#125;- (void)evalJsHelper:(NSString*)js&#123; // Cycle the run-loop before executing the JS. // This works around a bug where sometimes alerts() within callbacks can cause // dead-lock. // If the commandQueue is currently executing, then we know that it is safe to // execute the callback immediately. // Using (dispatch_get_main_queue()) does *not* fix deadlocks for some reaon, // but performSelectorOnMainThread: does. if (![NSThread isMainThread] || !_commandQueue.currentlyExecuting) &#123; [self performSelectorOnMainThread:@selector(evalJsHelper2:) withObject:js waitUntilDone:NO]; &#125; else &#123; [self evalJsHelper2:js]; &#125;&#125; 怎么串起来先看一下 Cordova JS 端请求方法的格式：// successCallback : 成功回调方法// failCallback : 失败回调方法// server : 所要请求的服务名字// action : 所要请求的服务具体操作// actionArgs : 请求操作所带的参数cordova.exec(successCallback, failCallback, service, action, actionArgs); 传进来的这五个参数并不是直接传送给原生代码的，Cordova JS 端会做以下的处理： 会为每个请求生成一个叫 callbackId 的唯一标识：这个参数需传给 Objective-C 端，Objective-C 处理完后，会把 callbackId 连同处理结果一起返回给 JS 端 以 callbackId 为 key，{success:successCallback, fail:failCallback} 为 value，把这个键值对保存在 JS 端的字典里，successCallback 与 failCallback 这两个参数不需要传给 Objective-C 端，Objective-C 返回结果时带上 callbackId，JS 端就可以根据 callbackId 找到回调方法 每次 JS 请求，最后发到 Objective-C 的数据包括：callbackId, service, action, actionArgs 关键代码如下：JS 端处理请求cordova.jsfunction iOSExec() &#123; ... // 生成一个 callbackId 的唯一标识，并把此标志与成功、失败回调方法一起保存在 JS 端 // Register the callbacks and add the callbackId to the positional // arguments if given. if (successCallback || failCallback) &#123; callbackId = service + cordova.callbackId++; cordova.callbacks[callbackId] = &#123;success:successCallback, fail:failCallback&#125;; &#125; actionArgs = massageArgsJsToNative(actionArgs); // 把 callbackId，service，action，actionArgs 保持到 commandQueue 中 // 这四个参数就是最后发给原生代码的数据 var command = [callbackId, service, action, actionArgs]; commandQueue.push(JSON.stringify(command)); ...&#125;// 获取请求的数据，包括 callbackId, service, action, actionArgsiOSExec.nativeFetchMessages = function() &#123; // Each entry in commandQueue is a JSON string already. if (!commandQueue.length) &#123; return ''; &#125; var json = '[' + commandQueue.join(',') + ']'; commandQueue.length = 0; return json;&#125;; 原生代码拿到 callbackId、service、action 及 actionArgs 后，会做以下的处理： 根据 service 参数找到对应的插件类 根据 action 参数找到插件类中对应的处理方法，并把 actionArgs 作为处理方法请求参数的一部分传给处理方法 处理完成后，把处理结果及 callbackId 返回给 JS 端，JS 端收到后会根据 callbackId 找到回调方法，并把处理结果传给回调方法 关键代码：Objective-C 返回结果给 JS 端CDVCommandDelegateImpl.m- (void)sendPluginResult:(CDVPluginResult*)result callbackId:(NSString*)callbackId&#123; CDV_EXEC_LOG(@\"Exec(%@): Sending result. Status=%@\", callbackId, result.status); // This occurs when there is are no win/fail callbacks for the call. if ([@\"INVALID\" isEqualToString : callbackId]) &#123; return; &#125; int status = [result.status intValue]; BOOL keepCallback = [result.keepCallback boolValue]; NSString* argumentsAsJSON = [result argumentsAsJSON]; // 将请求的处理结果及 callbackId 通过调用 JS 方法返回给 JS 端 NSString* js = [NSString stringWithFormat: @\"cordova.require('cordova/exec').nativeCallback('%@',%d,%@,%d)\", callbackId, status, argumentsAsJSON, keepCallback]; [self evalJsHelper:js];&#125; JS 端根据 callbackId 回调cordova.js// 根据 callbackId 及是否成功标识，找到回调方法，并把处理结果传给回调方法callbackFromNative: function(callbackId, success, status, args, keepCallback) &#123; var callback = cordova.callbacks[callbackId]; if (callback) &#123; if (success &amp;&amp; status == cordova.callbackStatus.OK) &#123; callback.success &amp;&amp; callback.success.apply(null, args); &#125; else if (!success) &#123; callback.fail &amp;&amp; callback.fail.apply(null, args); &#125; // Clear callback if not expecting any more results if (!keepCallback) &#123; delete cordova.callbacks[callbackId]; &#125; &#125; &#125; 通信效率Cordova 这套通信效率并不算低。我使用 iPod Touch 4 与 iPhone 5 进行真机测试：JS 做一次请求，Objective-C 收到请求后不做任何的处理，马上把请求的数据返回给 JS 端，这样能大概的测出一来一往的时间(从 JS 发出请求，到 JS 收到结果的时间)。每个真机我做了三组测试，每组连续测试十次，每组测试前我都会把机器重启，结果如下： iPod Touch 4(时间单位：毫秒)： 组\\序号 第1次 第2次 第3次 第4次 第5次 第6次 第7次 第8次 第9次 第10次 组平均时间 第一组 10 11 8 13 11 9 14 13 9 12 11.0 第二组 33 13 9 13 11 8 14 12 15 37 15.2 第三组 20 19 9 16 11 17 13 9 10 8 13.2 这三十次测试的平均时间是：(11.0 + 15.2 + 13.2) / 3 = 13.13 毫秒 iPhone 5(时间单位：毫秒) 组\\序号 第1次 第2次 第3次 第4次 第5次 第6次 第7次 第8次 第9次 第10次 组平均时间 第一组 3 3 4 2 3 2 3 2 2 3 2.7 第二组 7 2 2 2 2 3 2 2 2 4 2.8 第三组 6 3 2 3 2 2 2 3 2 2 2.7 这三十次测试的平均时间是：(2.7 + 2.8 + 2.7) / 3 = 2.73 毫秒 这通信的效率虽然比不上原生调原生，但是也是属于可接受的范围了。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://zhenby.com/categories/编程技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"},{"name":"学习开源库","slug":"学习开源库","permalink":"http://zhenby.com/tags/学习开源库/"}]},{"title":"UIWindow的一个兼容性问题","slug":"uiwindowde-bug","date":"2013-04-28T04:53:00.000Z","updated":"2016-06-24T17:54:10.000Z","comments":true,"path":"/blog/2013/04/28/uiwindowde-bug/","link":"","permalink":"http://zhenby.com/blog/2013/04/28/uiwindowde-bug/","excerpt":"","text":"最近发现了一个奇怪的 UIWindow 的兼容性问题，通过一种比较取巧的方式解决了，如果你有更好的解决办法，请在回复中告诉我。 问题描述如果应用中使用了额外的 UIWindow，并且此 UIWindow 中包含了 UIWebView，那么在iOS 5.1或者以下的系统版本中，可能会出现在 UIWebView中触发键盘时，键盘处于不可见的状态。 前提 项目中使用了另一个 UIWindow (在这里给这个额外的 UIWindow 取个代号：HighLevelWindow) 设置此 HighLevelWindow 的 windowLevel 大于 UIWindowLevelNormal，确保在显示时能覆盖在应用默认的 UIWindow 上面 (UIWindowLevelNormal 级别为应用默认的 UIWindow 的 windowLevel 取值) HighLevelWindow 中的 rootViewController 里面包含了一个 UIWebView 在显示此 HighLevelWindow 时，已经调用makeKeyAndVisible方法将 HighLevelWindow 设置成应用的keyWindow，确保能正常的接收到触摸事件 重现步骤 使用 iOS 5.1或者以下版本的设备运行应用，在应用默认的 UIWindow 中触发过键盘，如触发过一个输入框(UITextField)，见下图： 2.调出 HighLevelWindow，将 HighLevelWindow 中的 UIWebView 载入 google.com，点击 google 的搜索输入框，会发现网页虽然上推了，但是键盘处于不可见的状态，见下图： 分析上 google 搜了很久，给出的解决方案都是说没把 HighLevelWindow 设置成应用的 KeyWindow，导致接收不到屏幕的触摸事件，但是从 google 网页上推可以看出，其实 HighLevelWindow 是可以接收到触摸事件的，而且我已经确定把 HightLevelWindow 设置成应用的 KeyWindow 了。 现在的症状就是键盘在默认的 UIWindow 中触发过后，在 HinhLevelWindow 中再次触发，键盘其实是被挡在了 HighLevelWindow 后面，处于不可见，不可点击的状态。(此症状可通过将 HighLevelWindow 的 frame.size 设置成只有屏幕一半大小来确定) 尝试了各种方法，都是不行的，而且从 iOS 6.0 开始，此 bug 是不存在的，那更可以确定是一个兼容性的问题了。 解决我突然想起，就在之前项目还没改用 UIWebView 前，使用一般的 UITextField 输入框是可以正常的显示键盘的，于是，就有以下这种取巧的解决方案：在包含了 UIWebView 的 UIViewController 显示时(viewDidAppear: 方法调用时)，插入一个 UITextField，迅速的获取焦点，然后取消焦点，删除此 UITextFiled ，关键代码如下：- FixedBugWindowViewController.m- (void)viewDidAppear:(BOOL)animated&#123; [super viewDidAppear:animated]; // 在系统版本低于 iOS 6.0 时才做此操作 if ([[[UIDevice currentDevice] systemVersion] floatValue] &lt; 6.0) &#123; // 新建一个 UITextField，并添加到视图中 UITextField *textFieldFixKeyBoardBug = [[UITextField alloc] initWithFrame:self.view.bounds]; [self.view addSubview:textFieldFixKeyBoardBug]; // 获取焦点，释放焦点 [textFieldFixKeyBoardBug becomeFirstResponder]; [textFieldFixKeyBoardBug resignFirstResponder]; // 将 UITextField 从视图中移除，并释放 [textFieldFixKeyBoardBug removeFromSuperview]; [textFieldFixKeyBoardBug release]; &#125;&#125; 加上以上代码后，可以正常的显示键盘了。 不单单是UIWebView，不单单是键盘 不单单是 UIWebView，我在使用 MFMessageComposeViewController 时也遇过这个问题，类似的 MFMailComposeViewController 应该也会出现这个问题，可以使用相同的方法修复 不单单是键盘，在 UIWebView 中，页面有一个下拉框，会显示一个 UIPickerView，此 UIPickerView 也处于被隐藏，不可见的状态，也可以使用此方法修复 Demo源码Demo源码地址：https://github.com/zhenby/UIWindowKeyboardBug","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://zhenby.com/categories/编程技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"}]},{"title":"函数vs方法","slug":"han-shu-yu-fang-fa","date":"2013-03-05T12:38:00.000Z","updated":"2016-06-24T17:46:35.000Z","comments":true,"path":"/blog/2013/03/05/han-shu-yu-fang-fa/","link":"","permalink":"http://zhenby.com/blog/2013/03/05/han-shu-yu-fang-fa/","excerpt":"","text":"函数(function)，方法(method)，之前没细究它们的不同，随心所欲的想说哪个就说哪个，“这个初始化函数…”，“这个初始化方法…”，看着都差不多，没什么区别。直到前几天，一个新来的同事，在看我整理的 Objective-C代码规范文档，里面有一段是这样的： 初始化函数 (void)init{ …}… 他看到后，疑惑的跟我说：“你这表达方式不对吧，你标题说的是函数，但是内容却说的是方法。”哦？原来函数跟方法是不一样的。 函数一个代码块，完成特定的功能，然后将结果返回给调用方，常见的函数的格式是这样的：&lt;return type&gt; &lt;function name&gt; (&lt;arg1 type&gt; &lt;arg1 name&gt;, &lt;arg2 type&gt; &lt;arg2 name&gt;, ... )&#123; // Code here&#125;一个函数声明与调用的例子：// 实现函数int plus(int x, int y)&#123; return x * y;&#125;int main (int argc, const char *argv[])&#123; int x = 2; int y = 3; // 调用函数 int result = plus(x, y); return 0;&#125; 方法也是一个代码块，不过方法是需要写在类里面的，调用时需要类或者对象才可以调用，一个 Objective-C 的方法例子如下：@implementation Person// 实现方法- (void)setName:(NSString *)name&#123; //code here&#125;@endint main (int argc, const char *argv[])&#123; // 使用对象调用方法 [[Person new] setName:@\"zhenby\"]; return 0;&#125; 有什么不同那说到底，函数跟方法的不同就是：方法是属于类或者对象的，而函数则不一定，可以独立于类与对象之外，独立调用，所以可以说 函数 &gt;= 方法，因此方法也可以叫 member function。 Objective-C中的函数Objective-C 中一般的函数是全局有效的(可在函数前加 static 关键字使得该函数只在该文件中有效)，即在一个文件中实现了一个函数，在同个项目中的其他代码中都可以直接调用此函数，所以定义函数时，函数名需要唯一，重复的函数名(不管参数是否一致)是编译不过的。知道这个特性后，就可以把一些常用的代码块，比如获取当前时间戳这样的功能的整理成了一个函数，这样的好处是项目中的代码在需要时都可以直接调用，而不需要类或者对象，类似于 NSLog 函数。 而我在实现函数的时候，遇到了一个这样的警告“no previous prototype for function xxx ”，这个警告的意思是没找到一个前置的函数原型，在文件的顶端，或者头文件(如果有的话)加上你所加的函数原型就可以了，例如：// 函数原型int plus(int, int);/* 如果参数为空的话，在函数原型中需要传 void，在函数原型中参数为空的话， 在C中表示此函数可以接受任意个参数，在 Objective-C 中也有一样的规则 */long timestamp(void);// 实现函数int plus(int x, int y)&#123; return x * y;&#125;long timestamp()&#123; // 返回当前的时间戳 return (long)[[NSDate date] timeIntervalSince1970];&#125; Objective-C中的方法在 Objective-C 中，方法的调用是通过消息传递来进行的，需要在运行时才能确定方法的地址(只要知道一个类的方法名，不管这个方法是否公开，都可以调用到，这也是为啥苹果的私有 API 会被挖出来，所以也没有受保护方法这样的说法，方法要么是公开的，要么是不公开的，无论公不公开，通过方法名都可以调用到方法)，而消息传递就是通过id objc_msgSend(id theReceiver, SEL theSelector, ...)这个函数来达到目的的，可以说 Objective-C 中的方法，其实相当于固定前两个参数的 objc_msgSend 函数。比如：@implementation Test- (long)timestamp&#123; NSLog(@\"in timestamp\"); // 返回当前时间戳 return (long)[[NSDate date] timeIntervalSince1970];&#125;@end// 调用 timestamp 方法Test *test = [Test new];[test timestamp];[test release];//----------------------------------------------------------/* 上面 [test timestamp] 这句代码就相当于以下的函数调用， 直接执行下面的代码，也可以在控制台中打印出 in timestamp。 */#import &lt;objc/message.h&gt;objc_msgSend(test, @selector(timestamp));","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://zhenby.com/categories/编程技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"}]},{"title":"2012","slug":"2012","date":"2013-02-10T07:35:00.000Z","updated":"2016-06-24T17:45:54.000Z","comments":true,"path":"/blog/2013/02/10/2012/","link":"","permalink":"http://zhenby.com/blog/2013/02/10/2012/","excerpt":"","text":"大家新年好！大年初一，窝在家写博客，写写我的2012。 工作2012春节后，开始去公司的游戏中心，从服务端转成客户端，开始搞 iOS。这一年我感觉很不错，比之前搞服务端进步大很多。之前搞服务端，主要提供的是接口跟数据，而客户端，是用户可以直接接触到的产品，我更喜欢客户端，离用户更近一点。 作品今年开始才有自己个人的作品。做了一个叫剪贴箱的 app，下载量很一般，用户量很少；我也没做推广，发版本的时候就在微博上发一下。用户量跟用户评价都很少，所以让我没了更新版本的动力， 到现在为止也只是更新了两个版本而已。不过v1.1 版本发了之后，每天的新增用户跟活跃用户都有明显的提高，现在能稳定排在中国区效率类热门榜单五六十名左右的位置。这是我第一次做一个完整的产品，从一个小想法，到一个产品。其实还做了另一个娱乐类的 app，想着年前能上线的，不过就前两天被苹果的审核拒了，也发现了一些 bugs，所以等着年后修复完再重新提交审核。 开源开始 iOS 开发后，我还有另一个改变，就是开始大量的使用开源项目，自己也有意识的开源一些代码了。想想以前做服务端，做的都是比较简单的东西，对数据进行简单的处理，把数据保持在内存里，找出符合条件的数据返回……很少需要用到开源的项目，所以自己也不会有意识的把某些模块独立出来，作为一个开源项目。做了 iOS 后开始接触到了大量的开源项目，一遇到一个系统没提供的功能或者控件，先上 github 找开源库，找不到那就自己尝试写一个。Three20，JSONKit，ASIHttpRequest，EGO等这些优秀的开源项目给 iOS 开发者很大的帮助。我慢慢的也会自己开源一些东西，我的 github 主页：http://github.com/zhenby。 我读今年开始阅读，读了大概20本书，书单在这里。之前也会零散的阅读，一本书放在床头，三个月都没读完，读到最后都忘了前面讲什么了。2012年年初买了 Kindle，也在手机，iTouch 上装上各种阅读软件，买电子书看。睡觉前看，上厕所的时候也看，公车地铁上也看，感觉读一本没之前想的那么困难，有时候一天就可以读完一本书了。我越来越喜欢读电子书了，随时随地想看就看，做书摘，做笔记，再导出来放到 Evernote 中，多方便。很多人还是钟情于实体书，我也买实体书，不过相对于电子书，我读实体书的效率低很多，这跟我没有大片连续的阅读时间有关，所以我现在都首选电子书，想读的书实在没电子版，再考虑买实体书。2012年真应该对电子书说一声我爱你。 运动2012年的运动频率明显增多了。夏天的时候，每个工作日基本能保持一天一跑步，跑个两三公里。现在冬天懒了，一三五才去跑。亏了一群跟我一起跑步的同事，六点一到，几个人就开始动身准备跑步，几个人互相问一问去不去跑步，今天穿牛仔裤，不方便跑？拿不跑也去走走，吊一下单杠嘛。好，走！2012我还去参加了一次10Km的马拉松跑，2013年继续参加。对了，2013年还有一个运动的目标就是骑单车去珠海。 2013 读书、运动的好习惯要继续保持 开源多点东西 继续参加广州马拉松，骑单车去珠海","categories":[{"name":"生活","slug":"生活","permalink":"http://zhenby.com/categories/生活/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"http://zhenby.com/tags/年度总结/"}]},{"title":"印象普吉岛","slug":"yin-xiang-pu-ji-dao","date":"2013-02-09T04:50:00.000Z","updated":"2016-06-24T17:45:40.000Z","comments":true,"path":"/blog/2013/02/09/yin-xiang-pu-ji-dao/","link":"","permalink":"http://zhenby.com/blog/2013/02/09/yin-xiang-pu-ji-dao/","excerpt":"","text":"梦除夕夜了，这两天天气冷了不少。就三天前我从广州回来的那天，广州的天气热到就穿一件薄长袖还会流汗，所以我就带了一件薄外套回来。把这件外套穿上，扣子扣紧，开着摩托车出去，浑身发抖。被冷了这么几天后，昨晚做梦的时候，我梦到了我在海边晒太阳。梦里我穿着一条沙滩裤，太阳很猛，海风徐徐，近处大家正在踏着海浪；远处拖拽伞刚被水上摩托拉起，在蓝天下飞的跟白云一样高。多舒服，我躺下，直接睡在沙滩上，让阳光洒满全身，正想舒服的睡去的时候，我突然想起，我靠，我还没擦防晒霜。这可不成，会被晒伤的阿！然后就起来准备去买防晒霜，就醒了！买什么防晒霜！买什么防晒霜！醒来后才想起梦中海边的景色不就跟当时在普吉岛一摸一样，才想起我还没写这篇游记呢。 行程11月底从吉隆坡去的普吉岛，待了四天，就逛了两个海滩，巴东跟卡伦。大部分时间都在巴东上，巴东很热闹，人很多，一条海鲜街，晚上还有一条小吃街。卡伦的海滩人比较少，很舒服，适合去那里晒着太阳睡觉。 吃巴东有很多饭店，海鲜一条街，是吃海鲜的好地方，推荐 NO.6 饭店，价格公道，味道也不错。巴东夜市晚上的时候，很多路边摊出动，里面有各式各样的小吃。不过肠胃不好的，就少吃生的海鲜咯，我们吃了个不熟的生蚝，然后我女朋友中招了，闹了一天肠胃炎。 骑摩托车直接用护照去抵押，就可以租到摩托车，价格不贵，一天就三四十块。骑着摩托车很方便的，可以到处逛，吹着海风，看着海景，逛去远一点的地方。我租了一天，从巴东海滩骑到了卡伦海滩，那段山路很多的上下坡，开起来有飙车的感觉。不过有点危险，而且泰国是靠左行驶的，一开始不习惯。那天我开着摩托车去买东西，转弯后一时忘了靠左行驶，迎面骑来的老外对我大喊：“You should drive left！！”，我才意识到我骑错边了，“I sorry, i forgot”，我小声的应答。 人妖没去看人妖表演，不过在饭店吃饭的时候遇到一个会讲普通话的人妖，骨架很大，男生的声音，女生的外貌，不漂亮，显得有点粗狂。她有很多女性化的动作：说话激动时用手捂着脸，不耐烦时给出一个 小S 的白眼，还有一个比较夸张的是，空闲下来时在旁边做两腿张开的深蹲动作，我猜是想身材更好点吧。 欧美老年人普吉岛有超多的欧美人，而且还有很多欧美老年人。女的深受肥胖毒害，站在沙滩上，浪花打过来纹丝不动；而男的一副大好肯德基上校的样子，站在老婆旁边，望着老婆，是不是的说上几句话。我为什么一直强调欧美老年人，因为真的没看见其他脸孔的老年人在度假。心态不一样，中国这个时期的老年人，忙于担心儿女的婚事，忙于带孙子孙女。 再乱扯一下 在泰国的电视上看到微信的广告，赞助了一个节目，那个节目让大家通过微信进行投票，用微信查看附近的人，发现也有不少人，原来微信已经进军泰国市场了 观察了一下泰国人拿的手机，大部分的本地人，拿的基本都是 Nokia 之类的功能机，少量的 Android 机，欧美人大部分都拿 iPhone 坑爹的酒店竟然没 wifi，感觉普吉岛那边的 wifi 不是很普及，搜出来一些免费热点，也上不了","categories":[{"name":"生活","slug":"生活","permalink":"http://zhenby.com/categories/生活/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://zhenby.com/tags/旅行/"}]},{"title":"剪贴箱V1.1 版本上线了","slug":"jian-tie-xiang-v1-dot-1-ban-ben-shang-xian-liao","date":"2013-01-11T12:37:00.000Z","updated":"2016-06-24T17:52:32.000Z","comments":true,"path":"/blog/2013/01/11/jian-tie-xiang-v1-dot-1-ban-ben-shang-xian-liao/","link":"","permalink":"http://zhenby.com/blog/2013/01/11/jian-tie-xiang-v1-dot-1-ban-ben-shang-xian-liao/","excerpt":"","text":"剪贴箱V1.1 版本上线了，这个版本主要新增了一个 直达应用，在解锁图案加密显示密码 跟 清除剪贴板 这三个功能。 而直达应用这个功能受启发于一个朋友在微博中的反馈 @Rex-Wanted：回复@夏小蛋:看了简介，有些建议不知道可不可以实现，比如说进去后可以添加应用列表，然后直接在软件里打开需要用的应用，同时已经复制好应该复制的东西这样，而不需手工切换… 一看到这个意见，有点豁然开朗的感觉，我一直在思考怎么简化这个流程：用户在别的应用中需要一个常用内容 -&gt; 进入剪贴箱复制 -&gt; 切换回之前的应用 -&gt; 粘贴内容。由于苹果在 iOS 中的沙箱限制，第一步与第四步我都无法触及，第一个版本中我主要优化第二步，现在听了朋友的这个建议后，发现，第二步也是有优化空间的：在剪贴箱中复制完内容后，可以让用户方便的跳去别的应用，可以省去用户手动切换应用这一繁琐的步骤。 实现方案需求有了，但是在 iOS 中应用是无法获取到用户所有安装的应用的，不过可以通过 URL Scheme 的方式检查当前设备是否有安装这个 URL Scheme 的应用，所以我的做法是通过内置一些应用的信息(包括应用名、图标、URL Scheme等)，只有有安装的应用才会显示在直达应用列表中，用户点击了一个应用的图标，就通过 URL Scheme 打开这个应用。 获取应用的URL Scheme的方法 上这个网站 URL Schemes 查一下相应的 app 的 URL Scheme 是否有被收录； 第一种方法没找到的话，把相应的 app 的 ipa 安装文件下载下来，把文件 .ipa 的后缀改成 .zip，然后解压，打开 Payload/xxx.app/Info.plist 这个文件，找到 URL types 下的 URL Schemes 下的数组对应的值就是这个 app 的 URL Scheme 了。 简单验证应用URL Scheme是否正确的方法在真机设备（此设备要安装了待验证的 app）里面打开 Safari，然后在地址栏中键入应用的 URL Scheme，注意后面要带 ://，比如 Gmail 的，在地址栏中键入googlegmail://，然后点击确定，如果能正常调出 Gmail，即代表这个 URL Scheme 正确可用。 麻烦的苹果自家应用苹果自家的应用， App Store、Mail 跟 Safari 这三款应用用到复制内容的可能性比较大，所以我就想在剪贴箱中内置这三款应用。这三款应用虽然都可以使用 URL Scheme 打开这些应用，但是官方文档中提到的都是定义了具体行为的 URL Scheme，比如 Mail 应用的 URL Scheme 是 mailto:，在用户设置了邮箱账号的情况下打开这个 URL Scheme，就调出了发邮件的界面了。但是我应用需要的跳转到一个应用时，还原到应用最小化前的界面。最后这三个应用的处理方案都是不完美的。 App StoreApp Store 这个应用的 URL Scheme 是 itms-apps://，通过这个 URL Scheme 能打开 App Store，但是却无法还原回用户最小化前的界面。此 URL Scheme 一般被用来打开 App Store 中某一个具体的应用的详情页，或者搜索某个关键字的结果页等等这种有具体行为的操作，如果直接使用itms-apps://或者其他非法的地址打开的话，在 App Store 中会报无法连接到iTunes Store的错误。关于这个问题，查了很多资料，都无法找到解决办法，就一直乱试，终于试到在 iOS 6.0 下使用itms-apps://itunes.apple.com打开时，App Store 能正常打开了，但是只是能打开首页，而且是 tab 没选中下的首页。用户要再点一次 tab 才可以回还原到上次的界面。比如用户在搜索 tab 中搜了一个关键字，并打开了一个应用A的详情，用户再通过剪贴箱打开 App Store 时，会到 App Store 的首页，而用户要点一下搜索这个 tab 才能回到之前应用A相详情的界面。这个效果比报错效果好，找不到其他办法的情况下，就直接用了这种方法了。但是某天在 iOS 5.0.1 的系统下面使用这个itms-apps://itunes.apple.com打开时，先打开了 App Store，载入了一下，又调用出了 iTunes。崩溃了阿！！找来了 iOS 5.1.1 的版本测试了一下，发现又可以跳到 App Store 首页，所以就对 iOS 5.0.1及以下的版本做了处理，直接用 itms-apps:// 打开，所以会报一个错误。处理起来没有完美的方案，所以只能先这样处理了，后续想到好的再改进。 MailMail 这个使用mailto:打开，如果用户设备中没设置邮箱账号，那么就会跳到 Mail 最小化前的界面；如果用户设备已经设置了邮箱账号，会直接调用出 Mail 到达发邮箱界面。考虑到用户大部分是在设置邮箱账号的情况下需要剪贴箱的概率大一点，所以就采用这种方式了。 SafariSafari 一定要在http://后面跟上地址，如果不跟的话，直接就会到达一个新建的空白标签页，麻烦，直接把 Safari 去掉，不内置了。 写在最后至于其他第三方的应用我只是简单测试了一下而已，没细测，如果发现有问题可联系我，或者直接在意见反馈里面反馈给我就可以了。这个版本要特别感谢@Rex-Wanted、@bang 跟 @Mr大表 提的产品建议，特别给力。对了，在解锁图案界面，右滑剪贴板内容，可以清除剪贴板哦，怕剪贴板泄露了你的密码可以把剪贴板清除。","categories":[{"name":"作品","slug":"作品","permalink":"http://zhenby.com/categories/作品/"}],"tags":[{"name":"我的应用","slug":"我的应用","permalink":"http://zhenby.com/tags/我的应用/"},{"name":"ClipBox","slug":"ClipBox","permalink":"http://zhenby.com/tags/ClipBox/"}]},{"title":"在吉隆坡遇见的一些人","slug":"yin-xiang-ji-long-po","date":"2013-01-05T13:53:00.000Z","updated":"2016-06-24T17:45:15.000Z","comments":true,"path":"/blog/2013/01/05/yin-xiang-ji-long-po/","link":"","permalink":"http://zhenby.com/blog/2013/01/05/yin-xiang-ji-long-po/","excerpt":"","text":"11月底去了一趟吉隆坡+普吉岛，讲讲在吉隆坡遇到的一些人。 主动帮我们拍照的欧美人第一天到吉隆坡，到之前预定的 Sky Bar 吃饭，这个吧在36楼，环境很特别，中间是游泳池，跟双子塔很近，靠窗的位置可以看到很美的双子塔夜景。这是我们在吉隆坡吃的第一顿，光看那个英文菜单就看晕了，翻了几次菜单才知道，原来这里没主食，只有小吃跟鸡尾酒，就蒙着随便点了东西。泳池里面一男一女在游泳，男的一个来回一个来回的游着自由泳双子塔也开灯了，双子塔在刚降临的夜色下多明亮好看看了看吧里面的人，欧美人居多，旁边的一对欧美中年妇女(五六十岁左右)，喝着鸡尾酒，时不时的站在沙发上跟双子塔合照叫我们给她们两个拍张合照，笑着说了几声 Thank you她们埋单准备走人，经过我们座位的时候，主动问我们，要不要帮我拍找合照，还叫我们站在沙发上，这样照的好看点帮我们照了两张后，看了一下效果，说太暗了，这个相机闪光灯怎么开，开着闪光灯拍会比较好我折腾了一下，也折腾不出来，这是借来的相机，我还不太会用呢跟她们道谢了一下：没关系，这样就可以了她们叫我们回去 PS 一下，效果应该会好点真亲切，真好。五六十岁，儿女长大了，开始满世界玩，多美好的人生。 「Sky Bar」「Sky Bar 窗外的双子塔」「她们帮我们拍的与双子塔合照」 酒店服务员第一天，入住酒店，晚上女朋友洗了头，叫酒店服务员送个吹风筒，一直说吹风筒别的客人在用。到了12点再催他的时候，他就说现在没办法，没吹风筒可以提供了，因为这个时间点其他客人都睡觉了。叫服务员想办法，他上来我们房间说明情况，然后打了一通电话，说可以借到风扇。跑到附近朋友家借来了风扇，搬上来给我们我们很感动，连说了很多声 Thank you然后他说：“So，Tips！”我一时没反应过来，女朋友提醒我，要小费阿惊愕，不太习惯这种文化起身找出钱包，找出了零钱给了他我出发前查过，泰国才是小费国家，马来西亚不是阿即使在泰国这样的小费国家，也没有遇到这种公然要小费的情况。 「酒店外」 指路的甲乙丙第二天在吉隆坡游玩，想搭车去金三角，不知道怎么去，遂问人，这段经过引用我女朋友的两条微博： 除了自身英语烂之外，不习惯这里local的发音也是个问题～刚刚向一个保安问路，他告诉我们哪里有free bus可以坐过去，一直跟我们说behind the hotel会看到bling bling colour的bus，@夏小BO 问我知不知道bling bling colour是什么颜色，我哪知道啊！只好过了马路再问人，这次又变成是bubble colour！一直试图理解这到底是什么colour，幸好此时有个会说中文的男的过来告诉我们，到前面坐那个紫色的车。原来是紫色！purple colour！！！对的，他们的英文口音确实很重，不过他们的英文普及程度很高，随便问个人，基本都会讲英文。吃饭的时候跟你一起搭台的也在用英文在聊天。 一起避雨的母女在去金三角的车上，天就下起雷陈雨。下车马上跑到一个地方避雨，一对母女也在同个地方避雨。我用英语搭讪跟她们聊了一下，她们突然冒出一句普通话问我是不是华人。“原来你会讲普通话阿”“对阿，上学时候上的是华语学校，所以会讲华语”开始用普通话闲聊。。。。。。突然她手机有一个来电，她接起来开始用粤语描述当前被雨困住的情形。“原来你还会讲粤语阿”开始用粤语闲聊。。。。。。。在吉隆坡这类华人脸孔的人语言天赋真不错，马来语、英语、普通话，甚至粤语都会讲。憋英语跟人交流憋太久了，能跟个会讲普通话、粤语的交流起来，倍感轻松。 她还很生动的跟我们描述了一下吉隆坡的天气 吉隆坡就两季，下午之前就是很晒，很热，到了下午，就会下起雷阵雨在吉隆坡几天，确实符合她的描述。","categories":[{"name":"生活","slug":"生活","permalink":"http://zhenby.com/categories/生活/"}],"tags":[{"name":"旅行","slug":"旅行","permalink":"http://zhenby.com/tags/旅行/"}]},{"title":"我的「剪贴箱」上线 App Store 了","slug":"clipbox-avaliable-on-app-store","date":"2012-12-08T15:13:00.000Z","updated":"2016-06-24T17:51:53.000Z","comments":true,"path":"/blog/2012/12/08/clipbox-avaliable-on-app-store/","link":"","permalink":"http://zhenby.com/blog/2012/12/08/clipbox-avaliable-on-app-store/","excerpt":"","text":"我的 app「剪贴箱」经过五天的审核，终于通过上线了。App Store 地址：https://itunes.apple.com/cn/app/id583710975?mt=8 做的原因转做 iOS 后，一直想做个东西，不然好像浪费了 App Store 这个最大的 app 分发市场了。而我经常在 App Store 上下载东西，发现 App Store 上下载总是需要密码，而且我的密码是包含数字，大写字母，小写字母还有符号的，每次输入都觉的很麻烦，所以就想到了要做一个可以复制粘贴密码的 app。 过程一开始想的很简单， 只是保存常用的密码，然后需要的时候复制就可以了。这个功能两三天就可以搞定了，但是觉的单单有这个功能不足于做成一个产品，后来通过自己慢慢体会，思考，才逐渐加上了常用文本、图案解锁等其他功能。整个 app 完成的时间很漫长，基本大部分晚上跟周末的时间都投入进去了。6月份开始做的，前前后后一直弄，主要功能不多，图案解锁的比较麻烦。而且我还做了英文的国际化，翻译浪费了不少时间。差不多做完了时候，忙工作的项目，停了两个月。前前后后搞了4个月，终于上线了。 困难 产品设计：第一次完整的做一个产品，学会了更多的从用户的角度思考，思考用户的使用场景，这个过程里面，想不通的时候很迷茫，等到想通了，很爽，感觉我是在创造一个东西，一个属于我自己的东西，慢慢的给他加上骨架，填上血肉，再上色；轻轻拍拍他的头，唤醒他，运行的还不错，可以帮助一些用户解决某类场景下的问题，够了。 界面设计：第一次做一个完整的产品，最难的就是设计了。本身对设计不在行，觉的界面怎么弄怎么怪，图标怎么弄怎么拙。很多界面上的图片，我都是从别的 app 中“偸”g过来做修改的，东凑西凑终于凑了一个可以见人的界面出来。 国际化：我把这个 app 定位为工具效率类 app，可以国际通用，而且国外的 App Store 市场那么蓬勃，所以做了英文的国际化。六级不过的我翻译起英文来比较难，想比较短，又要准确的表达出意思，一些简短、常用的词就参考了几个英文版本的 app，长一点的句子，就只能靠我两个英语专业的高中同学了。 定位与目标我的这个 app 是 效率工具类，我把我自己的 app 定位为效率类的，那么就代表这是让用户在某个场景下能更好、更快的完成某件事的辅助工具，我的 app 是帮助用户把密码/文本复制到剪贴板里面，用户复制完就要去完成下载、注册或者登录了，所以居于这个定位，我确定了两个目标：多启动次数，少停留时间。 启动次数越多，就代表用户对这个 app 越依赖，比如：每次想从 App Store 上下载 app 的时候，都会先进去这个 app 里面复制 App Store 的密码； 启动次数越多，基本是每个 app 追求的目标，我的 app 还有一个目标，单次启动的停留时间越少越好，用户需要这个 app 的时候，能快速的从 app 中获取到他想要的东西，复制完，走人。所以我在启动画面的解锁图案里面加了 当前剪贴板内容，用户在启动的时候，如果刚好当前剪贴板是用户需要的内容，那么用户就可以 转身离开了。 知道了定位跟目标，做出来的产品至少不会偏离用户需求太远。 写在最后初次做产品，在产品推出的那一刻，幸福感十足，自己投入了很多时间，精力，希望使用的用户会喜欢。当然产品中也有很多不合理的地方，如果发现了，或者有好的产品建议，都可以在「剪贴箱」中的 意见反馈 中给我提，或者直接发邮件给我：ifone8[@]gmail.com 。","categories":[{"name":"作品","slug":"作品","permalink":"http://zhenby.com/categories/作品/"}],"tags":[{"name":"我的应用","slug":"我的应用","permalink":"http://zhenby.com/tags/我的应用/"},{"name":"ClipBox","slug":"ClipBox","permalink":"http://zhenby.com/tags/ClipBox/"}]},{"title":"第一次10km跑","slug":"my-first-10k","date":"2012-11-21T06:38:00.000Z","updated":"2016-06-24T17:43:27.000Z","comments":true,"path":"/blog/2012/11/21/my-first-10k/","link":"","permalink":"http://zhenby.com/blog/2012/11/21/my-first-10k/","excerpt":"","text":"11月18号的时候参加了广州国际马拉松，第一次跑10km，顺利完成，成绩56’50。 报名报名比较曲折。11月初的时候在微博上看到有这个赛事，看到了有10km 的项目，就想试试。登录进去报名网站里面想报名，发现名额全满了。然后在11月13号的时候，@Nike广州 发了个微博，说前一百回复的可以报名参加广州马拉松5km 项目，马上就回复参加了。在前一天 Nike 才发信息来通知报名成功，然后去领号码牌跟衣服。本来以为是报5km 的，拿到的号码牌却是10km 的，原来是5km 跟10km 的路线是一样的，所以 Nike 鼓励大家都完成10km 的项目。就这样曲折的还是报上了10km 的项目。 预想我前半年，下班后去天河公园的跑步，跑两个小中圈，跑一次3.5km 左右。下半年懒了，只是跑一个小圈-。- ，跑一次1km 左右而已，不过跑完后会去小区的健身设备上做仰卧起坐。没跑过10km 这么长的距离，不过我经常运动，对我的体力还是有点信心的。所以第一次跑10km，第一目标是跑完全程，第二目标是跑进1个小时内。 过程 起点 ： 人超多，大家都堆在起点的位置，所以我开跑6分钟后，才开始跑出起点，可以开始小跑； 0-2km ：开始跑感觉还满轻松的，跟我平常的节奏一样。我习惯两呼两吸的呼吸节奏，然后每一次呼或者吸都会抬脚跑一步。在1-2km 间，超过了很多人； 3-4km ：运动量开始上来了，也开始出汗了。我是穿长的运动裤跑的，感觉大腿的毛孔都塞住了，很热，很痒，以后还是穿短裤跑比较好; 4-5km ：体力明显下降了，呼吸变短了，步子也小了，不过节奏掌握的不错。这是一段比较困难的时间，总想着这么5km 跑的终点还没到；这段时间感觉有挫折感，也没有外部激励，只能靠自己慢慢熬过来。这段时间也被很多人超过了； 5km ：5km 是 mini 跑的重点，终于跑完一半了，心里的挫折感也慢慢没了。喝了水之后，体力也慢慢恢复了； 5-6km ：跑的还不错，比较轻松； 7-8km ：补充的能量慢慢消耗完，有点吃力，不知道自己又跑了多远，好迷茫的样子； 9-10km：看到小蛮腰越来越近了，就知道终点不远了；第一个10km 跑即将完成，感觉越跑越有劲； 10km ：最后临近终点前，还冲刺了一下，很满足的冲过终点，时间：1小时02分50秒。 感受 10km 没想象中那么困难，而且在最后越跑越有劲，出乎我的意料。 路上行人，选手间的鼓励作用很大，组委会安排了一些中老年的健身小团体(打太极，舞剑，舞扇子等)在赛跑跑步给我们加油，路上看的人时不时也会给我们喊加油，鼓励真的很重要，在听到鼓励后的50m 里，明显感觉更有动力。所以下次看到长跑人群，不要吝啬你的鼓励，给他们喊一句“加油“其实就够了。 跑手想知道自己跑了多远，这是给自己的正能量。但是组委会没在各路段上设置路程的牌子，这点比较遗憾，如果有在各路段设置路程的牌子的话，大家还会跑的更好的。 还要一个要吐槽的就是，在 5km 处，给我们喝的水是一整瓶的。我们要一边跑一边拧开瓶盖，然后再喝，而且你只会喝一点，不会把一整瓶喝光，剩下的大半瓶又不能带着它跑，所以都直接扔地上了，很浪费。直接用纸杯装一杯就差不多了；而且路上的喝水点设的很少，就只有5km 处，7-8km 处，10km 处三个而已。 跑完这次 10km，我的人生要做的事又增加了一项：在我有生之年完成一次全程的马拉松跑。","categories":[{"name":"生活","slug":"生活","permalink":"http://zhenby.com/categories/生活/"}],"tags":[{"name":"跑步","slug":"跑步","permalink":"http://zhenby.com/tags/跑步/"},{"name":"马拉松","slug":"马拉松","permalink":"http://zhenby.com/tags/马拉松/"}]},{"title":"iOS 开发中的分辨率问题","slug":"ios-device-resolution","date":"2012-11-08T15:31:00.000Z","updated":"2016-06-24T17:42:57.000Z","comments":true,"path":"/blog/2012/11/08/ios-device-resolution/","link":"","permalink":"http://zhenby.com/blog/2012/11/08/ios-device-resolution/","excerpt":"","text":"今天逛知乎的时候看到这个问题 ios开发过程中屏幕尺寸，分辨率及其比例等等之间的关系?一次性详尽，清晰介绍，以饷入门者 根据屏幕尺寸和分辨率，ios现在数起来有6个版本。一，3GS；二，4s为代表；三，iphone5；四，ipad2为代表；五，ipad4为代表；六，ipad mini。只是分辨率不一样的情况，如一二或者四五相比，开发时提供两种分辨率就可以了，应用自动识别？只是尺寸不一样的情况，如四六相比，开发时完全没有影响？分辨率以及尺寸都不一样的情况，如二三相比，又如何? 想想刚开始做 iOS 开发的时候也有类似的疑问，于是做了回答，希望这个对初学者有帮助： iOS 设备现有的分辨率 iPhone/iPod Touch 普通屏320像素 x 480像素 iPhone 1、3G、3GS，iPod Touch 1、2、3 3：2 Retina 屏640像素 x 960像素 iPhone 4、4S，iPod Touch 4 16：9 Retina 屏640像素 x 1136像素 iPhone 5，iPod Touch 5 iPad 普通屏768像素 x 1024像素 iPad 1， iPad2，iPad mini Retina屏1536像素 x 2048像素 New iPad，iPad 4 问一：只是分辨率不一样的情况，如一二或者四五相比，开发时提供两种分辨率就可以了，应用自动识别？答：在 iPhone 5 跟 iPod Touch 5 没出之前，对于开发者来说，一二就是分辨率不同的区别而已，因为他们都是3.5寸的屏幕。并且，你细心的话会注意到，一二他们的分辨率是成倍的关系。这给 iOS 的设计和开发都提供了方便，界面设计只需要设计一套，然后进行等比例放大缩小即可。 为了方便开发人员开发，iOS 中统一使用点（Point）对界面元素的大小进行描述。所以对于一跟二，只需把屏幕大小都当成 320 x 480点 进行开发即可，点跟像素的换算关系如下：普屏 : 1点 = 1像素Retina屏 : 1点 = 2像素iPad 上的开发也是这样，只需根据 768 x 1136点 进行开发即可。 而在 iPhone 5 跟 iPod Touch 5 的机器上，对于开发者来说，它的界面大小就是 320 x 568点，你只需根据这个大小去调整你的界面（如果需要调整的话）。 比如：我有一个按钮，要放在屏幕中间的位置，那么在界面大小为 320 x 480点 的设备上，只需设置它的 center 为 (320/2, 480/2) 即可，在 3：2 Retina 屏上系统这个按钮也可以正确的显示在中间；而在屏幕大小为 320 x 568点 的设备上，你就设置它的 center 为 (320/2, 568/2)。直接通过 [[UIScreen mainScreen] bounds] 即可获取到当前屏幕的基础分辨率，所以不用 hard code。 问二：只是尺寸不一样的情况，如四六相比，开发时完全没有影响？答：开发时只需要关注分辨率即可，iPad 2 跟 iPad mini 屏幕尺寸不同，但是分辨率一致，所以完全没有影响，在 iPad 2 上可正常跑的 app，在 iPad mini 上也可正常跑。 问三：分辨率以及尺寸都不一样的情况，如二三相比，又如何？答：在 问一 中已经回答了","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://zhenby.com/categories/编程技术/"}],"tags":[]},{"title":"《麦田守望者》","slug":"the-catcher","date":"2012-11-02T12:42:00.000Z","updated":"2016-06-25T15:30:06.000Z","comments":true,"path":"/blog/2012/11/02/the-catcher/","link":"","permalink":"http://zhenby.com/blog/2012/11/02/the-catcher/","excerpt":"","text":"花了一个多星期把《麦田里的守望者》看完了。 小说里 “有那么一群小孩子在一大块麦田里做游戏。几千几万个小孩子，附近没有一个人——没有一个大人，我是说——除了我。我呢，就站在那混账的悬崖边。我的职务是在那儿守望，要是有哪个孩子往悬崖边奔来，我就把他捉住——我是说孩子们都在狂奔，也不知道自己是在往哪儿跑，我得从什么地方出来，把他捉住。我整天就干这样的事。我只想当个麦田里的守望者，我知道这有点异想天开，可我喜欢干的就是这个，我知道这不象话。” 当主人公霍尔顿的妹妹菲比问霍尔顿：“说说你将来喜欢当个什么？” 的时候，霍尔顿说出了上面的这一段话。他不喜欢生活中别人的各种假模假式; 他讨厌看电影，因为电影里面充满伪君子 他讨厌别人跟他说“Good luck” 他讨厌学校的校长老师对有钱人毕恭毕敬 他讨厌弹琴弹的很好，开始卖弄起来的酒吧老板 ……他好像对现实世界中的一切都看不惯，除了他妹妹菲比跟他的梦中情人琴。他不想成为假模假式的人，他只想当个麦田里的守望者，守望着孩子，避免象菲比，琴这样天真纯真的孩子堕落成假仁假义的伪君子。他渴望能接触到真实，真诚，但是遇到的却全是欺骗与虚伪。所以他开始拒绝接触，融入，理解社会，霍尔顿甚至一度想成为一个聋哑人，到一个没人认识他的地方安静的过一辈子，因为他知道，一旦他开始接触与融入社会时，他也会慢慢的变成他自己讨厌的人：出人头地，然后买辆混账凯迪拉克。 现实里我们的青春期也有这么一个阶段，看大人的世界怎么都看不惯，叛逆的很。总是拒绝配合，想突出自己的个性，但是那是真实的我们，表达出自己最真的想法。但是我们经过初中、高中、大学、工作阶段后，我们的叛逆不见了，我们跟世界合拍了，互相说这一些恭维的话，想着怎么讨好别人，唯利是图…..上一次跟高中同学一起在一个餐厅吃饭，旁边一桌的白领也在吃饭，主要是在喝酒，互相的敬酒，说着一些傻里傻气的恭维的话。我一直在观察他们，觉得他们很可笑。其中一个胖子领导，笑笑的在劝一个小的喝一杯白酒，那个小的开始喋喋不休的在说着，不太愿意喝。胖子领导对旁边的一位（应该是那位小的直接主管）说了一句，那位同事马上跑过去，对着小的耳语了几句。小的马上起来，说了几句混账祝酒语，就把那杯白酒喝了。他们之间就是这样观察着对方的眼色，随机应变的在说着，做着。我觉的他们的表情很狰狞，我受不了这种人。这也是我不喜欢当公务员，在事业单位，甚至国企里面工作的原因。幸亏我所在的互联网行业里面很少接触到这种人，互联网行业还是算干净的，因为程序员都喜欢干实事，不喜欢来虚的。 我说这些，不是想标榜自己有多清高，只是想多提醒自己 follow my heart，而你也 follow your heart，做自己喜欢的，而不是做别人想要你做的事。","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[]},{"title":"《球状闪电》的宇宙观","slug":"ball-lightning","date":"2012-11-01T12:50:00.000Z","updated":"2016-06-24T17:49:26.000Z","comments":true,"path":"/blog/2012/11/01/ball-lightning/","link":"","permalink":"http://zhenby.com/blog/2012/11/01/ball-lightning/","excerpt":"","text":"宇宙观花了几天时间，把大刘的[《球状闪电》][0]看完了。从看完[三体][1]后，就很喜欢大刘的科幻小说，他的科幻小说，总是给世界、宇宙的存在做出了另一种不一样的诠释。初看《球状闪电》,上篇一度让我看不下去；上篇就是各种诡异的事情：父母被球状闪电所杀、男主角的大学老师张斌、空无一人的屋子竟然还是很干净整齐….. 反正上篇就是各种挖坑。上篇我觉的用书里面的一句话来概括很合适： 爱因斯坦晚年的时候说过：“窗外的每一片树叶，都使人类的科学显的那么的幼稚无力”。 上篇，就是面对着各种诡异的事情，使用各种“幼稚无力”的科学方法去研究球状闪电。多少人因为一辈子就耗在球状闪电中，甩都甩不开，因为他们已经迷上了，但是研究却毫无进展。 人就是这样，有时不知怎的就迷上了一个东西，你就一辈子都甩不开它了。 等到丁仪出现后，小说才开始了它的高潮。丁仪这个物理学家，总是能从一个不同的高度去看待事情，他说: 你们不是想的不够复杂，而是想的不够简单。 什么各种复杂模型去分析球状闪电，都太复杂了。其实球状闪电就是个电子，只是它是个2-3m的电子，是个宏电子。它一直存在在空气中，只是在某些特殊情况下才会被激发而已。什么？宏电子？如果跟电子做一下联想比较的话，那是不是应该还有宏原子？然后又组成宏物质，再形成宏世界呢？大刘就是在构建一个这么宏大的宇宙观，有一个2-3米的电子，那么就有一个超大的原子，这些原子又组成了一个超大的物质。那么地球，是不是只是宏世界里面的一个细胞，抑或一个小球而已？这是平行世界的另一种形式，层层嵌合，可能我们存在的地球里面，还存在一个比我们小一个数量级的宇宙呢。 “我相信宏世界，或者说宏宇宙，但它是什么样子，还是未知中的未知。也许与我们的世界完全不同，也许完全对应，象猜测中的正反物质宇宙那样，存在着宏地球和宏的你我他，要是那样的话，我在宏世界的脑袋一定大得能装下宇宙的银河…..这是不是平行宇宙的另一种表现形式呢?” 最近一集的《生活大爆炸》([第六季第五集][2])，也提到了一种宇宙观： 宇宙可能是张全息图，人类每天在三维空间感受的一切，可能只是宇宙最远地方的全息投影’所以有可能我们的生活了，可能只是在宇宙这张巨大的画布上绘画而已 ![生活大爆炸-全息宇宙观][3] 宇宙存在太多的未解之谜了：宇宙怎么形成的？ 外星文明在哪里？宇宙的尽头在哪里？有时光机吗？平行世界存在吗？仰望星空，我感受到一种无与伦比的空间感，感受到我们人类的渺小与幼稚，我们可能拼搏一生，最后却发现现实世界一切都是泡影，虚幻。我真的希望在我有生之年，人类能解出其中的一些谜团，让我知道这个宇宙的一点秘密。 硬科幻《球状闪电》是本硬科幻的小说，读懂它需要一定的物理功底，[波粒二象性][4]，[量子态][5]，[薛定谔的猫][6]….虽然我高中是读物理的，但是很多地方也只是知道个大概而已。书中关于死于球状闪电的人的解说最让我印象深刻： “所有死于球状闪电的人，都处于量子态，严格地说他们并没有真正死去，他们都是薛定鄂的猫，在不确定总同时处于生与死的两种状态” 死于球状闪电的人是薛定鄂的猫，也就是说当我们不去观察他的时候，他可能是死的，也可能是活的；而由于他们的坍缩态是死亡，当你开始去观察他的时候，他就坍缩到死亡状态了。等等，这不就是我们平常说的鬼嘛 -＿- ，晚上没人的时候才出现，被人见到后马上消失…而这个也解释了前面讲到的空无一人的屋子多年过去了，屋子还是很干净整齐。大刘就这样把迷信用物理装饰成了科幻，虽然唯心，但我觉的很新颖。 推荐喜欢科幻的可以读一读，你的宇宙观是时候 update 一下了。[0]:http://book.douban.com/subject/1192090/[1]:http://book.douban.com/subject/2567698/[2]:http://tv.sohu.com/20121026/n355780022.shtml[3]:http://ww4.sinaimg.cn/mw690/632302ecgw1dyghm1lvt9j.jpg[4]:http://zh.wikipedia.org/wiki/%E6%B3%A2%E7%B2%92%E4%BA%8C%E8%B1%A1%E6%80%A7[5]:http://zh.wikipedia.org/wiki/%E9%87%8F%E5%AD%90%E6%85%8B[6]:http://zh.wikipedia.org/wiki/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84%E7%8C%AB","categories":[{"name":"读书","slug":"读书","permalink":"http://zhenby.com/categories/读书/"}],"tags":[{"name":"大刘","slug":"大刘","permalink":"http://zhenby.com/tags/大刘/"},{"name":"科幻","slug":"科幻","permalink":"http://zhenby.com/tags/科幻/"}]},{"title":"使用一个包含category的静态库","slug":"zai-jing-tai-ku-zhong-shi-yong-category","date":"2012-08-13T04:05:00.000Z","updated":"2016-06-24T17:44:25.000Z","comments":true,"path":"/blog/2012/08/13/zai-jing-tai-ku-zhong-shi-yong-category/","link":"","permalink":"http://zhenby.com/blog/2012/08/13/zai-jing-tai-ku-zhong-shi-yong-category/","excerpt":"","text":"问题一个项目中使用了一个包含 category 的静态库，但是此项目在运行过程中，该静态库调用 category 增加的方法处，却报 selector not recognized 异常。 最佳方案：方案四，赶时间的可以直接查看方案四； 方案一将 category 文件跟静态库一起导入到工程中。 缺点笨，而且多余，在多个地方中存在同一份文件，可能会带来不一致。 方案二不使用 category，将 category 中新增加的方法增加一个参数，此参数就是 category 扩展的类的实例，例如要扩展 NSDictionary，要增加一个(NSString *)JSONString 方法，那么将此方法修改成(NSString *)JSONStringWithDict: (NSDictionary *)dict，也可以实现想要的效果。 缺点如果是自己写的 category ，修改起来还比较简单 ，但是如果是开源项目中包含的 category，改动的工作量会很大；需要额外的类，而且会导致使用 category 的好处尽失。 问题原因上面的两个方案是在搞不清楚那个错误产生的原因时使用的两个简单、直接的方法，但是都太麻烦了。苹果官方文档中的这个 Q&amp;A QA1490:Building Objective-C static libraries with categories 已经说明了这个问题产生的原因： 这个异常是因为标准 UNIX 静态库、linker 以及 Objective-C 的动态性三者之间的实现导致的，Objective-C 不会为方法定义 linker symbols，它只会为每一个类定义 linker symbols。如果你使用 category 扩展了一个已经存在的类，那么 linker 不会将已有类的实现跟 category 的实现连接起来，这就导致了调用静态库中 category 中新增加的方法时抛出 selector not recognized 的异常。 方案三在使用静态库的 target 要将 -ObjC 选项传递给 linker，这个标志将会使得 linker 将静态库中原始类及 category 的类文件都载入！ 设置这个 -ObjC 选项的具体步骤在 Xcode 中，查看使用了静态库的那个 target 的 Building Settings，然后找到 Linking 类别中的 Other Linker Flags 选项，设置其值为 -ObjC ；不过，设置 -ObjC 选项对于 iOS 程序来说有时是不够的，这是因为 linker 中存在一个 bug，所以还是可能会在 -ObjC 的情况下导致 selector not recognized 的异常，为了避免这个 bug，在 Other Linker Flags 中，我们将其值设置为 -all_load 或者 -force_load 即可，见下图： -all_load 与 -force_load 说明 -all_load ：linker 会将所有可见的文件都载入到静态库中 -force_load ：从 Xcode3.2之后才有的选项，能使得文件的载入更细化，每一个你要载入的文件，都要增加一个 -force_load 选项，并且在 -force_load 后面跟上要导入的文件路径，例如：-force_load ../three20/Build/Products/Release-iphoneos/libThree20.a 缺点 使用 -all_load 会导致很多多余文件的导入，会导致静态库体积变大; 使用 -force_load 会很麻烦，要一个个手动添加。 方案四facebook 的 three20 框架也遇到了这个问题，他们给出了一个更好的解决方案：/** * Add this macro before each category implementation, so we don't have to use * -all_load or -force_load to load object files from static libraries that only contain * categories and no classes. * See http://developer.apple.com/library/mac/#qa/qa2006/qa1490.html for more info. */ #define TT_FIX_CATEGORY_BUG(name) @interface TT_FIX_CATEGORY_BUG_##name @end \\ @implementation TT_FIX_CATEGORY_BUG_##name @end上面的宏定义在 TTCorePreprocessorMacros.h 文件中，在每个 category 的实现文件开头加上：TT_FIX_CATEGORY_BUG({cateory名字}) ，这样就能避免在 iOS 中使用 -ObjC 的 linker 的 bug，但是记住，还是需要把使用静态库的 Target 中的 Building Setting 的 Other Linker Flags 设置成 -ObjC 。","categories":[{"name":"编程技术","slug":"编程技术","permalink":"http://zhenby.com/categories/编程技术/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"}]},{"title":"学车被虐记","slug":"xue-che-bei-nue-ji","date":"2012-07-25T03:59:00.000Z","updated":"2016-06-24T17:44:06.000Z","comments":true,"path":"/blog/2012/07/25/xue-che-bei-nue-ji/","link":"","permalink":"http://zhenby.com/blog/2012/07/25/xue-che-bei-nue-ji/","excerpt":"","text":"去年毕业前，大约2011年4月份的时候就报名学车了，过程太艰苦了，直到今天才真正学完。 被迫买烟一开始，跟了一个烂教练（发现大部分教练都这么的烂），教你开车的时候各种骂，好像欠他很多钱一样；11年8月份的时候去考倒桩，考试完后还要叫我们买烟给他，那时候的情景是这样的：我们两个考生去考倒桩，都考过了，然后在回去的路上，他突然停下来， 对我们说：“你们两个，每个人去买包烟，给那个…他只抽五叶神的哦，红色硬盒的那种”。 尼玛，“那个”是哪个啊，那种烟一包21块，而且都考完试了，这不明摆着要我们买给他抽的嘛。那个时候很不爽，就在车里拍了个张照（木有人露脸的，只有那包烟），上传到微博上骂了他一下。 换教练在这个烂教练下面考过了九选三、长途，长途我2012年过年前就考完了，但是一直等到2012年的5月份都还没叫我去练车，一直也没怎么理。直到有一天，那个驾校的总教练打电话给我，说：“网上的那个照片是你发的吗？能不能把它删了。” 一开始我还不知道他在说啥，后来才想起我发过那照片，我说：“我微博很少人看啊，那照片也很少人转啊。” “被我知道他叫你们买烟，我也会骂他，但是现在整班人都知道了，现在很多学生来学车，都指明不要那个Y教练” 不想生事，我还想拿驾照的呢，所以就答应删了，不过也让他帮我换教练了，不然肯定会被那个教练虐的更惨。ps.被驾校知道了教练叫人买烟“孝敬”他，也不处罚，只是受总教练一骂而已。 然后就换了个也是很 SB 的教练，不给人问问题，不给人顶嘴，他说的就要照做。有一次，他在说怎么靠边停车，我就提了个问题：“靠边停车的时候，一直要看着右边的后视镜，除了看后面有没有车外，是不是还可以看一下有没有停到位啊？”“你问这样的问题是不是要找骂啊，我刚才有说过这个吗？没有你乱问什么。”-。- 这样的人也可以当教练，一点师德都没有。 两次路考考路面的时候因为 方向盘不稳 跟 没看后视镜 挂了一次，考官心情不好，先把我们教练骂了一顿，然后又让我们车里面的四个都挂了。今天第二次考，终于遇到个好考官，我再转弯的时候忘了打灯，但是看我开的比较熟，比较稳，还是让我过了。 Tips 学个车很浪费时间，大学的时候有很多时间，可以去浪费浪费，工作了学起来就麻烦了，周末的休息时间都没了。 遇到的教练都是烂教练，刚入行的教练还会好一点，对你客气一点。 教练都是一群心理变态加没事找事骂你的人，你就把他们当笑话看就行了。 去学校的驾校学比较好，比较正规，我路考补考费140，而在其他驾校学的同事都要200，或者300。 路考很大程度看运气，看能不能遇到个好考官，好路况，好路段；今天同考的一个女生，学了三节课，遇到个好路段，过了；第二次考的另一个女生，路段跟路况都比较复杂，这次还是挂了。 感叹一下，驾校教练这个行业，什么时候可以整顿一下，这么差的教学态度，一切的教学都是为了考试的“教学理念”。什么时候才会有好教练平心静气的、耐心的教你开车？现在学车真的是太苦太苦太苦啦。。","categories":[{"name":"生活","slug":"生活","permalink":"http://zhenby.com/categories/生活/"}],"tags":[]},{"title":"在Xcode中使用vim","slug":"zai-xcode-zhong-shi-yong-vim","date":"2012-06-07T06:19:00.000Z","updated":"2016-06-24T17:44:55.000Z","comments":true,"path":"/blog/2012/06/07/zai-xcode-zhong-shi-yong-vim/","link":"","permalink":"http://zhenby.com/blog/2012/06/07/zai-xcode-zhong-shi-yong-vim/","excerpt":"","text":"从服务端转来做客户端半年时间了，编辑工具也从原来的 vim 转成了 Xcode。在 Xcode 使用正常的编辑模式总觉的不太顺手，特别是对比在 vim 中的查找、替换、复制、粘贴、光标跳转、文件切换等操作；我想让我的手更多的时间是在键盘上，方便我马上可以写代码，而 Xcode 中正常的编辑模式，很多情况下都要进行鼠标点击(也可能是我对 Xcode 的快捷键不熟)。 所以就找了 Xcode 的一个 vim插件：XVim，XVim 的使用手册 写了支持的 vim 的命令，支持大部分的 vim 命令，熟悉 vim 的同学可以直接上手就可以再 Xcode 里面用 vim 编辑了。其中一个最好用的命令我觉的就是这个： JumpsC-o, C-i, gd If you want to open the file under the cursor you can use ‘gd’ instead of ‘gf’ in XVim environment. 键入 gd 直接跳转到光标下的类定义文件或者变量定义的地方，而在之前我是使用 command + 鼠标点击 的动作进行跳转的，感觉太麻烦了。 使用这个插件，再用上黑底的配色方案，看起来舒服多了。","categories":[{"name":"效率","slug":"效率","permalink":"http://zhenby.com/categories/效率/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://zhenby.com/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"http://zhenby.com/tags/Xcode/"}]},{"title":"好的作息才能高效工作","slug":"hao-de-zuo-xi-cai-neng-gao-xiao-gong-zuo","date":"2012-06-04T04:54:00.000Z","updated":"2016-06-24T17:50:24.000Z","comments":true,"path":"/blog/2012/06/04/hao-de-zuo-xi-cai-neng-gao-xiao-gong-zuo/","link":"","permalink":"http://zhenby.com/blog/2012/06/04/hao-de-zuo-xi-cai-neng-gao-xiao-gong-zuo/","excerpt":"","text":"最近很烦，一个版本质量好烂，被爆了好多bug，天天加班到很晚，又早早的来改bug，作息规律混乱，感觉身心疲惫。 又临近高考了，这两天，我突然无限的怀念我五年前高考前的一个月。因为那一个月，我的作息太规律了，规律到我竟然没多大的压力，也不急躁，每天的作息是我懂事以来最好的了。那段时间，我每天的行程是这样的： 早上6:00起床，背背语文的古诗古文 8:30出发去上课，最后一个月基本不上课，自己看书，做题 中午12:15回到家，吃个午饭，听英语听力 中午1:15睡午觉，大概半个小时 晚上17:30回到家，看电视，吃饭，洗澡 7:00学习到10:00 10:00上床睡觉我也忘了是什么促使我做了一个这样的决定，但是我真的坚持下来了。那一个月，每天真的就是这么机械式又枯燥，但是良好的作息跟计划让我感觉那段时间无比的舒坦。也因为这样，让我学习效率奇高，每天晚上学习的时候都能弄懂新知识，感觉尼玛就像开挂了一样。 最后高考小爆发，分数竟然超过每一次的模拟考。 所以作息规律很重要，计划也很重要。多少人跟我一样说了很多次早起早睡，却总是坚持了一两天后，就忘记了。也有很多人像我一样，计划今晚要看书的，看了两页，就拿起手机刷微博了。 其实写这个口水文章还有一部分原因是最近看了这篇东东：每天工作四小时的程序员，这样的一天让我很向往：作息规律，思考，进步，高效工作，健身，家庭活动，多么美好的一天。","categories":[{"name":"生活","slug":"生活","permalink":"http://zhenby.com/categories/生活/"}],"tags":[]},{"title":"2011年-后学生时代","slug":"2011","date":"2011-12-31T16:30:00.000Z","updated":"2016-06-24T17:50:07.000Z","comments":true,"path":"/blog/2012/01/01/2011/","link":"","permalink":"http://zhenby.com/blog/2012/01/01/2011/","excerpt":"","text":"本博客的第一篇日志，献给即将过去的2011。 2011年，学生到苦逼上班族的转变 2011年，与蛋蛋开始异地恋了 2011年，变成了微博的重度使用者 2011年，工作有波动，期待2012的工作安排 2011年，阅读很少，不勤奋，浪费了很多时光 2011年，去了北京四天 2011年，好习惯还是没培养成 2011年，体重突破65kg -。- 2011年，学会了游泳，冬天后少运动了，部门篮球赛只拿了第三名 学生-&gt;上班族记得我的QQ签名“学生无限好”保持了四五个月，人总是这样，失去的才觉的曾经的有多好。2011年，一半时间学生，一半时间上班族。而大四的下学期，毕业设计，毕业答辩，各种忙；毕业聚会 ，毕业照，各种伤；学生时光现在回想起来总是最美好的；我特别怀念我的高中，大学，这是两个让我得以改变，升华的时期。 后学生时代的我…苦逼的很，一天又一天周而复始的上班，下班，让我看不出每个工作日有啥区别。没计划，不勤奋，让我觉得有点虚度光阴。直到最近，才让我领悟到了，好习惯的养成很重要，阅读很重要，沟通也很重要。2011年末得知转行做 iOS，让我很兴奋，希望2012能让我在技术上有一点突破。 异地恋与夏小蛋开始了异地恋，距离100多公里，50分钟的车程，28元的车票拥抱变少，珍惜更多。2012年，继续进行 四天北京行第一次去北京，也是第一次去北方，第一次体验到真正地冷…很多的第一次。给我的感觉，帝都有文化底蕴，北京人也比较热情，但是，北京空气真的很不好，灰蒙蒙的天气，不适应，觉得这种天气对人体有害，北京的饭菜口味重，也不太适应；北京交通也堵的慌；四天的北京行基本上有三天都是在工作的，期间逛了天安门，王府井，鸟巢跟水立方。还跟朝阳夜闯八大胡同（听说是清朝时候的妓院），遗憾的是没见到下雪。","categories":[{"name":"生活","slug":"生活","permalink":"http://zhenby.com/categories/生活/"}],"tags":[{"name":"年度总结","slug":"年度总结","permalink":"http://zhenby.com/tags/年度总结/"}]}]}